# -*- coding: utf-8 -*-
"""

@author: Christian T. Kreis, Ruby May A. Sullan -- Department of Physical and Environmental Sciences, University of Toronto Scarborough, 1065 Military Trail, Toronto, ON M1C 1A4, Canada

special thanks to all the members of the Sullan lab for your input on useful functionalities to add, as well as testing the functions with your data


"""


DATA_TYPES = {'short':(2,'h'),'short-data':(2,'h'), 'unsignedshort':(2,'H'),
              'integer-data':(4,'i'), 'signedinteger':(4,'i'),
              'float-data':(4,'f')}


import sys
import os
import time
import datetime
import pickle
import math
import io
import zipfile
import warnings
import traceback
import copy

import threading

import tkinter
import tkinter.ttk
import tkinter.messagebox #does not gets automatically imported....according to stackoverflow
import tkinter.filedialog
#from tkinter import messagebox


import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk


import scipy.linalg


#from copy import deepcopy
from struct import unpack
from scipy.optimize import curve_fit
from scipy.signal import savgol_filter
#from scipy import interpolate
from scipy.optimize import fsolve


_COLOR_MAPS = ['viridis', 'plasma', 'inferno', 'magma', 'cividis', 'Greys', 'Purples', 'Blues', 'Greens', 'Oranges', 'Reds', 'YlOrBr', 'YlOrRd', 'OrRd', 'PuRd', 'RdPu', 'BuPu', 'GnBu', 'PuBu', 'YlGnBu', 'PuBuGn', 'BuGn', 'YlGn', 'binary', 'gist_yarg', 'gist_gray', 'gray', 'bone', 'pink', 'spring', 'summer', 'autumn', 'winter', 'cool', 'Wistia', 'hot', 'afmhot', 'gist_heat', 'copper', 'PiYG', 'PRGn', 'BrBG', 'PuOr', 'RdGy', 'RdBu', 'RdYlBu', 'RdYlGn', 'Spectral', 'coolwarm', 'bwr', 'seismic', 'twilight', 'twilight_shifted', 'hsv', 'Pastel1', 'Pastel2', 'Paired', 'Accent', 'Dark2', 'Set1', 'Set2', 'Set3', 'tab10', 'tab20', 'tab20b', 'tab20c', 'flag', 'prism', 'ocean', 'gist_earth', 'terrain', 'gist_stern', 'gnuplot', 'gnuplot2', 'CMRmap', 'cubehelix', 'brg', 'gist_rainbow', 'rainbow', 'jet', 'nipy_spectral', 'gist_ncar']





warnings.simplefilter('ignore', RuntimeWarning)
warnings.simplefilter('ignore', np.RankWarning)


class QIMap():

    def __init__(self):

        self.class_version = '14.alpha'
        self.file_info = dict()
        #self.file_info['save_directory'] = os.getcwd()

        self.sample_fd_curve = dict()
        self.jpk_qi_data = None
        self.data = dict()


        self.channels = list()
        self.channel_units = dict()

        self.settings = dict()

        self.calibrations = dict()


        self.keys = dict()

        self.corrections = dict()
        self.corrections_pass_to_function = dict() #adds some additional dict members so that all possible combinations are covered
        self.units = dict()

        self.selections = dict()

        self.control_variables = dict()
        self.control_variables['file_imported'] = False
        self.control_variables['sample_fd_extracted'] = False
        self.control_variables['cantilever_calibrated'] = False
        self.control_variables['allow_analysis'] = False

        #self.noise_level = dict()
        #self.max_adhesion_force = dict()
        #self.adhesion_energy = dict()
        #self.snap_in = dict()
        #self.rupture_length = dict()
        #self.adhesion_signatures = dict()
        self.hertz_fit = dict()
        self.hertz_fit['full_map'] = dict()
        self.hertz_fit['selections'] = dict()

        self.apparent_layer = dict()
        self.apparent_layer['basic'] = dict()
        self.apparent_layer['hertz_fit'] = dict()
        self.apparent_layer['setpoint'] = dict()
        self.apparent_layer['selections'] = dict()

        self.linearized_hertz_fit = dict()
        self.linearized_hertz_fit['full_map'] = dict()
        self.linearized_hertz_fit['selections'] = dict()

        self.two_layer_hertz = dict()
        self.two_layer_hertz['full_map'] = dict()
        self.two_layer_hertz['selections'] = dict()

        self.multi_layer_hertz = dict()
        self.multi_layer_hertz['full_map'] = dict()
        self.multi_layer_hertz['selections'] = dict()

        self.baseline_tilt = dict()
        self.baseline_tilt['full_map'] = dict()
        self.baseline_tilt['full_map']['extend'] = dict()
        self.baseline_tilt['full_map']['retract'] = dict()
        self.baseline_tilt['selections'] = dict()

        self.slope_contact = dict()
        self.slope_contact['full_map'] = dict()
        self.slope_contact['full_map']['extend'] = dict()
        self.slope_contact['full_map']['retract'] = dict()
        self.slope_contact['selections'] = dict()

        self.breakthrough_events = dict()
        self.breakthrough_events['full_map'] = dict()
        self.breakthrough_events['selections'] = dict()

        self.counter = {'count': None, 'max': None, 'select': None}
        #self.counter = {'count': tkinter.IntVar(None),'max': tkinter.IntVar(None)}


# %% combined stuff

    def import_data(self, filepath, x_key = str()):

        if os.path.isfile(filepath):

            if filepath[filepath.rfind('.'):] == '.jpk-qi-data':

                self.file_info['filename'] = os.path.normpath(filepath)
                self._import_jpk_qi_file(filepath, x_key)


            else:

                raise TypeError('ERROR! Given file is not a jpk-force file!')


        else:

            raise ValueError('ERROR! Given filepath or filename is incorrect!')




    def set_corrections(self):

        if len(self.sample_fd_curve['object'].corrections) == 0:

              raise ValueError('ERROR! Perform corrections on sample fd_curve first!')

        else:

            self.corrections = dict()
            self.corrections_pass_to_function = dict()


            self.corrections = copy.deepcopy(self.sample_fd_curve['object'].corrections)
            self.units = copy.deepcopy(self.sample_fd_curve['object'].units)

            #self.units = deepcopy(self.sample_fd_curve['object'].units)
            self.corrections_pass_to_function = copy.deepcopy(self.sample_fd_curve['object'].corrections)



            if type(self.corrections['baseline_correction']) is dict:

                self.corrections_pass_to_function['baseline_correction']['applied'] = True

                if 'parameter' in self.corrections['baseline_correction'].keys():
                    del self.corrections['baseline_correction']['parameter']
                if 'parameter' in self.corrections_pass_to_function['baseline_correction'].keys():
                    del self.corrections_pass_to_function['baseline_correction']['parameter']

            elif type(self.corrections['baseline_correction']) is bool and not self.corrections['baseline_correction']:
                self.corrections_pass_to_function['baseline_correction'] = dict()
                self.corrections_pass_to_function['baseline_correction']['applied'] = False


            if type(self.corrections['distance_correction']) is dict:

                self.corrections_pass_to_function['distance_correction']['applied'] = True

                if 'parameter' in self.corrections['distance_correction'].keys():
                    del self.corrections['distance_correction']['parameter']
                if 'parameter' in self.corrections_pass_to_function['distance_correction'].keys():
                    del self.corrections_pass_to_function['distance_correction']['parameter']
                if 'smooth_applied' not in self.corrections_pass_to_function['distance_correction'].keys():
                    self.corrections_pass_to_function['distance_correction']['smooth_applied'] = False
                if 'sensitivity 'not in self.corrections_pass_to_function['distance_correction'].keys():
                    self.corrections_pass_to_function['distance_correction']['sensitivity'] = 1
                if 'length_fit 'not in self.corrections_pass_to_function['distance_correction'].keys():
                    self.corrections_pass_to_function['distance_correction']['length_fit'] = 20
                if 'length_mean 'not in self.corrections_pass_to_function['distance_correction'].keys():
                    self.corrections_pass_to_function['distance_correction']['smooth_length'] = 51
                if 'means_above_baseline 'not in self.corrections_pass_to_function['distance_correction'].keys():
                    self.corrections_pass_to_function['distance_correction']['means_above_baseline'] = 10

            elif type(self.corrections['distance_correction']) is bool and not self.corrections['distance_correction']:

                self.corrections_pass_to_function['distance_correction'] = dict()
                self.corrections_pass_to_function['distance_correction']['applied'] = False

            self.control_variables['allow_analysis'] = self.sample_fd_curve['object'].control_variables['allow_analysis']

            if not os.path.isdir(self.file_info['save_directory']):

                os.makedirs(self.file_info['save_directory'])






    def set_save_directory(self, directory, auto_dir = True):

        if self.control_variables['file_imported']:

            if auto_dir:

                if os.path.isdir(directory):

                    parent_directory = directory
                    final_directory = os.path.normpath(os.path.join(parent_directory,self.file_info['file_org']))

                    if not os.path.isdir(final_directory):

                        os.makedirs(final_directory)

                    self.file_info['save_directory'] = os.path.normpath(final_directory)

                else:

                    if os.path.isabs(directory):

                        parent_directory = directory
                        final_directory = os.path.normpath(os.path.join(parent_directory,self.file_info['file_org']))

                    else:

                        final_directory = self.file_info['filename'][:self.file_info['filename'].rfind('.')]

                    os.makedirs(final_directory)
                    self.file_info['save_directory'] = os.path.normpath(final_directory)

            else:

                if not os.path.isdir(directory):

                    try:

                        os.makedirs(directory)
                        final_directory = directory
                        self.file_info['save_directory'] = os.path.normpath(final_directory)

                    except:

                        raise ValueError('ERROR! Specify valid directory!')

        else:

            raise ValueError('ERROR! Import file first!')




    def save_snapshot(self):

        timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')

        if not os.path.isdir(self.file_info['save_directory']):

            try:

                os.makedirs(self.file_info['save_directory'])

            except:

                raise ValueError('ERROR! Save directory is no valid directory!')



        file_pickle = os.path.join(self.file_info['save_directory'], '.snap_shot.' + self.file_info['file_org'] + '_analysis_'+ timestamp + '.pkl')
        out_pkl = open(file_pickle, 'wb')


        save_qi_map = dict()

        save_qi_map['class_version'] = copy.deepcopy(self.class_version)
        save_qi_map['file_info'] = copy.deepcopy(self.file_info)

        #save_qi_map['sample_fd_curve'] = copy.deepcopy(self.sample_fd_curve)
        #self.jpk_qi_data = None # would be too much storage space
        save_qi_map['sample_fd_curve'] = None

        save_qi_map['data'] = copy.deepcopy(self.data)
        save_qi_map['selections'] = copy.deepcopy(self.selections)

        save_qi_map['channels'] = copy.deepcopy(self.channels)
        save_qi_map['channel_units'] = copy.deepcopy(self.channel_units)
        save_qi_map['settings'] = copy.deepcopy(self.settings)
        save_qi_map['calibrations'] = copy.deepcopy(self.calibrations)
        save_qi_map['keys'] = copy.deepcopy(self.keys)
        save_qi_map['corrections'] = copy.deepcopy(self.corrections)
        save_qi_map['units'] = copy.deepcopy(self.units)
        save_qi_map['corrections_pass_to_function'] = copy.deepcopy(self.corrections_pass_to_function)

        save_qi_map['control_variables'] = copy.deepcopy(self.control_variables)
        save_qi_map['selections'] = copy.deepcopy(self.selections)

        #self.noise_level = dict()
        #self.max_adhesion_force = dict()
        #self.adhesion_energy = dict()
        #self.snap_in = dict()
        #self.rupture_length = dict()
        #self.adhesion_signatures = dict()

        save_qi_map['hertz_fit'] = copy.deepcopy(self.hertz_fit)
        save_qi_map['linearized_hertz_fit'] = copy.deepcopy(self.linearized_hertz_fit)
        save_qi_map['two_layer_hertz'] = copy.deepcopy(self.two_layer_hertz)
        save_qi_map['multi_layer_hertz'] = copy.deepcopy(self.multi_layer_hertz)

        save_qi_map['apparent_layer'] = copy.deepcopy(self.apparent_layer)
        save_qi_map['baseline_tilt'] = copy.deepcopy(self.baseline_tilt)
        save_qi_map['slope_contact'] = copy.deepcopy(self.slope_contact)
        save_qi_map['breakthrough_events'] = copy.deepcopy(self.breakthrough_events)

        pickle.dump(save_qi_map, out_pkl)
        out_pkl.close()




    def dummy_function(self):

        print(self.data)


    def load_snapshot(self, file):

        in_pkl = open(file, 'rb')
        qi_loaded = pickle.load(in_pkl)
        in_pkl.close()

        if not self.class_version == qi_loaded['class_version']:

            print('\aLoaded snapshot was created with another class version. There might be inconsistencies!')
            #input = input('Do you want to proceed <Y/N>?')
            #print(input)

        self.file_info = qi_loaded['file_info']
        self.sample_fd_curve = qi_loaded['sample_fd_curve']
        self.data = qi_loaded['data']

        self.channels = qi_loaded['channels']
        self.channel_units = qi_loaded['channel_units']
        self.settings = qi_loaded['settings']
        self.calibrations = qi_loaded['calibrations']
        self.keys = qi_loaded['keys']
        self.corrections = qi_loaded['corrections']
        self.corrections_pass_to_function = qi_loaded['corrections_pass_to_function']
        self.units = qi_loaded['units']

        self.control_variables = qi_loaded['control_variables']
        self.selections = qi_loaded['selections']

        #self.noise_level = dict()
        #self.max_adhesion_force = dict()
        #self.adhesion_energy = dict()
        #self.snap_in = dict()
        #self.rupture_length = dict()
        #self.adhesion_signatures = dict()

        self.hertz_fit = qi_loaded['hertz_fit']
        self.linearized_hertz_fit = qi_loaded['linearized_hertz_fit']
        self.two_layer_hertz = qi_loaded['two_layer_hertz']
        self.multi_layer_hertz = qi_loaded['multi_layer_hertz']

        self.apparent_layer = qi_loaded['apparent_layer']
        self.baseline_tilt = qi_loaded['baseline_tilt']
        self.slope_contact = qi_loaded['slope_contact']
        self.breakthrough_events = qi_loaded['breakthrough_events']






    def save_object_snapshot(self):

        timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')

        if not os.path.isdir(self.file_info['save_directory']):

            try:

                os.makedirs(self.file_info['save_directory'])

            except:

                raise ValueError('ERROR! Save directory is no valid directory!')


        file_pickle = os.path.join(self.file_info['save_directory'], '.object_snap_shot.' + self.file_info['file_org'] + '_analysis_'+ timestamp + '.pkl')
        out_pkl = open(file_pickle, 'wb')


        save_qi_map = QIMap()

        save_qi_map.class_version = copy.deepcopy(self.class_version)
        save_qi_map.file_info = copy.deepcopy(self.file_info)

        save_qi_map.sample_fd_curve = copy.deepcopy(self.sample_fd_curve)
        #self.jpk_qi_data = None # would be too much storage space

        save_qi_map.data = copy.deepcopy(self.data)
        save_qi_map.selections = copy.deepcopy(self.selections)

        save_qi_map.channels = copy.deepcopy(self.channels)
        save_qi_map.channel_units = copy.deepcopy(self.channel_units)
        save_qi_map.settings = copy.deepcopy(self.settings)
        save_qi_map.calibrations = copy.deepcopy(self.calibrations)
        save_qi_map.keys = copy.deepcopy(self.keys)
        save_qi_map.corrections = copy.deepcopy(self.corrections)
        save_qi_map.units = copy.deepcopy(self.units)
        save_qi_map.corrections_pass_to_function = copy.deepcopy(self.corrections_pass_to_function)

        save_qi_map.control_variables = copy.deepcopy(self.control_variables)
        save_qi_map.selections = copy.deepcopy(self.selections)

        #self.noise_level = dict()
        #self.max_adhesion_force = dict()
        #self.adhesion_energy = dict()
        #self.snap_in = dict()
        #self.rupture_length = dict()
        #self.adhesion_signatures = dict()

        save_qi_map.hertz_fit = copy.deepcopy(self.hertz_fit)
        save_qi_map.linearized_hertz_fit = copy.deepcopy(self.linearized_hertz_fit)
        save_qi_map.two_layer_hertz = copy.deepcopy(self.two_layer_hertz)
        save_qi_map.multi_layer_hertz = copy.deepcopy(self.multi_layer_hertz)

        save_qi_map.apparent_layer = copy.deepcopy(self.apparent_layer)
        save_qi_map.baseline_tilt = copy.deepcopy(self.baseline_tilt)
        save_qi_map.slope_contact = copy.deepcopy(self.slope_contact)
        save_qi_map.breakthrough_events = copy.deepcopy(self.breakthrough_events)

        pickle.dump(save_qi_map, out_pkl)
        out_pkl.close()




    def load_object_snapshot(self, file):

        in_pkl = open(file, 'rb')
        qi_loaded = pickle.load(in_pkl)
        in_pkl.close()

        if not self.class_version == qi_loaded.class_version:
        #
            print('\aLoaded snapshot was created with another class version. There might be inconsistencies!')


        self.file_info = qi_loaded.file_info
        self.sample_fd_curve = qi_loaded.sample_fd_curve
        self.data = qi_loaded.data

        self.channels = qi_loaded.channels
        self.channel_units = qi_loaded.channel_units
        self.settings = qi_loaded.settings
        self.calibrations = qi_loaded.calibrations
        self.keys = qi_loaded.keys
        self.corrections = qi_loaded.corrections
        self.corrections_pass_to_function = qi_loaded.corrections_pass_to_function
        self.units = qi_loaded.units

        self.control_variables = qi_loaded.control_variables
        self.selections = qi_loaded.selections

        #self.noise_level = dict()
        #self.max_adhesion_force = dict()
        #self.adhesion_energy = dict()
        #self.snap_in = dict()
        #self.rupture_length = dict()
        #self.adhesion_signatures = dict()

        self.hertz_fit = qi_loaded.hertz_fit
        self.linearized_hertz_fit = qi_loaded.linearized_hertz_fit
        self.two_layer_hertz = qi_loaded.two_layer_hertz
        self.multi_layer_hertz = qi_loaded.multi_layer_hertz

        self.apparent_layer = qi_loaded.apparent_layer
        self.baseline_tilt = qi_loaded.baseline_tilt
        self.slope_contact = qi_loaded.slope_contact
        self.breakthrough_events = qi_loaded.breakthrough_event






    def re_import_jpk_raw_data(self, file = str()):

        if not file:

            filepath = self.file_info['filename']

        else:

            filepath = file

        self.jpk_qi_data = JPK_QIFile()
        self.jpk_qi_data.open_qi_file(filepath)




#     def show_fd_preview(self):
#
#
#         app = QI_FD_Preview(self)
#         app.mainloop() #see comments in class itself
# #        app.root.mainloop()
#
#         # if class inheritance is used and QI_FD_Preview inherits tkinter.Tk than app.mainloop is enough
#         # if tkinter.Tk is a member of QI_FD_Preview, than I would assign it to self.root = tkinter.Tk(), and then app.root.mainloop() is necessary
#











# %% sample fd curves tuff

    def open_sample_fd_curve(self, index = 0, graph_select = False, data_key = 'topography'):

        if graph_select :

            label_key = ''

            if type(data_key) is not list:

                data_key = [data_key]


            data = self.data

            while len(data_key):

                key = data_key.pop(0)
                data = data[key]

                if label_key == '':

                    label_key = str(key)

                else:

                    label_key = label_key + '-' + str(key)


            data_plot = data


            fig1 = plt.figure()
            ax1 = fig1.add_subplot(111)
            c1 = ax1.imshow(data_plot, origin = 'lower', cmap = 'afmhot')
            cbar1 = fig1.colorbar(c1, ax=ax1)
            cbar1.set_label(label_key, rotation = 270, labelpad = 20)
            ax1.set_xlabel('Position / pixel')
            ax1.set_ylabel('Position / pixel')
            ax1.set_title('Select fd-curve of interestbpy clicking to a point')

            point = plt.ginput(1)
            ind = int(round(point[0][1]) * self.settings['grid']['y'] + round(point[0][0]))

            plt.close(fig1)

            if ind not in self.settings['fd_indices']['list']:

                  ind = self.settings['fd_indices']['list'][0]


        else:

            if index not in self.settings['fd_indices']['list']:

                  ind = self.settings['fd_indices']['list'][0]

            else:

                  ind = index


        self.sample_fd_curve['index'] = ind
        self.sample_fd_curve['grid_index'] = ((ind) % self.settings['grid']['x'],int(ind / self.settings['grid']['y']))
        self.sample_fd_curve['object'] = self.extract_fd_curve(ind)
        self.sample_fd_curve['object'].control_variables['file_imported'] = True
        self.sample_fd_curve['object'].control_variables['cantilever_calibrated'] = self.control_variables['cantilever_calibrated']
        self.control_variables['sample_fd_extracted'] = True




    def correct_sample_fd_curve(self, **kwargs):

        if self.control_variables['sample_fd_extracted']:

            self.sample_fd_curve['object'].correct_data(**kwargs)

        else:

            raise ValueError('ERROR! Open a sample force distance curve first')




    def plot_sample_fd_curve(self, col1 = '', col2 = '', ax = 0, **kwargs):

        if self.control_variables['sample_fd_extracted']:

            self.sample_fd_curve['object'].data_plot(col1, col2, ax, **kwargs)

        else:

            raise ValueError('ERROR! Open a sample force distance curve first')



# %% data analysis stuff


    def get_topography(self, perc_setpoint = 0.8, export = False):

        timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
        sys.stdout.write('\rExtract topography: %.2f%% <%d/%d>' %(0, 0, self.settings['fd_indices']['total']))
        log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_topography.' + timestamp +'.txt'), 'w')

        count = 1
        self.counter['count'] = 0
        self.counter['max'] = self.settings['fd_indices']['total'] - 1
        data = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)

        for ind in self.settings['fd_indices']['list']:

            y = int(ind / self.settings['grid']['y'])
            x = (ind) % self.settings['grid']['x']

            try:

                fd = self.extract_fd_curve_batch(ind)

                # baseline calculated as the mean of the first 10% of points
                end_index = np.argmax(fd.data['extend'][self.keys['y_key']] > perc_setpoint * self.settings['setpoint']['force (N)'] + np.mean(fd.data['extend'][self.keys['y_key']][0:int(0.1*fd.settings['samples']['extend'])]))

                if not end_index:
                    end_index = -1

                data[y][x] = fd.data['extend'][self.keys['x_key']][end_index]

            except:

                log_file.write('An error occured while processing index ' + str(ind) + '\n')

            finally:

                sys.stdout.write('\rExtract topography: %.2f%% <%d/%d>' %(count/self.settings['fd_indices']['total']*100, count,self.settings['fd_indices']['total']))
                count += 1
                self.counter['count'] += 1



        data = data * 10**6

        self.data['topography'] = copy.deepcopy(data)
        sys.stdout.write(' -- Done!\n')

        if export:

            try:

                file_pickle = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + '.topography.' + timestamp + '.pkl')
                out_pkl = open(file_pickle, 'wb')

                pickle.dump(data, out_pkl)

            except:

                 log_file.write('ERROR! Cannot open/write file ' + file_pickle)

            finally:

                 out_pkl.close()

        log_file.close()




    def get_topography_contact_point(self, perc_setpoint = 0.8, method = 'standard', export = False):

        if method == 'standard':

            timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
            sys.stdout.write('\rExtract contact_point topography: %.2f%% <%d/%d>' %(0, 0, self.settings['fd_indices']['total']))
            log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_topography_contact_point.' + timestamp +'.txt'), 'w')

            count = 1
            data = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)

            for ind in self.settings['fd_indices']['list']:

                y = int(ind / self.settings['grid']['y'])
                x = (ind) % self.settings['grid']['x']

                try:

                    fd = self.extract_fd_curve_batch(ind)

                    # baseline calculated as the mean of the first 10% of points

                    #z_pos = fd.data['extend'][self.keys['x_key']][-1]

                    fd.correct_data(force_unit = self.corrections_pass_to_function['force_unit'],
                                    distance_unit = 'um',
                                    noise_lvl = self.corrections_pass_to_function['noise_lvl'],
                                    distance_correction = {'applied': False},
                                    baseline_correction = self.corrections_pass_to_function['baseline_correction'],
                                    get_tip_sample_separation = self.corrections_pass_to_function['get_tip_sample_separation'])


                    #thickness = abs(fd.data['extend'][self.keys['ts_key']][-1])


                    ctc_point = fd.get_zero_force_intersect_extend()
                    data[y][x] = fd.data['extend'][self.keys['x_key']][ctc_point['index']]

                except:

                    log_file.write('An error occured while processing index ' + str(ind) + '\n')

                finally:

                    sys.stdout.write('\rExtract contact_point topography: %.2f%% <%d/%d>' %(count/self.settings['fd_indices']['total']*100, count,self.settings['fd_indices']['total']))
                    count += 1

            #data = data * 10**6

        elif method == 'hertz' and self.hertz_fit['full_map']['analyzed']:

            timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
            sys.stdout.write('\rExtract contact_point_hertz topography: %.2f%% <%d/%d>' %(0, 0, self.settings['fd_indices']['total']))
            log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_topography_contact_point_hertz.' + timestamp +'.txt'), 'w')

            count = 1
            data = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)

            for ind in self.settings['fd_indices']['list']:

                y = int(ind / self.settings['grid']['y'])
                x = (ind) % self.settings['grid']['x']

                try:

                    fd = self.extract_fd_curve_batch(ind)

                    # baseline calculated as the mean of the first 10% of points


                    data[y][x] = fd.data['extend'][self.keys['x_key']][self.hertz_fit['standard'][ind]['contact_point_index']]

                except:

                    log_file.write('An error occured while processing index ' + str(ind) + '\n')

                finally:

                    sys.stdout.write('\rExtract contact_point_hertz topography: %.2f%% <%d/%d>' %(count/self.settings['fd_indices']['total']*100, count,self.settings['fd_indices']['total']))
                    count += 1

            data = data * 10**6

        else:

            raise ValueError('ERROR! Chose valid method!')


        self.data['topography_contact_point'] = copy.deepcopy(data)
        sys.stdout.write(' -- Done!\n')

        if export:

            try:

                file_pickle = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + '.topography_contact_point.' + timestamp + '.pkl')
                out_pkl = open(file_pickle, 'wb')

                pickle.dump(data, out_pkl)

            except:

                 log_file.write('ERROR! Cannot open/write file ' + file_pickle)

            finally:

                 out_pkl.close()

        log_file.close()




    def get_topography_no_log(self, perc_setpoint = 0.8, export = False):

        timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
        sys.stdout.write('\rExtract topography: %.2f%% <%d/%d>' %(0, 0, self.settings['fd_indices']['total']))

        count = 1
        self.counter['count'] = 0
        self.counter['max'] = self.settings['fd_indices']['total'] - 1
        data = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)

        for ind in self.settings['fd_indices']['list']:

            y = int(ind / self.settings['grid']['y'])
            x = (ind) % self.settings['grid']['x']

            try:

                fd = self.extract_fd_curve_batch(ind)

                # baseline calculated as the mean of the first 10% of points
                end_index = np.argmax(fd.data['extend'][self.keys['y_key']] > perc_setpoint * self.settings['setpoint']['force (N)'] + np.mean(fd.data['extend'][self.keys['y_key']][0:int(0.1*fd.settings['samples']['extend'])]))

                if not end_index:
                    end_index = -1

                data[y][x] = fd.data['extend'][self.keys['x_key']][end_index]

            except:

                sys.stdout.write('An error occured while processing index ' + str(ind) + '\n')

            finally:

                sys.stdout.write('\rExtract topography: %.2f%% <%d/%d>' %(count/self.settings['fd_indices']['total']*100, count,self.settings['fd_indices']['total']))
                count += 1
                self.counter['count'] += 1



        data = data * 10**6

        self.data['topography'] = copy.deepcopy(data)
        sys.stdout.write(' -- Done!\n')

        if export:

            try:

                file_pickle = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + '.topography.' + timestamp + '.pkl')
                out_pkl = open(file_pickle, 'wb')

                pickle.dump(data, out_pkl)

            except:

                 sys.stdout.write('ERROR! Cannot open/write file ' + file_pickle)

            finally:

                 out_pkl.close()






    def fit_hertz_model(self, selection = False,
                        mode = 'free_contact_point',
                        residuals_baseline_weight = 0,
                        y_offset = 'zero',
                        distance_to_contact = 50, poisson_ratio = 0.5,
                        indenter_characteristics = {'geometry': 'parabolic', 'radius [nm]': 10},
                        max_indentation = np.inf, force_limit = np.inf, #threshold_sensitivity = 0,
                        min_fit_length = 20,
                        **kwargs):

        if self.control_variables['allow_analysis']:

#            if bool(selection) and selection in self.selections.keys():
            if bool(selection):

                if type(selection) is not list:

                    selection = [selection]

                for select in selection:

                    if select in self.selections.keys():

                        self.hertz_fit['selections'][select] = dict()

                        self.hertz_fit['selections'][select]['indenter'] = indenter_characteristics

                        self.hertz_fit['selections'][select]['method'] = dict()
                        self.hertz_fit['selections'][select]['method']['type'] = 'standard'
                        self.hertz_fit['selections'][select]['method']['parameter'] = dict()
                        self.hertz_fit['selections'][select]['method']['parameter']['force_limit'] = force_limit
                        self.hertz_fit['selections'][select]['method']['parameter']['max_indentation'] = max_indentation
                        self.hertz_fit['selections'][select]['method']['parameter']['distance_to_contact'] = distance_to_contact
                        self.hertz_fit['selections'][select]['method']['parameter']['min_fit_length'] = min_fit_length
                        #self.hertz_fit['selections'][select]['method']['parameter']['threshold_sensitivity'] = threshold_sensitivity
                        self.hertz_fit['selections'][select]['method']['parameter']['mode'] = mode
                        if mode == "free_contact_point":
                            self.hertz_fit['selections'][select]['method']['parameter']['y_offset'] = y_offset
                        else:
                            self.hertz_fit['selections'][select]['method']['parameter']['y_offset'] = 'zero'
                        self.hertz_fit['selections'][select]['method']['parameter']['residuals_baseline_weight'] = residuals_baseline_weight


                        self.hertz_fit['selections'][select]['filter'] = dict()
                        self.hertz_fit['selections'][select]['filter']['type'] = 'none'


                        timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                        sys.stdout.write('\rFitting Hertz model - Selection %s: %.2f%% <%d/%d>' %(select,0, 0, len(self.selections[select]['fd_index'])))

                        log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_hertz_standard.' + timestamp +'.txt'), 'w')


                        count = 1
                        self.counter['select'] = select
                        self.counter['count'] = 0
                        self.counter['max'] = len(self.selections[select]['fd_index']) - 1
                        #data = np.zeros((self.settings['grid']['y'], self.settings['grid']['x']))
                        #data_error = np.zeros((self.settings['grid']['y'], self.settings['grid']['x']))

                        if indenter_characteristics['geometry'] == 'spherical':

                            conv_list = Conversion_List_Spherical_Indenter_Hertz(indenter_characteristics['radius [nm]'],1, int(self.settings['z-length']['extend']*10**9)+10)
                            indenter_characteristics['contact_circle_conversion'] = conv_list

                        self.hertz_fit['selections'][select]['indices'] = dict()

                        for ind in self.selections[select]['fd_index']:

                            #y = int(ind / self.settings['grid']['y'])
                            #x = (ind) % self.settings['grid']['x']

                            self.hertz_fit['selections'][select]['indices'][ind] = dict()

                            try:

                                fd = self.extract_fd_curve(ind)
                                fd.set_save_directory(self.file_info['save_directory'])
                                fd.correct_data(force_unit = self.corrections_pass_to_function['force_unit'],
                                                distance_unit = self.corrections_pass_to_function['distance_unit'],
                                                noise_lvl = self.corrections_pass_to_function['noise_lvl'],
                                                distance_correction = self.corrections_pass_to_function['distance_correction'],
                                                baseline_correction = self.corrections_pass_to_function['baseline_correction'],
                                                get_tip_sample_separation = self.corrections_pass_to_function['get_tip_sample_separation'])

                                fd.fit_hertz_model(mode = mode,
                                                   residuals_baseline_weight = residuals_baseline_weight,
                                                   y_offset = y_offset,
                                                   distance_to_contact = distance_to_contact,
                                                   poisson_ratio = poisson_ratio,
                                                   indenter_characteristics = indenter_characteristics,
                                                   max_indentation = max_indentation, force_limit = force_limit,
                                                   min_fit_length = min_fit_length,
                                                   **kwargs)

                                self.hertz_fit['selections'][select]['indices'][ind]['young_modulus'] = fd.hertz_fit['young_modulus']
                                self.hertz_fit['selections'][select]['indices'][ind]['best_fit'] = fd.hertz_fit['best_fit']
                                self.hertz_fit['selections'][select]['indices'][ind]['residuals'] = fd.hertz_fit['residuals']
                                self.hertz_fit['selections'][select]['indices'][ind]['except'] = False

                            except:

                                self.hertz_fit['selections'][select]['indices'][ind]['except'] = True
                                self.hertz_fit['selections'][select]['indices'][ind]['young_modulus'] = {'value': np.nan, 'unit': 'Pa', 'factor': 1}
                                log_file.write('-------------------------------\n')
                                log_file.write('An error occured while processing index ' + str(ind) + '\n')
                                traceback.print_exc(file = log_file)

                            finally:

                                sys.stdout.write('\rFitting Hertz model - Selection %s: %.2f%% <%d/%d>' %(select,count/len(self.selections[select]['fd_index'])*100, count,len(self.selections[select]['fd_index'])))
                                count += 1
                                self.counter['count'] += 1


                        self.hertz_fit['selections'][select]['poisson_ratio'] = poisson_ratio


                        self.hertz_fit['selections'][select]['units'] = copy.deepcopy(self.units)
                        self.hertz_fit['selections'][select]['e_modul_unit'] = 'Pa'
                        self.hertz_fit['selections'][select]['e_modul_factor'] = 1
                        self.hertz_fit['selections'][select]['corrections'] = copy.deepcopy(self.corrections_pass_to_function)

                        sys.stdout.write(' -- Done!\n')

                        try:

                            file_pickle = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + '.hertz_standard.'+ timestamp+ '.'+ select + '.pkl')
                            out_pkl = open(file_pickle, 'wb')
                            pickle.dump(self.hertz_fit['selections'][select], out_pkl)

                        except:

                            log_file.write('-------------------------------\n')
                            log_file.write('ERROR! Cannot open/write file ' + file_pickle)
                            traceback.print_exc(file = log_file)

                        finally:

                            out_pkl.close()


                        log_file.close()


                    elif select not in self.selections.keys():

                        print('ERROR! Selection', select,'is not a valid selection.')


            elif ('plot_result' in kwargs and kwargs['plot_result']) or ('export_result' in kwargs and kwargs['export_result']):

                self.hertz_fit['full_map']['indenter'] = indenter_characteristics

                self.hertz_fit['full_map']['method'] = dict()
                self.hertz_fit['full_map']['method']['type'] = 'standard'
                self.hertz_fit['full_map']['method']['parameter'] = dict()
                self.hertz_fit['full_map']['method']['parameter']['force_limit'] = force_limit
                self.hertz_fit['full_map']['method']['parameter']['max_indentation'] = max_indentation
                self.hertz_fit['full_map']['method']['parameter']['distance_to_contact'] = distance_to_contact
                self.hertz_fit['full_map']['method']['parameter']['min_fit_length'] = min_fit_length
                #self.hertz_fit['full_map']['method']['parameter']['threshold_sensitivity'] = threshold_sensitivity
                self.hertz_fit['full_map']['method']['parameter']['residuals_baseline_weight'] = residuals_baseline_weight
                self.hertz_fit['full_map']['method']['parameter']['mode'] = mode
                if mode == "free_contact_point":
                    self.hertz_fit['full_map']['method']['parameter']['y_offset'] = y_offset
                else:
                    self.hertz_fit['full_map']['method']['parameter']['y_offset'] = 'zero'


                self.hertz_fit['full_map']['filter'] = dict()
                self.hertz_fit['full_map']['filter']['type'] = 'none'

                timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                sys.stdout.write('\rFitting Hertz model - with plot/export results: %.2f%% <%d/%d>' %(0, 0, self.settings['fd_indices']['total']))
                log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_hertz_standard.' + timestamp +'.txt'), 'w')

                count = 1
                self.counter['count'] = 0
                self.counter['max'] = self.settings['fd_indices']['total'] - 1

                data = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_error = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)

                if indenter_characteristics['geometry'] == 'spherical':

                    conv_list = Conversion_List_Spherical_Indenter_Hertz(indenter_characteristics['radius [nm]'],1, int(self.settings['z-length']['extend']*10**9)+10)
                    indenter_characteristics['contact_circle_conversion'] = conv_list


                self.hertz_fit['full_map']['indices'] = dict()

                for ind in self.settings['fd_indices']['list']:

                    y = int(ind / self.settings['grid']['y'])
                    x = (ind) % self.settings['grid']['x']

                    self.hertz_fit['full_map']['indices'][ind] = dict()

                    try:

                        fd = self.extract_fd_curve(ind)
                        fd.set_save_directory(self.file_info['save_directory'])
                        fd.correct_data(force_unit = self.corrections_pass_to_function['force_unit'],
                                        distance_unit = self.corrections_pass_to_function['distance_unit'],
                                        noise_lvl = self.corrections_pass_to_function['noise_lvl'],
                                        distance_correction = self.corrections_pass_to_function['distance_correction'],
                                        baseline_correction = self.corrections_pass_to_function['baseline_correction'],
                                        get_tip_sample_separation = self.corrections_pass_to_function['get_tip_sample_separation'])

                        fd.fit_hertz_model(mode = mode,
                                           residuals_baseline_weight = residuals_baseline_weight,
                                           y_offset = y_offset,
                                           distance_to_contact = distance_to_contact,
                                           poisson_ratio = poisson_ratio,
                                           indenter_characteristics = indenter_characteristics,
                                           max_indentation = max_indentation, force_limit = force_limit,
                                           min_fit_length = min_fit_length,
                                           **kwargs)


                        self.hertz_fit['full_map']['indices'][ind]['young_modulus'] = fd.hertz_fit['young_modulus']

                        self.hertz_fit['full_map']['indices'][ind]['best_fit'] = fd.hertz_fit['best_fit']
                        self.hertz_fit['full_map']['indices'][ind]['residuals'] = fd.hertz_fit['residuals']

                        data[y][x] = fd.hertz_fit['young_modulus']['value']
                        data_error[y][x] = fd.hertz_fit['residuals']['mean']

                        self.hertz_fit['full_map']['indices'][ind]['except'] = False

                    except:

                        self.hertz_fit['full_map']['indices'][ind]['except'] = True
                        log_file.write('-------------------------------\n')
                        log_file.write('An error occured while processing index ' + str(ind) + '\n')
                        traceback.print_exc(file = log_file)

                    finally:

                        sys.stdout.write('\rFitting Hertz model - with plot/export results: %.2f%% <%d/%d>' %(count/self.settings['fd_indices']['total']*100, count,self.settings['fd_indices']['total']))
                        count += 1
                        self.counter['count'] += 1


                self.data['hertz_fit'] = dict()
                self.data['hertz_fit']['value'] = copy.deepcopy(data)
                self.data['hertz_fit']['error'] = copy.deepcopy(data_error)

                self.hertz_fit['full_map']['poisson_ratio'] = poisson_ratio
                self.hertz_fit['full_map']['units'] = copy.deepcopy(self.units)
                self.hertz_fit['full_map']['e_modul_unit'] = 'Pa'
                self.hertz_fit['full_map']['e_modul_factor'] = 1
                self.hertz_fit['full_map']['corrections'] = copy.deepcopy(self.corrections_pass_to_function)
                self.hertz_fit['full_map']['analyzed'] = True
                self.hertz_fit['full_map']['successfully_analyzed'] = np.sum(~np.isnan(np.reshape(data,-1)))
                self.hertz_fit['full_map']['successfully_analyzed_percent'] = 100 * self.hertz_fit['full_map']['successfully_analyzed']/np.reshape(data,-1).size


                sys.stdout.write(' -- Done!\n')


                try:

                    file_pickle = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + '.hertz_standard.' + timestamp + '.pkl')
                    out_pkl = open(file_pickle, 'wb')
                    pickle.dump(self.hertz_fit['full_map'], out_pkl)

                except:

                    log_file.write('-------------------------------\n')
                    log_file.write('ERROR! Cannot open/write file ' + file_pickle)
                    traceback.print_exc(file = log_file)

                finally:

                    out_pkl.close()

                log_file.close()

            else:

                self.hertz_fit['full_map']['indenter'] = indenter_characteristics

                self.hertz_fit['full_map']['method'] = dict()
                self.hertz_fit['full_map']['method']['type'] = 'standard'
                self.hertz_fit['full_map']['method']['parameter'] = dict()
                self.hertz_fit['full_map']['method']['parameter']['force_limit'] = force_limit
                self.hertz_fit['full_map']['method']['parameter']['max_indentation'] = max_indentation
                self.hertz_fit['full_map']['method']['parameter']['distance_to_contact'] = distance_to_contact
                self.hertz_fit['full_map']['method']['parameter']['min_fit_length'] = min_fit_length
                #self.hertz_fit['full_map']['method']['parameter']['threshold_sensitivity'] = threshold_sensitivity
                self.hertz_fit['full_map']['method']['parameter']['residuals_baseline_weight'] = residuals_baseline_weight
                self.hertz_fit['full_map']['method']['parameter']['mode'] = mode
                if mode == "free_contact_point":
                    self.hertz_fit['full_map']['method']['parameter']['y_offset'] = y_offset
                else:
                    self.hertz_fit['full_map']['method']['parameter']['y_offset'] = 'zero'


                self.hertz_fit['full_map']['filter'] = dict()
                self.hertz_fit['full_map']['filter']['type'] = 'none'

                timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                sys.stdout.write('\rFitting Hertz model: %.2f%% <%d/%d>' %(0, 0, self.settings['fd_indices']['total']))
                log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_hertz_standard.' + timestamp +'.txt'), 'w')

                count = 1
                self.counter['count'] = 0
                self.counter['max'] = self.settings['fd_indices']['total'] - 1

                data = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_error = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)

                if indenter_characteristics['geometry'] == 'spherical':

                    conv_list = Conversion_List_Spherical_Indenter_Hertz(indenter_characteristics['radius [nm]'],1, int(self.settings['z-length']['extend']*10**9)+10)
                    indenter_characteristics['contact_circle_conversion'] = conv_list


                self.hertz_fit['full_map']['indices'] = dict()

                for ind in self.settings['fd_indices']['list']:

                    y = int(ind / self.settings['grid']['y'])
                    x = (ind) % self.settings['grid']['x']

                    self.hertz_fit['full_map']['indices'][ind] = dict()

                    try:

                        fd = self.extract_fd_curve_batch(ind)
                        fd.set_save_directory(self.file_info['save_directory'])
                        fd.correct_data(force_unit = self.corrections_pass_to_function['force_unit'],
                                        distance_unit = self.corrections_pass_to_function['distance_unit'],
                                        noise_lvl = self.corrections_pass_to_function['noise_lvl'],
                                        distance_correction = self.corrections_pass_to_function['distance_correction'],
                                        baseline_correction = self.corrections_pass_to_function['baseline_correction'],
                                        get_tip_sample_separation = self.corrections_pass_to_function['get_tip_sample_separation'])

                        fd.fit_hertz_model(mode = mode,
                                           residuals_baseline_weight = residuals_baseline_weight,
                                           y_offset = y_offset,
                                           distance_to_contact = distance_to_contact,
                                           poisson_ratio = poisson_ratio,
                                           indenter_characteristics = indenter_characteristics,
                                           max_indentation = max_indentation, force_limit = force_limit,
                                           min_fit_length = min_fit_length)


                        self.hertz_fit['full_map']['indices'][ind]['young_modulus'] = fd.hertz_fit['young_modulus']

                        self.hertz_fit['full_map']['indices'][ind]['best_fit'] = fd.hertz_fit['best_fit']
                        self.hertz_fit['full_map']['indices'][ind]['residuals'] = fd.hertz_fit['residuals']

                        data[y][x] = fd.hertz_fit['young_modulus']['value']
                        data_error[y][x] = fd.hertz_fit['residuals']['mean']

                        self.hertz_fit['full_map']['indices'][ind]['except'] = False

                    except:

                        self.hertz_fit['full_map']['indices'][ind]['except'] = True
                        log_file.write('-------------------------------\n')
                        log_file.write('An error occured while processing index ' + str(ind) + '\n')
                        traceback.print_exc(file = log_file)

                    finally:

#                             #self.youngs_modulus[ind] = copy.deepcopy(ret_dict_complete[ind])
                        sys.stdout.write('\rFitting Hertz model: %.2f%% <%d/%d>' %(count/self.settings['fd_indices']['total']*100, count,self.settings['fd_indices']['total']))
                        count += 1
                        self.counter['count'] += 1

                self.data['hertz_fit'] = dict()
                self.data['hertz_fit']['value'] = copy.deepcopy(data)
                self.data['hertz_fit']['error'] = copy.deepcopy(data_error)

                self.hertz_fit['full_map']['poisson_ratio'] = poisson_ratio
                self.hertz_fit['full_map']['units'] = copy.deepcopy(self.units)
                self.hertz_fit['full_map']['e_modul_unit'] = 'Pa'
                self.hertz_fit['full_map']['e_modul_factor'] = 1
                self.hertz_fit['full_map']['corrections'] = copy.deepcopy(self.corrections_pass_to_function)
                self.hertz_fit['full_map']['analyzed'] = True
                self.hertz_fit['full_map']['successfully_analyzed'] = np.sum(~np.isnan(np.reshape(data,-1)))
                self.hertz_fit['full_map']['successfully_analyzed_percent'] = 100 * self.hertz_fit['full_map']['successfully_analyzed']/np.reshape(data,-1).size


                sys.stdout.write(' -- Done!\n')


                try:

                    file_pickle = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + 'hertz_standard.' + timestamp + '.pkl')
                    out_pkl = open(file_pickle, 'wb')
                    pickle.dump(self.hertz_fit['full_map'], out_pkl)

                except:

                    log_file.write('-------------------------------\n')
                    log_file.write('ERROR! Cannot open/write file ' + file_pickle)
                    traceback.print_exc(file = log_file)

                finally:

                    out_pkl.close()

                log_file.close()


        else:

            raise ValueError('ERROR! Set the corrections first!')





    def fit_linearized_hertz_model(self, selection = False,
                        poisson_ratio = 0.5,
                        indenter_characteristics = {'geometry': 'parabolic', 'radius [nm]': 10},
                        transition_sensitivity = 1,
                        filter_correction_fraction = 0.5,
                        stop_at_transition = True,
                        **kwargs):

        layer1_parameters = {'start_fit_length': 'automatic',
                             'savgol_filter_characteristics': {'length': 51, 'order': 1, 'deriv': 0, 'delta': 1.0, 'axis': -1, 'mode': 'interp', 'cval': 0.0},
                             'r_squared_limit':  0.98,
                             'residual_sensitivity': 1,
                             'final_fit_fraction': 0.8,
                             'with_residuals': True}

        if 'layer1_parameters' in kwargs:

            for key in kwargs['layer1_parameters'].keys():

                layer1_parameters[key] = kwargs['layer1_parameters'][key]


        if 'layer1_parameters' in kwargs: del kwargs['layer1_parameters']


        residual_fac_layer1 = 5 - math.log10(layer1_parameters['residual_sensitivity'])
        transition_fac = 5 - math.log10(transition_sensitivity)

        if self.control_variables['allow_analysis']:

#            if bool(selection) and selection in self.selections.keys():
            if bool(selection):

                if type(selection) is not list:

                    selection = [selection]

                for select in selection:

                    if select in self.selections.keys():

                        self.linearized_hertz_fit['selections'][select] = dict()

                        self.linearized_hertz_fit['selections'][select]['indenter'] = indenter_characteristics

                        self.linearized_hertz_fit['selections'][select]['method'] = dict()
                        self.linearized_hertz_fit['selections'][select]['method']['type'] = 'linear'

                        self.linearized_hertz_fit['selections'][select]['method']['parameter'] = dict()
                        self.linearized_hertz_fit['selections'][select]['method']['parameter']['transition_sensitivity'] = transition_sensitivity
                        self.linearized_hertz_fit['selections'][select]['method']['parameter']['transition_factor'] = transition_fac

                        self.linearized_hertz_fit['selections'][select]['method']['parameter']['r_squared_limit'] = layer1_parameters['r_squared_limit']
                        self.linearized_hertz_fit['selections'][select]['method']['parameter']['with_residuals'] = layer1_parameters['with_residuals']
                        self.linearized_hertz_fit['selections'][select]['method']['parameter']['residual_sensitivity'] = layer1_parameters['residual_sensitivity']
                        self.linearized_hertz_fit['selections'][select]['method']['parameter']['residual_factor'] = residual_fac_layer1
                        self.linearized_hertz_fit['selections'][select]['method']['parameter']['final_fit_fraction'] = layer1_parameters['final_fit_fraction']



                        self.linearized_hertz_fit['selections'][select]['filter'] = dict()
                        self.linearized_hertz_fit['selections'][select]['filter']['type'] = 'savitzky-golay'
                        self.linearized_hertz_fit['selections'][select]['filter']['parameter'] = dict()
                        self.linearized_hertz_fit['selections'][select]['filter']['parameter']['length'] = layer1_parameters['savgol_filter_characteristics']['length']
                        self.linearized_hertz_fit['selections'][select]['filter']['parameter']['order'] = layer1_parameters['savgol_filter_characteristics']['length']


                        timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                        sys.stdout.write('\rFitting linearized Hertz model - Selection %s: %.2f%% <%d/%d>' %(select,0, 0, len(self.selections[select]['fd_index'])))
                        log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_youngs_modulus_linear.' + timestamp +'.txt'), 'w')

                        #if not os.path.isdir(os.path.join(self.file_info['save_directory'], 'linearized_hertz_fit')):

                        #    os.makedirs(os.path.join(self.file_info['save_directory'], 'linearized_hertz_fit'))



                        count = 1

                        self.linearized_hertz_fit['selections'][select]['indices'] = dict()

                        for ind in self.selections[select]['fd_index']:

                            #y = int(ind / self.settings['grid']['y'])
                            #x = (ind) % self.settings['grid']['x']

                            self.linearized_hertz_fit['selections'][select]['indices'][ind] = dict()

                            try:

                                fd = self.extract_fd_curve_batch(ind)

                                fd.set_save_directory(self.file_info['save_directory'])
                                     # 3. correct data
                                fd.correct_data(force_unit = self.corrections_pass_to_function['force_unit'],
                                                distance_unit = self.corrections_pass_to_function['distance_unit'],
                                                noise_lvl = self.corrections_pass_to_function['noise_lvl'],
                                                distance_correction = self.corrections_pass_to_function['distance_correction'],
                                                baseline_correction = self.corrections_pass_to_function['baseline_correction'],
                                                get_tip_sample_separation = self.corrections_pass_to_function['get_tip_sample_separation'])

                                fd.fit_linearized_hertz_model(
                                                                poisson_ratio = poisson_ratio,
                                                                indenter_characteristics = indenter_characteristics,
                                                                transition_sensitivity = transition_sensitivity,
                                                                stop_at_transition = stop_at_transition,
                                                                filter_correction_fraction = filter_correction_fraction,
                                                                layer1_parameters = layer1_parameters,
                                                                **kwargs)

                                self.linearized_hertz_fit['selections'][select]['indices'][ind]['young_modulus'] = fd.linearized_hertz_fit['young_modulus']

                                self.linearized_hertz_fit['selections'][select]['indices'][ind]['best_fit'] = fd.linearized_hertz_fit['best_fit']
                                self.linearized_hertz_fit['selections'][select]['indices'][ind]['residuals'] = fd.linearized_hertz_fit['residuals']

                                self.linearized_hertz_fit['selections'][select]['indices'][ind]['except'] = False

                            except:

                                self.linearized_hertz_fit['selections'][select]['indices'][ind]['except'] = True
                                log_file.write('An error occured while processing index ' + str(ind) + '\n')


                            finally:

                                     #self.youngs_modulus[ind] = copy.deepcopy(ret_dict_complete[ind])
                                sys.stdout.write('\rFitting linearized Hertz model - Selection %s: %.2f%% <%d/%d>' %(select,count/len(self.selections[select]['fd_index'])*100, count,len(self.selections[select]['fd_index'])))
                                count += 1

                        self.linearized_hertz_fit['selections'][select]['poisson_ratio'] = poisson_ratio

                        self.linearized_hertz_fit['selections'][select]['units'] = copy.deepcopy(self.units)
                        self.linearized_hertz_fit['selections'][select]['e_modul_unit'] = 'Pa'
                        self.linearized_hertz_fit['selections'][select]['e_modul_factor'] = 1
                        self.linearized_hertz_fit['selections'][select]['corrections'] = copy.deepcopy(self.corrections)

                        sys.stdout.write(' -- Done!\n')


                        try:

                            file_pickle = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + '.youngs_modulus.'+ select+ '.'+ timestamp + '.pkl')
                            out_pkl = open(file_pickle, 'wb')
                            pickle.dump(self.linearized_hertz_fit['selections'][select], out_pkl)

                        except:

                            log_file.write('ERROR! Cannot open/write file ' + file_pickle)

                        finally:

                            out_pkl.close()

                        log_file.close()

                    elif select not in self.selections.keys():

                        print('ERROR! Selection', select,'is not a valid selection.')


            elif ('plot_result' in kwargs and kwargs['plot_result']) or 'export_result' in kwargs:

                self.linearized_hertz_fit['full_map']['indenter'] = indenter_characteristics

                self.linearized_hertz_fit['full_map']['method'] = dict()
                self.linearized_hertz_fit['full_map']['method']['type'] = 'linear'

                self.linearized_hertz_fit['full_map']['method']['parameter'] = dict()
                self.linearized_hertz_fit['full_map']['method']['parameter']['transition_sensitivity'] = transition_sensitivity
                self.linearized_hertz_fit['full_map']['method']['parameter']['transition_factor'] = transition_fac

                self.linearized_hertz_fit['full_map']['method']['parameter']['r_squared_limit'] = layer1_parameters['r_squared_limit']
                self.linearized_hertz_fit['full_map']['method']['parameter']['with_residuals'] = layer1_parameters['with_residuals']
                self.linearized_hertz_fit['full_map']['method']['parameter']['residual_sensitivity'] = layer1_parameters['residual_sensitivity']
                self.linearized_hertz_fit['full_map']['method']['parameter']['residual_factor'] = residual_fac_layer1
                self.linearized_hertz_fit['full_map']['method']['parameter']['final_fit_fraction'] = layer1_parameters['final_fit_fraction']

                self.linearized_hertz_fit['full_map']['filter'] = dict()
                self.linearized_hertz_fit['full_map']['filter']['type'] = 'savitzky-golay'
                self.linearized_hertz_fit['full_map']['filter']['parameter'] = dict()
                self.linearized_hertz_fit['full_map']['filter']['parameter']['length'] = layer1_parameters['savgol_filter_characteristics']['length']
                self.linearized_hertz_fit['full_map']['filter']['parameter']['order'] = layer1_parameters['savgol_filter_characteristics']['length']

                timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                sys.stdout.write('\rFitting linearized Hertz model - with plot/export result: %.2f%% <%d/%d>' %(0, 0, self.settings['fd_indices']['total']))
                log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_youngs_modulus_linear.' + timestamp +'.txt'), 'w')

                count = 1

                data = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_error = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_fit_length_index = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_fit_length_interval = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_soft_layer_thickness = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)

                self.linearized_hertz_fit['full_map']['indices'] = dict()

                for ind in self.settings['fd_indices']['list']:

                    y = int(ind / self.settings['grid']['y'])
                    x = (ind) % self.settings['grid']['x']

                    self.linearized_hertz_fit['full_map']['indices'][ind] = dict()

                    try:

                        fd = self.extract_fd_curve_batch(ind)

                        fd.set_save_directory(self.file_info['save_directory'])
                             # 3. correct data
                        fd.correct_data(force_unit = self.corrections_pass_to_function['force_unit'],
                                        distance_unit = self.corrections_pass_to_function['distance_unit'],
                                        noise_lvl = self.corrections_pass_to_function['noise_lvl'],
                                        distance_correction = self.corrections_pass_to_function['distance_correction'],
                                        baseline_correction = self.corrections_pass_to_function['baseline_correction'],
                                        get_tip_sample_separation = self.corrections_pass_to_function['get_tip_sample_separation'])

                        fd.fit_linearized_hertz_model(poisson_ratio = poisson_ratio,
                                                      indenter_characteristics = indenter_characteristics,
                                                      transition_sensitivity = transition_sensitivity,
                                                      stop_at_transition = stop_at_transition,
                                                      filter_correction_fraction = filter_correction_fraction,
                                                      layer1_parameters = layer1_parameters,
                                                      **kwargs)

                        self.linearized_hertz_fit['full_map']['indices'][ind]['young_modulus'] = fd.linearized_hertz_fit['young_modulus']

                        self.linearized_hertz_fit['full_map']['indices'][ind]['best_fit'] = fd.linearized_hertz_fit['best_fit']
                        self.linearized_hertz_fit['full_map']['indices'][ind]['residuals'] = fd.linearized_hertz_fit['residuals']

                        if fd.linearized_hertz_fit['best_fit']['line_found']:

                            data[y][x] = fd.linearized_hertz_fit['young_modulus']['value']
                            data_error[y][x] = fd.linearized_hertz_fit['residuals']['mean']
                            data_fit_length_interval[y][x] = fd.linearized_hertz_fit['best_fit']['interval'][0] - fd.linearized_hertz_fit['best_fit']['interval'][1]
                            data_fit_length_index[y][x] = fd.linearized_hertz_fit['best_fit']['index'][1] - fd.linearized_hertz_fit['best_fit']['index'][0]
                            data_soft_layer_thickness[y][x] = fd.linearized_hertz_fit['best_fit']['contact_point']['value'] - fd.linearized_hertz_fit['best_fit']['interval'][1]


                        self.linearized_hertz_fit['full_map']['indices'][ind]['except'] = False

                    except:

                        self.linearized_hertz_fit['full_map']['indices'][ind]['except'] = True
                        log_file.write('An error occured while processing index ' + str(ind) + '\n')

                    finally:

                             #self.youngs_modulus[ind] = copy.deepcopy(ret_dict_complete[ind])
                        sys.stdout.write('\rFitting linearized Hertz model  - with plot/export result: %.2f%% <%d/%d>' %(count/self.settings['fd_indices']['total']*100, count,self.settings['fd_indices']['total']))
                        count += 1

                self.data['linearized_hertz_fit'] = dict()
                self.data['linearized_hertz_fit']['value'] = copy.deepcopy(data)
                self.data['linearized_hertz_fit']['error'] = copy.deepcopy(data_error)
                self.data['linearized_hertz_fit']['fit_length_interval'] = copy.deepcopy(data_fit_length_interval)
                self.data['linearized_hertz_fit']['fit_length_datapoints'] = copy.deepcopy(data_fit_length_index)
                self.data['linearized_hertz_fit']['apparent_layer_thickness'] = copy.deepcopy(data_soft_layer_thickness)

                self.linearized_hertz_fit['full_map']['poisson_ratio'] = poisson_ratio
                self.linearized_hertz_fit['full_map']['units'] = copy.deepcopy(self.units)
                self.linearized_hertz_fit['full_map']['e_modul_unit'] = 'Pa'
                self.linearized_hertz_fit['full_map']['e_modul_factor'] = 1
                self.linearized_hertz_fit['full_map']['corrections'] = copy.deepcopy(self.corrections)
                self.linearized_hertz_fit['full_map']['analyzed'] = True
                self.linearized_hertz_fit['full_map']['successfully_analyzed'] = np.sum(~np.isnan(np.reshape(data,-1)))
                self.linearized_hertz_fit['full_map']['successfully_analyzed_percent'] = 100 * self.linearized_hertz_fit['full_map']['successfully_analyzed']/np.reshape(data,-1).size

                sys.stdout.write(' -- Done!\n')


                try:

                    file_pickle = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + '.youngs_modulus.linear.' + timestamp + '.pkl')
                    out_pkl = open(file_pickle, 'wb')
                    pickle.dump(self.linearized_hertz_fit['full_map'], out_pkl)

                except:

                    log_file.write('ERROR! Cannot open/write file ' + file_pickle)

                finally:

                    out_pkl.close()

                log_file.close()

            else:

                self.linearized_hertz_fit['full_map']['indenter'] = indenter_characteristics

                self.linearized_hertz_fit['full_map']['method'] = dict()
                self.linearized_hertz_fit['full_map']['method']['type'] = 'linear'

                self.linearized_hertz_fit['full_map']['method']['parameter'] = dict()
                self.linearized_hertz_fit['full_map']['method']['parameter']['transition_sensitivity'] = transition_sensitivity
                self.linearized_hertz_fit['full_map']['method']['parameter']['transition_factor'] = transition_fac

                self.linearized_hertz_fit['full_map']['method']['parameter']['r_squared_limit'] = layer1_parameters['r_squared_limit']
                self.linearized_hertz_fit['full_map']['method']['parameter']['with_residuals'] = layer1_parameters['with_residuals']
                self.linearized_hertz_fit['full_map']['method']['parameter']['residual_sensitivity'] = layer1_parameters['residual_sensitivity']
                self.linearized_hertz_fit['full_map']['method']['parameter']['residual_factor'] = residual_fac_layer1
                self.linearized_hertz_fit['full_map']['method']['parameter']['final_fit_fraction'] = layer1_parameters['final_fit_fraction']

                self.linearized_hertz_fit['full_map']['filter'] = dict()
                self.linearized_hertz_fit['full_map']['filter']['type'] = 'savitzky-golay'
                self.linearized_hertz_fit['full_map']['filter']['parameter'] = dict()
                self.linearized_hertz_fit['full_map']['filter']['parameter']['length'] = layer1_parameters['savgol_filter_characteristics']['length']
                self.linearized_hertz_fit['full_map']['filter']['parameter']['order'] = layer1_parameters['savgol_filter_characteristics']['length']

                timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                sys.stdout.write('\rFitting linearized Hertz model: %.2f%% <%d/%d>' %(0, 0, self.settings['fd_indices']['total']))
                log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_youngs_modulus_linear.' + timestamp +'.txt'), 'w')

                count = 1

                data = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_error = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_fit_length_index = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_fit_length_interval = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_soft_layer_thickness = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)

                self.linearized_hertz_fit['full_map']['indices'] = dict()

                for ind in self.settings['fd_indices']['list']:

                    y = int(ind / self.settings['grid']['y'])
                    x = (ind) % self.settings['grid']['x']

                    self.linearized_hertz_fit['full_map']['indices'][ind] = dict()

                    try:

                        fd = self.extract_fd_curve(ind)

                        fd.set_save_directory(self.file_info['save_directory'])
                             # 3. correct data
                        fd.correct_data(force_unit = self.corrections_pass_to_function['force_unit'],
                                        distance_unit = self.corrections_pass_to_function['distance_unit'],
                                        noise_lvl = self.corrections_pass_to_function['noise_lvl'],
                                        distance_correction = self.corrections_pass_to_function['distance_correction'],
                                        baseline_correction = self.corrections_pass_to_function['baseline_correction'],
                                        get_tip_sample_separation = self.corrections_pass_to_function['get_tip_sample_separation'])

                        fd.fit_linearized_hertz_model(poisson_ratio = poisson_ratio,
                                                      indenter_characteristics = indenter_characteristics,
                                                      transition_sensitivity = transition_sensitivity,
                                                      stop_at_transition = stop_at_transition,
                                                      filter_correction_fraction = filter_correction_fraction,
                                                      layer1_parameters = layer1_parameters)



                        self.linearized_hertz_fit['full_map']['indices'][ind]['young_modulus'] = fd.linearized_hertz_fit['young_modulus']

                        self.linearized_hertz_fit['full_map']['indices'][ind]['best_fit'] = fd.linearized_hertz_fit['best_fit']
                        self.linearized_hertz_fit['full_map']['indices'][ind]['residuals'] = fd.linearized_hertz_fit['residuals']

                        if fd.linearized_hertz_fit['best_fit']['line_found']:

                            data[y][x] = fd.linearized_hertz_fit['young_modulus']['value']
                            data_error[y][x] = fd.linearized_hertz_fit['residuals']['mean']
                            data_fit_length_interval[y][x] = fd.linearized_hertz_fit['best_fit']['interval'][0] - fd.linearized_hertz_fit['best_fit']['interval'][1]
                            data_fit_length_index[y][x] = fd.linearized_hertz_fit['best_fit']['index'][1] - fd.linearized_hertz_fit['best_fit']['index'][0]
                            data_soft_layer_thickness[y][x] = fd.linearized_hertz_fit['best_fit']['contact_point']['value'] - fd.linearized_hertz_fit['best_fit']['interval'][1]


                        self.linearized_hertz_fit['full_map']['indices'][ind]['except'] = False

                    except:

                        self.linearized_hertz_fit['full_map']['indices'][ind]['except'] = True
                        log_file.write('An error occured while processing index ' + str(ind) + '\n')

                    finally:

                             #self.youngs_modulus[ind] = copy.deepcopy(ret_dict_complete[ind])
                        sys.stdout.write('\rFitting linearized Hertz model: %.2f%% <%d/%d>' %(count/self.settings['fd_indices']['total']*100, count,self.settings['fd_indices']['total']))
                        count += 1

                self.data['linearized_hertz_fit'] = dict()
                self.data['linearized_hertz_fit']['value'] = copy.deepcopy(data)
                self.data['linearized_hertz_fit']['error'] = copy.deepcopy(data_error)
                self.data['linearized_hertz_fit']['fit_length_interval'] = copy.deepcopy(data_fit_length_interval)
                self.data['linearized_hertz_fit']['fit_length_datapoints'] = copy.deepcopy(data_fit_length_index)
                self.data['linearized_hertz_fit']['apparent_layer_thickness'] = copy.deepcopy(data_soft_layer_thickness)



                self.linearized_hertz_fit['full_map']['poisson_ratio'] = poisson_ratio
                self.linearized_hertz_fit['full_map']['units'] = copy.deepcopy(self.units)
                self.linearized_hertz_fit['full_map']['e_modul_unit'] = 'Pa'
                self.linearized_hertz_fit['full_map']['e_modul_factor'] = 1
                self.linearized_hertz_fit['full_map']['corrections'] = copy.deepcopy(self.corrections)
                self.linearized_hertz_fit['full_map']['analyzed'] = True
                self.linearized_hertz_fit['full_map']['successfully_analyzed'] = np.sum(~np.isnan(np.reshape(data,-1)))
                self.linearized_hertz_fit['full_map']['successfully_analyzed_percent'] = 100 * self.linearized_hertz_fit['full_map']['successfully_analyzed']/np.reshape(data,-1).size

                sys.stdout.write(' -- Done!\n')


                try:

                    file_pickle = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + '.youngs_modulus.linear.' + timestamp + '.pkl')
                    out_pkl = open(file_pickle, 'wb')
                    pickle.dump(self.linearized_hertz_fit['full_map'], out_pkl)

                except:

                    log_file.write('ERROR! Cannot open/write file ' + file_pickle)

                finally:

                    out_pkl.close()

                log_file.close()


        else:

            raise ValueError('ERROR! Set the corrections first!')





    def fit_two_layer_linearized_hertz_model(self, selection = False,
                        poisson_ratio = 0.5,
                        indenter_characteristics = {'geometry': 'parabolic', 'radius [nm]': 10},
                        transition_sensitivity = 1,
                        filter_correction_fraction = 0.5,
                        **kwargs):

        layer1_parameters = {'start_fit_length': 'automatic',
                             'savgol_filter_characteristics': {'length': 51, 'order': 1, 'deriv': 0, 'delta': 1.0, 'axis': -1, 'mode': 'interp', 'cval': 0.0},
                             'r_squared_limit':  0.98,
                             'residual_sensitivity': 1,
                             'final_fit_fraction': 0.8,
                             'with_residuals': True}

        layer2_parameters = {'start_fit_length': 'automatic',
                             #'savgol_filter_characteristics': {'length': 51, 'order': 1},
                             'r_squared_limit':  0.98,
                             'residual_sensitivity': 1,
                             'final_fit_fraction': 0.9,
                             'with_residuals': True,}


        if 'layer1_parameters' in kwargs:

            for key in kwargs['layer1_parameters'].keys():

                layer1_parameters[key] = kwargs['layer1_parameters'][key]


        if 'layer2_parameters' in kwargs:

            for key in kwargs['layer2_parameters'].keys():

                layer2_parameters[key] = kwargs['layer2_parameters'][key]

        if 'layer1_parameters' in kwargs: del kwargs['layer1_parameters']
        if 'layer2_parameters' in kwargs: del kwargs['layer2_parameters']

        residual_fac_layer1 = 5 - math.log10(layer1_parameters['residual_sensitivity'])
        residual_fac_layer2 = 5 - math.log10(layer2_parameters['residual_sensitivity'])
        transition_fac = 5 - math.log10(transition_sensitivity)

        kwargs.pop('layer1_parameters',None)
        kwargs.pop('layer2_parameters',None)


        if self.control_variables['allow_analysis']:

#            if bool(selection) and selection in self.selections.keys():
            if bool(selection):

                if type(selection) is not list:

                    selection = [selection]

                for select in selection:

                    if select in self.selections.keys():

                        self.two_layer_hertz['selections'][select] = dict()

                        self.two_layer_hertz['selections'][select]['indenter'] = indenter_characteristics

                        self.two_layer_hertz['selections'][select]['method'] = dict()
                        self.two_layer_hertz['selections'][select]['method']['type'] = 'linear'

                        self.two_layer_hertz['selections'][select]['method']['parameter'] = dict()
                        self.two_layer_hertz['selections'][select]['method']['parameter']['transition_sensitivity'] = transition_sensitivity
                        self.two_layer_hertz['selections'][select]['method']['parameter']['transition_factor'] = transition_fac

                        self.two_layer_hertz['selections'][select]['method']['parameter']['layer1'] = dict()
                        self.two_layer_hertz['selections'][select]['method']['parameter']['layer1']['r_squared_limit'] = layer1_parameters['r_squared_limit']
                        self.two_layer_hertz['selections'][select]['method']['parameter']['layer1']['with_residuals'] = layer1_parameters['with_residuals']
                        self.two_layer_hertz['selections'][select]['method']['parameter']['layer1']['residual_sensitivity'] = layer1_parameters['residual_sensitivity']
                        self.two_layer_hertz['selections'][select]['method']['parameter']['layer1']['residual_factor'] = residual_fac_layer1
                        self.two_layer_hertz['selections'][select]['method']['parameter']['layer1']['final_fit_fraction'] = layer1_parameters['final_fit_fraction']

                        self.two_layer_hertz['selections'][select]['method']['parameter']['layer2'] = dict()
                        self.two_layer_hertz['selections'][select]['method']['parameter']['layer2']['r_squared_limit'] = layer2_parameters['r_squared_limit']
                        self.two_layer_hertz['selections'][select]['method']['parameter']['layer2']['with_residuals'] = layer2_parameters['with_residuals']
                        self.two_layer_hertz['selections'][select]['method']['parameter']['layer2']['residual_sensitivity'] = layer2_parameters['residual_sensitivity']
                        self.two_layer_hertz['selections'][select]['method']['parameter']['layer2']['residual_factor'] = residual_fac_layer2
                        self.two_layer_hertz['selections'][select]['method']['parameter']['layer2']['final_fit_fraction'] = layer2_parameters['final_fit_fraction']


                        self.two_layer_hertz['selections'][select]['filter'] = dict()
                        self.two_layer_hertz['selections'][select]['filter']['layer1'] = dict()
                        self.two_layer_hertz['selections'][select]['filter']['layer1']['type'] = 'savitzky-golay'
                        self.two_layer_hertz['selections'][select]['filter']['layer1']['parameter'] = dict()
                        self.two_layer_hertz['selections'][select]['filter']['layer1']['parameter']['length'] = layer1_parameters['savgol_filter_characteristics']['length']
                        self.two_layer_hertz['selections'][select]['filter']['layer1']['parameter']['order'] = layer1_parameters['savgol_filter_characteristics']['order']



                        timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                        sys.stdout.write('\rFitting Two-Layer Linearized Hertz model - Selection %s: %.2f%% <%d/%d>' %(select,0, 0, len(self.selections[select]['fd_index'])))
                        log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_two_layer_linearized_hertz.' + timestamp +'.txt'), 'w')

                        #if not os.path.isdir(os.path.join(self.file_info['save_directory'], 'two_layer_linearized_hertz')):

                        #   os.makedirs(os.path.join(self.file_info['save_directory'], 'two_layer_linearized_hertz'))



                        count = 1

                        self.two_layer_hertz['selections'][select]['indices'] = dict()

                        for ind in self.selections[select]['fd_index']:

                            #y = int(ind / self.settings['grid']['y'])
                            #x = (ind) % self.settings['grid']['x']

                            self.two_layer_hertz['selections'][select]['indices'][ind] = dict()

                            try:

                                fd = self.extract_fd_curve_batch(ind)

                                fd.set_save_directory(self.file_info['save_directory'])
                                     # 3. correct data
                                fd.correct_data(force_unit = self.corrections_pass_to_function['force_unit'],
                                                distance_unit = self.corrections_pass_to_function['distance_unit'],
                                                noise_lvl = self.corrections_pass_to_function['noise_lvl'],
                                                distance_correction = self.corrections_pass_to_function['distance_correction'],
                                                baseline_correction = self.corrections_pass_to_function['baseline_correction'],
                                                get_tip_sample_separation = self.corrections_pass_to_function['get_tip_sample_separation'])

                                fd.fit_two_layer_linearized_hertz_model(
                                                                poisson_ratio = poisson_ratio,
                                                                indenter_characteristics = indenter_characteristics,
                                                                transition_sensitivity = transition_sensitivity,
                                                                filter_correction_fraction = filter_correction_fraction,
                                                                layer1_parameters = layer1_parameters,
                                                                layer2_parameters = layer2_parameters,
                                                                **kwargs)



                                self.two_layer_hertz['selections'][select]['indices'][ind]['young_modulus'] = fd.two_layer_hertz['young_modulus']

                                self.two_layer_hertz['selections'][select]['indices'][ind]['best_fit'] = fd.two_layer_hertz['best_fit']
                                self.two_layer_hertz['selections'][select]['indices'][ind]['residuals'] = fd.two_layer_hertz['residuals']

                                self.two_layer_hertz['selections'][select]['indices'][ind]['except'] = False

                            except:

                                self.two_layer_hertz['selections'][select]['indices'][ind]['except'] = True
                                log_file.write('An error occured while processing index ' + str(ind) + '\n')


                            finally:

                                     #self.youngs_modulus[ind] = copy.deepcopy(ret_dict_complete[ind])
                                sys.stdout.write('\rFitting Two-Layer Linearized Hertz model - Selection %s: %.2f%% <%d/%d>' %(select,count/len(self.selections[select]['fd_index'])*100, count,len(self.selections[select]['fd_index'])))
                                count += 1

                        self.two_layer_hertz['selections'][select]['poisson_ratio'] = poisson_ratio


                        self.two_layer_hertz['selections'][select]['units'] = copy.deepcopy(self.units)
                        self.two_layer_hertz['selections'][select]['e_modul_unit'] = 'Pa'
                        self.two_layer_hertz['selections'][select]['e_modul_factor'] = 1
                        self.two_layer_hertz['selections'][select]['corrections'] = copy.deepcopy(self.corrections)

                        sys.stdout.write(' -- Done!\n')


                        try:

                            file_pickle = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + '.two_layer_linearized_hertz.'+ select+ '.'+ timestamp + '.pkl')
                            out_pkl = open(file_pickle, 'wb')
                            pickle.dump(self.two_layer_hertz['selections'][select], out_pkl)

                        except:

                            log_file.write('ERROR! Cannot open/write file ' + file_pickle)

                        finally:

                            out_pkl.close()

                        log_file.close()


                    elif select not in self.selections.keys():

                        print('ERROR! Selection', select,'is not a valid selection.')

            elif ('plot_result' in kwargs and kwargs['plot_result']) or 'export_result' in kwargs:

                self.two_layer_hertz['full_map']= dict()

                self.two_layer_hertz['full_map']['indenter'] = indenter_characteristics

                self.two_layer_hertz['full_map']['method'] = dict()
                self.two_layer_hertz['full_map']['method']['type'] = 'linear'

                self.two_layer_hertz['full_map']['method']['parameter'] = dict()
                self.two_layer_hertz['full_map']['method']['parameter']['transition_sensitivity'] = transition_sensitivity
                self.two_layer_hertz['full_map']['method']['parameter']['transition_factor'] = transition_fac

                self.two_layer_hertz['full_map']['method']['parameter']['layer1'] = dict()
                self.two_layer_hertz['full_map']['method']['parameter']['layer1']['r_squared_limit'] = layer1_parameters['r_squared_limit']
                self.two_layer_hertz['full_map']['method']['parameter']['layer1']['with_residuals'] = layer1_parameters['with_residuals']
                self.two_layer_hertz['full_map']['method']['parameter']['layer1']['residual_sensitivity'] = layer1_parameters['residual_sensitivity']
                self.two_layer_hertz['full_map']['method']['parameter']['layer1']['residual_factor'] = residual_fac_layer1
                self.two_layer_hertz['full_map']['method']['parameter']['layer1']['final_fit_fraction'] = layer1_parameters['final_fit_fraction']

                self.two_layer_hertz['full_map']['method']['parameter']['layer2'] = dict()
                self.two_layer_hertz['full_map']['method']['parameter']['layer2']['r_squared_limit'] = layer2_parameters['r_squared_limit']
                self.two_layer_hertz['full_map']['method']['parameter']['layer2']['with_residuals'] = layer2_parameters['with_residuals']
                self.two_layer_hertz['full_map']['method']['parameter']['layer2']['residual_sensitivity'] = layer2_parameters['residual_sensitivity']
                self.two_layer_hertz['full_map']['method']['parameter']['layer2']['residual_factor'] = residual_fac_layer2
                self.two_layer_hertz['full_map']['method']['parameter']['layer2']['final_fit_fraction'] = layer2_parameters['final_fit_fraction']


                self.two_layer_hertz['full_map']['filter'] = dict()
                self.two_layer_hertz['full_map']['filter']['layer1'] = dict()
                self.two_layer_hertz['full_map']['filter']['layer1']['type'] = 'savitzky-golay'
                self.two_layer_hertz['full_map']['filter']['layer1']['parameter'] = dict()
                self.two_layer_hertz['full_map']['filter']['layer1']['parameter']['length'] = layer1_parameters['savgol_filter_characteristics']['length']
                self.two_layer_hertz['full_map']['filter']['layer1']['parameter']['order'] = layer1_parameters['savgol_filter_characteristics']['order']

                timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                sys.stdout.write('\rFitting Two-Layer Linearized Hertz model - with plot/export results: %.2f%% <%d/%d>' %(0, 0, self.settings['fd_indices']['total']))
                log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_two_layer_linearized_hertz.' + timestamp +'.txt'), 'w')

                count = 1

                data_layer1 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_layer2 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_error_layer1 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_error_layer2 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_fit_length_index_layer1 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_fit_length_index_layer2 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_fit_length_interval_layer1 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_fit_length_interval_layer2 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_apparent_layer_thickness_layer1 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)

                self.two_layer_hertz['full_map']['indices'] = dict()

                for ind in self.settings['fd_indices']['list']:

                    y = int(ind / self.settings['grid']['y'])
                    x = (ind) % self.settings['grid']['x']

                    self.two_layer_hertz['full_map']['indices'][ind] = dict()

                    try:

                        fd = self.extract_fd_curve(ind)

                        fd.set_save_directory(self.file_info['save_directory'])
                             # 3. correct data
                        fd.correct_data(force_unit = self.corrections_pass_to_function['force_unit'],
                                        distance_unit = self.corrections_pass_to_function['distance_unit'],
                                        noise_lvl = self.corrections_pass_to_function['noise_lvl'],
                                        distance_correction = self.corrections_pass_to_function['distance_correction'],
                                        baseline_correction = self.corrections_pass_to_function['baseline_correction'],
                                        get_tip_sample_separation = self.corrections_pass_to_function['get_tip_sample_separation'])

                        fd.fit_two_layer_linearized_hertz_model(poisson_ratio = poisson_ratio,
                                                                indenter_characteristics = indenter_characteristics,
                                                                transition_sensitivity = transition_sensitivity,
                                                                filter_correction_fraction = filter_correction_fraction,
                                                                layer1_parameters = layer1_parameters,
                                                                layer2_parameters = layer2_parameters,
                                                                **kwargs)


                        self.two_layer_hertz['full_map']['indices'][ind]['young_modulus'] = fd.two_layer_hertz['young_modulus']

                        self.two_layer_hertz['full_map']['indices'][ind]['best_fit'] = fd.two_layer_hertz['best_fit']
                        self.two_layer_hertz['full_map']['indices'][ind]['residuals'] = fd.two_layer_hertz['residuals']

                        if fd.two_layer_hertz['best_fit']['layer1']['line_found']:

                            data_layer1[y][x] = fd.two_layer_hertz['young_modulus']['layer1']['value']
                            data_error_layer1[y][x] = fd.two_layer_hertz['residuals']['layer1']['mean_linear_fit']
                            data_fit_length_interval_layer1[y][x] = fd.two_layer_hertz['best_fit']['layer1']['interval'][0] - fd.two_layer_hertz['best_fit']['layer1']['interval'][1]
                            data_fit_length_index_layer1[y][x] = fd.two_layer_hertz['best_fit']['layer1']['index'][1] - fd.two_layer_hertz['best_fit']['layer1']['index'][0]
                            data_apparent_layer_thickness_layer1[y][x] = fd.two_layer_hertz['best_fit']['layer1']['contact_point']['value'] - fd.two_layer_hertz['best_fit']['layer1']['interval'][1]


                        if fd.two_layer_hertz['best_fit']['layer2']['line_found']:

                            data_layer2[y][x] = fd.two_layer_hertz['young_modulus']['layer2']['value']
                            data_error_layer2[y][x] = fd.two_layer_hertz['residuals']['layer2']['mean_linear_fit']
                            data_fit_length_interval_layer2[y][x] = fd.two_layer_hertz['best_fit']['layer2']['interval'][0] - fd.two_layer_hertz['best_fit']['layer2']['interval'][1]
                            data_fit_length_index_layer2[y][x] = fd.two_layer_hertz['best_fit']['layer2']['index'][1] - fd.two_layer_hertz['best_fit']['layer2']['index'][0]


                        self.two_layer_hertz['full_map']['indices'][ind]['except'] = False

                    except:

                        self.two_layer_hertz['full_map']['indices'][ind]['except'] = True
                        log_file.write('An error occured while processing index ' + str(ind) + '\n')

                    finally:

                             #self.youngs_modulus[ind] = copy.deepcopy(ret_dict_complete[ind])
                        sys.stdout.write('\rFitting Two-Layer Linearized Hertz model  - with plot/export results: %.2f%% <%d/%d>' %(count/self.settings['fd_indices']['total']*100, count,self.settings['fd_indices']['total']))
                        count += 1


                self.data['linearized_hertz_fit_two_layer'] = dict()
                self.data['linearized_hertz_fit_two_layer']['layer1'] = dict()
                self.data['linearized_hertz_fit_two_layer']['layer1']['value'] = copy.deepcopy(data_layer1)
                self.data['linearized_hertz_fit_two_layer']['layer1']['error'] = copy.deepcopy(data_error_layer1)
                self.data['linearized_hertz_fit_two_layer']['layer1']['fit_length_interval'] = copy.deepcopy(data_fit_length_interval_layer1)
                self.data['linearized_hertz_fit_two_layer']['layer1']['fit_length_datapoints'] = copy.deepcopy(data_fit_length_index_layer1)
                self.data['linearized_hertz_fit_two_layer']['layer1']['apparent_layer_thickness'] = copy.deepcopy(data_apparent_layer_thickness_layer1)

                self.data['linearized_hertz_fit_two_layer']['layer2'] = dict()
                self.data['linearized_hertz_fit_two_layer']['layer2']['value'] = copy.deepcopy(data_layer2)
                self.data['linearized_hertz_fit_two_layer']['layer2']['error'] = copy.deepcopy(data_error_layer2)
                self.data['linearized_hertz_fit_two_layer']['layer2']['fit_length_interval'] = copy.deepcopy(data_fit_length_interval_layer2)
                self.data['linearized_hertz_fit_two_layer']['layer2']['fit_length_datapoints'] = copy.deepcopy(data_fit_length_index_layer2)

                self.two_layer_hertz['full_map']['poisson_ratio'] = poisson_ratio
                self.two_layer_hertz['full_map']['units'] = copy.deepcopy(self.units)
                self.two_layer_hertz['full_map']['e_modul_unit'] = 'Pa'
                self.two_layer_hertz['full_map']['e_modul_factor'] = 1
                self.two_layer_hertz['full_map']['corrections'] = copy.deepcopy(self.corrections)
                self.two_layer_hertz['full_map']['analyzed'] = True
                self.two_layer_hertz['full_map']['successfully_analyzed'] = dict()
                self.two_layer_hertz['full_map']['successfully_analyzed']['layer1'] = np.sum(~np.isnan(np.reshape(data_layer1,-1)))
                self.two_layer_hertz['full_map']['successfully_analyzed']['layer2'] = np.sum(~np.isnan(np.reshape(data_layer2,-1)))
                self.two_layer_hertz['full_map']['successfully_analyzed_percent'] = dict()
                self.two_layer_hertz['full_map']['successfully_analyzed_percent']['layer1'] = 100 * self.two_layer_hertz['full_map']['successfully_analyzed']['layer1']/np.reshape(data_layer1,-1).size
                self.two_layer_hertz['full_map']['successfully_analyzed_percent']['layer2'] = 100 * self.two_layer_hertz['full_map']['successfully_analyzed']['layer2']/np.reshape(data_layer2,-1).size

                sys.stdout.write(' -- Done!\n')


                try:

                    file_pickle = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + '.two_layer_linearized_hertz.' + timestamp + '.pkl')
                    out_pkl = open(file_pickle, 'wb')
                    pickle.dump(self.two_layer_hertz['full_map'], out_pkl)

                except:

                    log_file.write('ERROR! Cannot open/write file ' + file_pickle)

                finally:

                    out_pkl.close()

                log_file.close()

            else:

                self.two_layer_hertz['full_map']= dict()

                self.two_layer_hertz['full_map']['indenter'] = indenter_characteristics

                self.two_layer_hertz['full_map']['method'] = dict()
                self.two_layer_hertz['full_map']['method']['type'] = 'linear'

                self.two_layer_hertz['full_map']['method']['parameter'] = dict()
                self.two_layer_hertz['full_map']['method']['parameter']['transition_sensitivity'] = transition_sensitivity
                self.two_layer_hertz['full_map']['method']['parameter']['transition_factor'] = transition_fac

                self.two_layer_hertz['full_map']['method']['parameter']['layer1'] = dict()
                self.two_layer_hertz['full_map']['method']['parameter']['layer1']['r_squared_limit'] = layer1_parameters['r_squared_limit']
                self.two_layer_hertz['full_map']['method']['parameter']['layer1']['with_residuals'] = layer1_parameters['with_residuals']
                self.two_layer_hertz['full_map']['method']['parameter']['layer1']['residual_sensitivity'] = layer1_parameters['residual_sensitivity']
                self.two_layer_hertz['full_map']['method']['parameter']['layer1']['residual_factor'] = residual_fac_layer1
                self.two_layer_hertz['full_map']['method']['parameter']['layer1']['final_fit_fraction'] = layer1_parameters['final_fit_fraction']

                self.two_layer_hertz['full_map']['method']['parameter']['layer2'] = dict()
                self.two_layer_hertz['full_map']['method']['parameter']['layer2']['r_squared_limit'] = layer2_parameters['r_squared_limit']
                self.two_layer_hertz['full_map']['method']['parameter']['layer2']['with_residuals'] = layer2_parameters['with_residuals']
                self.two_layer_hertz['full_map']['method']['parameter']['layer2']['residual_sensitivity'] = layer2_parameters['residual_sensitivity']
                self.two_layer_hertz['full_map']['method']['parameter']['layer2']['residual_factor'] = residual_fac_layer2
                self.two_layer_hertz['full_map']['method']['parameter']['layer2']['final_fit_fraction'] = layer2_parameters['final_fit_fraction']


                self.two_layer_hertz['full_map']['filter'] = dict()
                self.two_layer_hertz['full_map']['filter']['layer1'] = dict()
                self.two_layer_hertz['full_map']['filter']['layer1']['type'] = 'savitzky-golay'
                self.two_layer_hertz['full_map']['filter']['layer1']['parameter'] = dict()
                self.two_layer_hertz['full_map']['filter']['layer1']['parameter']['length'] = layer1_parameters['savgol_filter_characteristics']['length']
                self.two_layer_hertz['full_map']['filter']['layer1']['parameter']['order'] = layer1_parameters['savgol_filter_characteristics']['order']

                timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                sys.stdout.write('\rFitting Two-Layer Linearized Hertz model: %.2f%% <%d/%d>' %(0, 0, self.settings['fd_indices']['total']))
                log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_two_layer_linearized_hertz.' + timestamp +'.txt'), 'w')

                count = 1

                data_layer1 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_layer2 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_error_layer1 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_error_layer2 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_fit_length_index_layer1 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_fit_length_index_layer2 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_fit_length_interval_layer1 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_fit_length_interval_layer2 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_apparent_layer_thickness_layer1 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)

                self.two_layer_hertz['full_map']['indices'] = dict()

                for ind in self.settings['fd_indices']['list']:

                    y = int(ind / self.settings['grid']['y'])
                    x = (ind) % self.settings['grid']['x']

                    self.two_layer_hertz['full_map']['indices'][ind] = dict()

                    try:

                        fd = self.extract_fd_curve_batch(ind)

                        fd.set_save_directory(self.file_info['save_directory'])
                             # 3. correct data
                        fd.correct_data(force_unit = self.corrections_pass_to_function['force_unit'],
                                        distance_unit = self.corrections_pass_to_function['distance_unit'],
                                        noise_lvl = self.corrections_pass_to_function['noise_lvl'],
                                        distance_correction = self.corrections_pass_to_function['distance_correction'],
                                        baseline_correction = self.corrections_pass_to_function['baseline_correction'],
                                        get_tip_sample_separation = self.corrections_pass_to_function['get_tip_sample_separation'])

                        fd.fit_two_layer_linearized_hertz_model(poisson_ratio = poisson_ratio,
                                                                indenter_characteristics = indenter_characteristics,
                                                                transition_sensitivity = transition_sensitivity,
                                                                filter_correction_fraction = filter_correction_fraction,
                                                                layer1_parameters = layer1_parameters,
                                                                layer2_parameters = layer2_parameters)


                        self.two_layer_hertz['full_map']['indices'][ind]['young_modulus'] = fd.two_layer_hertz['young_modulus']

                        self.two_layer_hertz['full_map']['indices'][ind]['best_fit'] = fd.two_layer_hertz['best_fit']
                        self.two_layer_hertz['full_map']['indices'][ind]['residuals'] = fd.two_layer_hertz['residuals']

                        if fd.two_layer_hertz['best_fit']['layer1']['line_found']:

                            data_layer1[y][x] = fd.two_layer_hertz['young_modulus']['layer1']['value']
                            data_error_layer1[y][x] = fd.two_layer_hertz['residuals']['layer1']['mean_linear_fit']
                            data_fit_length_interval_layer1[y][x] = fd.two_layer_hertz['best_fit']['layer1']['interval'][0] - fd.two_layer_hertz['best_fit']['layer1']['interval'][1]
                            data_fit_length_index_layer1[y][x] = fd.two_layer_hertz['best_fit']['layer1']['index'][1] - fd.two_layer_hertz['best_fit']['layer1']['index'][0]
                            data_apparent_layer_thickness_layer1[y][x] = fd.two_layer_hertz['best_fit']['layer1']['contact_point']['value'] - fd.two_layer_hertz['best_fit']['layer1']['interval'][1]

                        if fd.two_layer_hertz['best_fit']['layer2']['line_found']:

                            data_layer2[y][x] = fd.two_layer_hertz['young_modulus']['layer2']['value']
                            data_error_layer2[y][x] = fd.two_layer_hertz['residuals']['layer2']['mean_linear_fit']
                            data_fit_length_interval_layer2[y][x] = fd.two_layer_hertz['best_fit']['layer2']['interval'][0] - fd.two_layer_hertz['best_fit']['layer2']['interval'][1]
                            data_fit_length_index_layer2[y][x] = fd.two_layer_hertz['best_fit']['layer2']['index'][1] - fd.two_layer_hertz['best_fit']['layer2']['index'][0]


                        self.two_layer_hertz['full_map']['indices'][ind]['except'] = False

                    except:

                        self.two_layer_hertz['full_map']['indices'][ind]['except'] = True
                        log_file.write('An error occured while processing index ' + str(ind) + '\n')

                    finally:

                             #self.youngs_modulus[ind] = copy.deepcopy(ret_dict_complete[ind])
                        sys.stdout.write('\rFitting Two-Layer Linearized Hertz model: %.2f%% <%d/%d>' %(count/self.settings['fd_indices']['total']*100, count,self.settings['fd_indices']['total']))
                        count += 1

                self.data['linearized_hertz_fit_two_layer'] = dict()
                self.data['linearized_hertz_fit_two_layer']['layer1'] = dict()
                self.data['linearized_hertz_fit_two_layer']['layer1']['value'] = copy.deepcopy(data_layer1)
                self.data['linearized_hertz_fit_two_layer']['layer1']['error'] = copy.deepcopy(data_error_layer1)
                self.data['linearized_hertz_fit_two_layer']['layer1']['fit_length_interval'] = copy.deepcopy(data_fit_length_interval_layer1)
                self.data['linearized_hertz_fit_two_layer']['layer1']['fit_length_datapoints'] = copy.deepcopy(data_fit_length_index_layer1)
                self.data['linearized_hertz_fit_two_layer']['layer1']['apparent_layer_thickness'] = copy.deepcopy(data_apparent_layer_thickness_layer1)

                self.data['linearized_hertz_fit_two_layer']['layer2'] = dict()
                self.data['linearized_hertz_fit_two_layer']['layer2']['value'] = copy.deepcopy(data_layer2)
                self.data['linearized_hertz_fit_two_layer']['layer2']['error'] = copy.deepcopy(data_error_layer2)
                self.data['linearized_hertz_fit_two_layer']['layer2']['fit_length_interval'] = copy.deepcopy(data_fit_length_interval_layer2)
                self.data['linearized_hertz_fit_two_layer']['layer2']['fit_length_datapoints'] = copy.deepcopy(data_fit_length_index_layer2)

                self.two_layer_hertz['full_map']['poisson_ratio'] = poisson_ratio
                self.two_layer_hertz['full_map']['units'] = copy.deepcopy(self.units)
                self.two_layer_hertz['full_map']['e_modul_unit'] = 'Pa'
                self.two_layer_hertz['full_map']['e_modul_factor'] = 1
                self.two_layer_hertz['full_map']['corrections'] = copy.deepcopy(self.corrections)
                self.two_layer_hertz['full_map']['analyzed'] = True
                self.two_layer_hertz['full_map']['successfully_analyzed'] = dict()
                self.two_layer_hertz['full_map']['successfully_analyzed']['layer1'] = np.sum(~np.isnan(np.reshape(data_layer1,-1)))
                self.two_layer_hertz['full_map']['successfully_analyzed']['layer2'] = np.sum(~np.isnan(np.reshape(data_layer2,-1)))
                self.two_layer_hertz['full_map']['successfully_analyzed_percent'] = dict()
                self.two_layer_hertz['full_map']['successfully_analyzed_percent']['layer1'] = 100 * self.two_layer_hertz['full_map']['successfully_analyzed']['layer1']/np.reshape(data_layer1,-1).size
                self.two_layer_hertz['full_map']['successfully_analyzed_percent']['layer2'] = 100 * self.two_layer_hertz['full_map']['successfully_analyzed']['layer2']/np.reshape(data_layer2,-1).size

                sys.stdout.write(' -- Done!\n')


                try:

                    file_pickle = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + '.two_layer_linearized_hertz.' + timestamp + '.pkl')
                    out_pkl = open(file_pickle, 'wb')
                    pickle.dump(self.two_layer_hertz['full_map'], out_pkl)

                except:

                    log_file.write('ERROR! Cannot open/write file ' + file_pickle)

                finally:

                    out_pkl.close()

                log_file.close()


        else:

            raise ValueError('ERROR! Set the corrections first!')





    def fit_multi_layer_segments(self, selection = False,
                                 poisson_ratio = 0.5,
                                 indenter_characteristics = {'geometry': 'parabolic', 'radius [nm]': 10},
                                 transition_sensitivity = 1,
                                 **kwargs):


        transition_fac = 5 - math.log10(transition_sensitivity) # is used in the _create_segments function


        segments = dict()
        segments[1] = dict()
        #segments[1]['index'] = dict()
        segments[2] = dict()
        #segments[2]['index'] = dict()
        segments[3] = dict()
        #segments[3]['index'] = dict()

        segments[1]['parameter'] = dict()
        segments[1]['parameter']['limit [Pa]'] = 5000
        segments[1]['parameter']['filter'] = dict()
        segments[1]['parameter']['filter']['applied'] = True
        segments[1]['parameter']['filter']['type'] = 'savitzky-golay'
        segments[1]['parameter']['filter']['parameter'] = {'length': 51, 'order': 1, 'deriv': 0, 'delta': 1.0, 'axis': -1, 'mode': 'interp', 'cval': 0.0}
        segments[1]['parameter']['transition_fac'] = transition_fac
        segments[1]['parameter']['fit_length'] = 100
        segments[1]['parameter']['final_fit_fraction'] = 0.9
        segments[1]['parameter']['r_squared_limit'] = 0.98
        segments[1]['parameter']['residual_sensitivity'] = 1 #residual fac 5
        segments[1]['parameter']['with_residuals'] = True
        segments[1]['parameter']['reverse_search'] = False

        segments[2]['parameter'] = dict()
        segments[2]['parameter']['limit [Pa]'] = 250000
        segments[2]['parameter']['filter'] = dict()
        segments[2]['parameter']['filter']['applied'] = False
        segments[2]['parameter']['transition_fac'] = transition_fac
        segments[2]['parameter']['fit_length'] = 75
        segments[2]['parameter']['final_fit_fraction'] = 0.9
        segments[2]['parameter']['r_squared_limit'] = 0.95
        segments[2]['parameter']['residual_sensitivity'] = 1 #residual fac 5
        segments[2]['parameter']['with_residuals'] = True
        segments[2]['parameter']['reverse_search'] = False

        segments[3]['parameter'] = dict()
        segments[3]['parameter']['limit [Pa]'] = np.nan
        segments[3]['parameter']['filter'] = dict()
        segments[3]['parameter']['filter']['applied'] = False
        segments[3]['parameter']['transition_fac'] = transition_fac
        segments[3]['parameter']['fit_length'] = 10
        segments[3]['parameter']['final_fit_fraction'] = 0.5
        segments[3]['parameter']['r_squared_limit'] = 0.9
        segments[3]['parameter']['residual_sensitivity'] = 1
        segments[3]['parameter']['with_residuals'] = True
        segments[3]['parameter']['reverse_search'] = True


        if self.control_variables['allow_analysis']:

#            if bool(selection) and selection in self.selections.keys():
            if bool(selection):

                if type(selection) is not list:

                    selection = [selection]

                for select in selection:

                    if select in self.selections.keys():

                        self.multi_layer_hertz['selections'][select] = dict()

                        self.multi_layer_hertz['selections'][select]['indenter'] = indenter_characteristics
                        self.multi_layer_hertz['selections'][select]['method'] = 'linear'

                        self.multi_layer_hertz['selections'][select]['parameter'] = dict()
                        self.multi_layer_hertz['selections'][select]['parameter']['transition_sensitivity'] = transition_sensitivity
                        self.multi_layer_hertz['selections'][select]['parameter']['transition_factor'] = transition_fac
                        self.multi_layer_hertz['selections'][select]['segments'] = segments


                        timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                        sys.stdout.write('\rFitting Multi-Layer Linearized Hertz model - Selection %s: %.2f%% <%d/%d>' %(select,0, 0, len(self.selections[select]['fd_index'])))
                        log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_hertz_mult_lay_lin.' + timestamp + '.' + select +'.txt'), 'w')


                        count = 1
                        self.counter['select'] = select
                        self.counter['count'] = 0
                        self.counter['max'] = len(self.selections[select]['fd_index']) - 1

                        self.multi_layer_hertz['selections'][select]['indices'] = dict()

                        for ind in self.selections[select]['fd_index']:

                            #y = int(ind / self.settings['grid']['y'])
                            #x = (ind) % self.settings['grid']['x']

                            self.multi_layer_hertz['selections'][select]['indices'][ind] = dict()

                            try:

                                fd = self.extract_fd_curve(ind)
                                #fd.set_save_directory(self.file_info['save_directory'])
                                fd.correct_data(force_unit = self.corrections_pass_to_function['force_unit'],
                                                distance_unit = self.corrections_pass_to_function['distance_unit'],
                                                noise_lvl = self.corrections_pass_to_function['noise_lvl'],
                                                distance_correction = self.corrections_pass_to_function['distance_correction'],
                                                baseline_correction = self.corrections_pass_to_function['baseline_correction'],
                                                get_tip_sample_separation = self.corrections_pass_to_function['get_tip_sample_separation'])

                                fd.fit_multi_layer_segments(segments = segments,
                                                            poisson_ratio = poisson_ratio,
                                                            indenter_characteristics = indenter_characteristics,
                                                            transition_sensitivity = transition_sensitivity,
                                                            **kwargs)

                                self.multi_layer_hertz['selections'][select]['indices'][ind]['segments'] = fd.multi_layer_hertz['segments']
                                self.multi_layer_hertz['selections'][select]['indices'][ind]['layers'] = fd.multi_layer_hertz['layers']
                                self.multi_layer_hertz['selections'][select]['indices'][ind]['young_modulus'] = fd.multi_layer_hertz['young_modulus']
                                self.multi_layer_hertz['selections'][select]['indices'][ind]['except'] = False

                            except:

                                self.multi_layer_hertz['selections'][select]['indices'][ind]['except'] = True
                                self.multi_layer_hertz['selections'][select]['indices'][ind]['young_modulus'] = {1: np.nan, 2: 'Pa', 3: 1}
                                log_file.write('-------------------------------\n')
                                log_file.write('An error occured while processing index ' + str(ind) + '\n')
                                traceback.print_exc(file = log_file)


                            finally:


                                sys.stdout.write('\rFitting Multi-Layer Linearized Hertz model - Selection %s: %.2f%% <%d/%d>' %(select,count/len(self.selections[select]['fd_index'])*100, count,len(self.selections[select]['fd_index'])))
                                count += 1
                                self.counter['count'] += 1


                        self.multi_layer_hertz['selections'][select]['poisson_ratio'] = poisson_ratio
                        self.multi_layer_hertz['selections'][select]['units'] = copy.deepcopy(self.units)
                        self.multi_layer_hertz['selections'][select]['e_modul_unit'] = 'Pa'
                        self.multi_layer_hertz['selections'][select]['e_modul_factor'] = 1
                        self.multi_layer_hertz['selections'][select]['corrections'] = copy.deepcopy(self.corrections_pass_to_function)

                        sys.stdout.write(' -- Done!\n')

                        try: # for some reason, this section causes problems with Franklin, the file cannot be created...although the same works for whole map analysis

                            file_pickle = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + '.hertz_mult_lay_lin.' + timestamp + '.'+ select + '.pkl')
                            out_pkl = open(file_pickle, 'wb')
                            pickle.dump(self.multi_layer_hertz['selections'][select], out_pkl)

                        except:

                            #log_file.write('ERROR! Cannot open/write file ' + file_pickle)
                            log_file.write('-------------------------------\n')
                            log_file.write('ERROR! Cannot open/write file ' + file_pickle)
                            traceback.print_exc(file = log_file)


                        finally:

                            out_pkl.close()

                        log_file.close()


                    elif select not in self.selections.keys():

                        print('ERROR! Selection', select,'is not a valid selection.')

            elif ('plot_result' in kwargs and kwargs['plot_result']) or ('export_result' in kwargs and kwargs['export_result']):

                self.multi_layer_hertz['full_map'] = dict()

                self.multi_layer_hertz['full_map']['indenter'] = indenter_characteristics
                self.multi_layer_hertz['full_map']['method'] = 'linear'

                self.multi_layer_hertz['full_map']['parameter'] = dict()
                self.multi_layer_hertz['full_map']['parameter']['transition_sensitivity'] = transition_sensitivity
                self.multi_layer_hertz['full_map']['parameter']['transition_factor'] = transition_fac
                self.multi_layer_hertz['full_map']['segments'] = segments


                timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                sys.stdout.write('\rFitting Multi-Layer Linearized Hertz model - with plot/export result: %.2f%% <%d/%d>' %(0, 0, self.settings['fd_indices']['total']))
                log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_hertz_mult_lay_lin.' + timestamp +'.txt'), 'w')

                data = dict()
                data_fit_length_index = dict()
                data_fit_length_interval = dict()
                data_error = dict()

                for seg in segments.keys():

                    data[seg] = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                    data_fit_length_index[seg] = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                    data_fit_length_interval[seg] = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                    data_error[seg] = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)


                data_apparent_layer_thickness_layer1 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)


                count = 1
                self.counter['count'] = 0
                self.counter['max'] = self.settings['fd_indices']['total'] - 1

                self.multi_layer_hertz['full_map']['indices'] = dict()

                for ind in self.settings['fd_indices']['list']:

                    y = int(ind / self.settings['grid']['y'])
                    x = (ind) % self.settings['grid']['x']

                    self.multi_layer_hertz['full_map']['indices'][ind] = dict()

                    try:

                        fd = self.extract_fd_curve(ind)
                        #fd.set_save_directory(self.file_info['save_directory'])
                        fd.correct_data(force_unit = self.corrections_pass_to_function['force_unit'],
                                        distance_unit = self.corrections_pass_to_function['distance_unit'],
                                        noise_lvl = self.corrections_pass_to_function['noise_lvl'],
                                        distance_correction = self.corrections_pass_to_function['distance_correction'],
                                        baseline_correction = self.corrections_pass_to_function['baseline_correction'],
                                        get_tip_sample_separation = self.corrections_pass_to_function['get_tip_sample_separation'])

                        fd.fit_multi_layer_segments(segments = segments,
                                                    poisson_ratio = poisson_ratio,
                                                    indenter_characteristics = indenter_characteristics,
                                                    transition_sensitivity = transition_sensitivity,
                                                    **kwargs)

                        self.multi_layer_hertz['full_map']['indices'][ind]['segments'] = fd.multi_layer_hertz['segments']
                        self.multi_layer_hertz['full_map']['indices'][ind]['layers'] = fd.multi_layer_hertz['layers']
                        self.multi_layer_hertz['full_map']['indices'][ind]['young_modulus'] = fd.multi_layer_hertz['young_modulus']
                        self.multi_layer_hertz['full_map']['indices'][ind]['except'] = False

                        for seg in segments.keys():

                            if fd.multi_layer_hertz['layers'][seg]['fit']['line_found']:

                                data[seg][y][x] = fd.multi_layer_hertz['layers'][seg]['young_modulus']['value']
                                data_error[seg][y][x] = fd.multi_layer_hertz['layers'][seg]['residuals']['mean_linear_fit']
                                data_fit_length_index[seg][y][x] = fd.multi_layer_hertz['layers'][seg]['fit']['index'][1] - fd.multi_layer_hertz['layers'][seg]['fit']['index'][0]
                                data_fit_length_interval[seg][y][x] = fd.multi_layer_hertz['layers'][seg]['fit']['interval'][0] - fd.multi_layer_hertz['layers'][seg]['fit']['interval'][1]

                                if seg == 1:

                                    data_apparent_layer_thickness_layer1[y][x] = fd.multi_layer_hertz['layers'][seg]['fit']['contact_point']['value'] - fd.multi_layer_hertz['layers'][seg]['fit']['interval'][1]


                    except:

                        self.multi_layer_hertz['full_map']['indices'][ind]['except'] = True
                        log_file.write('-------------------------------\n')
                        log_file.write('An error occured while processing index ' + str(ind) + '\n')
                        traceback.print_exc(file = log_file)

                    finally:

                             #self.youngs_modulus[ind] = copy.deepcopy(ret_dict_complete[ind])
                        sys.stdout.write('\rFitting Multi-Layer Linearized Hertz models - with plot/export result: %.2f%% <%d/%d>' %(count/self.settings['fd_indices']['total']*100, count,self.settings['fd_indices']['total']))
                        count += 1
                        self.counter['count'] += 1


                self.data['linearized_hertz_fit_multi_layer'] = dict()
                self.data['linearized_hertz_fit_multi_layer']['value'] = copy.deepcopy(data)
                self.data['linearized_hertz_fit_multi_layer']['error'] = copy.deepcopy(data_error)
                self.data['linearized_hertz_fit_multi_layer']['fit_length_datapoints'] = copy.deepcopy(data_fit_length_index)
                self.data['linearized_hertz_fit_multi_layer']['fit_length_interval'] = copy.deepcopy(data_fit_length_interval)
                self.data['linearized_hertz_fit_multi_layer']['apparent_layer_thickness'] = copy.deepcopy(data_apparent_layer_thickness_layer1)


                self.multi_layer_hertz['full_map']['poisson_ratio'] = poisson_ratio
                self.multi_layer_hertz['full_map']['units'] = copy.deepcopy(self.units)
                self.multi_layer_hertz['full_map']['e_modul_unit'] = 'Pa'
                self.multi_layer_hertz['full_map']['e_modul_factor'] = 1
                self.multi_layer_hertz['full_map']['corrections'] = copy.deepcopy(self.corrections_pass_to_function)

                self.multi_layer_hertz['full_map']['analyzed'] = True

                self.multi_layer_hertz['full_map']['successfully_analyzed'] = dict()

                for seg in segments.keys():

                    self.multi_layer_hertz['full_map']['successfully_analyzed'][seg] = dict()
                    self.multi_layer_hertz['full_map']['successfully_analyzed'][seg]['number'] = np.sum(~np.isnan(np.reshape(data[seg],-1)))
                    self.multi_layer_hertz['full_map']['successfully_analyzed'][seg]['precent'] = 100 * self.multi_layer_hertz['full_map']['successfully_analyzed'][seg]['number']/np.reshape(data[seg],-1).size


                sys.stdout.write(' -- Done!\n')

                try:

                    file_pickle = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + '.hertz_mult_lay_lin.' + timestamp + '.pkl')
                    out_pkl = open(file_pickle, 'wb')
                    pickle.dump(self.multi_layer_hertz['full_map'], out_pkl)

                except:

                    log_file.write('-------------------------------\n')
                    log_file.write('ERROR! Cannot open/write file ' + file_pickle)
                    traceback.print_exc(file = log_file)

                finally:

                    out_pkl.close()

                log_file.close()

            else:

                self.multi_layer_hertz['full_map'] = dict()

                self.multi_layer_hertz['full_map']['indenter'] = indenter_characteristics
                self.multi_layer_hertz['full_map']['method'] = 'linear'

                self.multi_layer_hertz['full_map']['parameter'] = dict()
                self.multi_layer_hertz['full_map']['parameter']['transition_sensitivity'] = transition_sensitivity
                self.multi_layer_hertz['full_map']['parameter']['transition_factor'] = transition_fac
                self.multi_layer_hertz['full_map']['segments'] = segments


                timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                sys.stdout.write('\rFitting Multi-Layer Linearized Hertz model: %.2f%% <%d/%d>' %(0, 0, self.settings['fd_indices']['total']))
                log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_hertz_mult_lay_lin.' + timestamp +'.txt'), 'w')

                data = dict()
                data_fit_length_index = dict()
                data_fit_length_interval = dict()
                data_error = dict()

                for seg in segments.keys():

                    data[seg] = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                    data_fit_length_index[seg] = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                    data_fit_length_interval[seg] = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                    data_error[seg] = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)


                data_apparent_layer_thickness_layer1 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)

                count = 1
                self.counter['count'] = 0
                self.counter['max'] = self.settings['fd_indices']['total'] - 1

                self.multi_layer_hertz['full_map']['indices'] = dict()

                for ind in self.settings['fd_indices']['list']:

                    y = int(ind / self.settings['grid']['y'])
                    x = (ind) % self.settings['grid']['x']

                    self.multi_layer_hertz['full_map']['indices'][ind] = dict()

                    try:

                        fd = self.extract_fd_curve_batch(ind)
                        #fd.set_save_directory(self.file_info['save_directory'])
                        fd.correct_data(force_unit = self.corrections_pass_to_function['force_unit'],
                                        distance_unit = self.corrections_pass_to_function['distance_unit'],
                                        noise_lvl = self.corrections_pass_to_function['noise_lvl'],
                                        distance_correction = self.corrections_pass_to_function['distance_correction'],
                                        baseline_correction = self.corrections_pass_to_function['baseline_correction'],
                                        get_tip_sample_separation = self.corrections_pass_to_function['get_tip_sample_separation'])

                        fd.fit_multi_layer_segments(segments = segments,
                                                    poisson_ratio = poisson_ratio,
                                                    indenter_characteristics = indenter_characteristics,
                                                    transition_sensitivity = transition_sensitivity)

                        self.multi_layer_hertz['full_map']['indices'][ind]['segments'] = fd.multi_layer_hertz['segments']
                        self.multi_layer_hertz['full_map']['indices'][ind]['layers'] = fd.multi_layer_hertz['layers']
                        self.multi_layer_hertz['full_map']['indices'][ind]['young_modulus'] = fd.multi_layer_hertz['young_modulus']
                        self.multi_layer_hertz['full_map']['indices'][ind]['except'] = False

                        for seg in segments.keys():

                            if fd.multi_layer_hertz['layers'][seg]['fit']['line_found']:

                                data[seg][y][x] = fd.multi_layer_hertz['layers'][seg]['young_modulus']['value']
                                data_error[seg][y][x] = fd.multi_layer_hertz['layers'][seg]['residuals']['mean_linear_fit']
                                data_fit_length_index[seg][y][x] = fd.multi_layer_hertz['layers'][seg]['fit']['index'][1] - fd.multi_layer_hertz['layers'][seg]['fit']['index'][0]
                                data_fit_length_interval[seg][y][x] = fd.multi_layer_hertz['layers'][seg]['fit']['interval'][0] - fd.multi_layer_hertz['layers'][seg]['fit']['interval'][1]

                                if seg == 1:

                                    data_apparent_layer_thickness_layer1[y][x] = fd.multi_layer_hertz['layers'][seg]['fit']['contact_point']['value'] - fd.multi_layer_hertz['layers'][seg]['fit']['interval'][1]


                    except:

                        self.multi_layer_hertz['full_map']['indices'][ind]['except'] = True
                        log_file.write('-------------------------------\n')
                        log_file.write('An error occured while processing index ' + str(ind) + '\n')
                        traceback.print_exc(file = log_file)

                    finally:

                             #self.youngs_modulus[ind] = copy.deepcopy(ret_dict_complete[ind])
                        sys.stdout.write('\rFitting Multi-Layer Linearized Hertz models: %.2f%% <%d/%d>' %(count/self.settings['fd_indices']['total']*100, count,self.settings['fd_indices']['total']))
                        count += 1
                        self.counter['count'] += 1



                self.data['linearized_hertz_fit_multi_layer'] = dict()
                self.data['linearized_hertz_fit_multi_layer']['value'] = copy.deepcopy(data)
                self.data['linearized_hertz_fit_multi_layer']['error'] = copy.deepcopy(data_error)
                self.data['linearized_hertz_fit_multi_layer']['fit_length_datapoints'] = copy.deepcopy(data_fit_length_index)
                self.data['linearized_hertz_fit_multi_layer']['fit_length_interval'] = copy.deepcopy(data_fit_length_interval)
                self.data['linearized_hertz_fit_multi_layer']['apparent_layer_thickness'] = copy.deepcopy(data_apparent_layer_thickness_layer1)


                self.multi_layer_hertz['full_map']['poisson_ratio'] = poisson_ratio
                self.multi_layer_hertz['full_map']['units'] = copy.deepcopy(self.units)
                self.multi_layer_hertz['full_map']['e_modul_unit'] = 'Pa'
                self.multi_layer_hertz['full_map']['e_modul_factor'] = 1
                self.multi_layer_hertz['full_map']['corrections'] = copy.deepcopy(self.corrections_pass_to_function)

                self.multi_layer_hertz['full_map']['analyzed'] = True

                self.multi_layer_hertz['full_map']['successfully_analyzed'] = dict()

                for seg in segments.keys():

                    self.multi_layer_hertz['full_map']['successfully_analyzed'][seg] = dict()
                    self.multi_layer_hertz['full_map']['successfully_analyzed'][seg]['number'] = np.sum(~np.isnan(np.reshape(data[seg],-1)))
                    self.multi_layer_hertz['full_map']['successfully_analyzed'][seg]['precent'] = 100 * self.multi_layer_hertz['full_map']['successfully_analyzed'][seg]['number']/np.reshape(data[seg],-1).size


                sys.stdout.write(' -- Done!\n')


                try:

                    file_pickle = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + '.hertz_mult_lay_lin.' + timestamp + '.pkl')
                    out_pkl = open(file_pickle, 'wb')
                    pickle.dump(self.multi_layer_hertz['full_map'], out_pkl)

                except:

                    log_file.write('-------------------------------\n')
                    log_file.write('ERROR! Cannot open/write file ' + file_pickle)
                    traceback.print_exc(file = log_file)

                finally:

                    out_pkl.close()

                log_file.close()


        else:

            raise ValueError('ERROR! Set the corrections first!')












    def get_apparent_layer_thickness(self, selection = False, reference = 'basic', perc_setpoint = 0.8):

        if self.control_variables['allow_analysis'] and reference in ['hertz_fit', 'basic', 'setpoint']:

#            if bool(selection) and selection in self.selections.keys():
            if bool(selection):

                if type(selection) is not list:

                    selection = [selection]

                for select in selection:

                    if select in self.selections.keys():

                        self.apparent_layer['selections'][select] = dict()

                        timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                        sys.stdout.write('\rMeasure layer thicknessl - Selection %s: %.2f%% <%d/%d>' %(select,0, 0, self.settings['fd_indices']['total']))
                        log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_apparent_layer.' + timestamp +'.txt'), 'w')

                        count = 1
                        self.counter['count'] = 0
                        self.counter['max'] = len(self.selections[select]['fd_index']) - 1
                        #data = np.zeros((self.settings['grid']['y'], self.settings['grid']['x']))

                        self.apparent_layer['selections'][select]['indices'] = dict()

                        for ind in self.selections[select]['fd_index']:

                            try:

                                fd = self.extract_fd_curve_batch(ind)

                                fd.correct_data(force_unit = self.corrections_pass_to_function['force_unit'],
                                                distance_unit = self.corrections_pass_to_function['distance_unit'],
                                                noise_lvl = self.corrections_pass_to_function['noise_lvl'],
                                                distance_correction = self.corrections_pass_to_function['distance_correction'],
                                                baseline_correction = self.corrections_pass_to_function['baseline_correction'],
                                                get_tip_sample_separation = self.corrections_pass_to_function['get_tip_sample_separation'])

                                if reference == 'hertz_fit':

                                    thickness = fd.data['extend'][self.keys['ts_key']][self.hertz_fit['selections']['indices'][select][ind]['best_fit']['contact_point']['index']] - fd.data['extend'][self.keys['ts_key']][-1]
                                    self.apparent_layer['selections'][select]['indices'][ind] = thickness

                                elif reference == 'basic':

                                    thickness = abs(fd.data['extend'][self.keys['ts_key']][-1])
                                    self.apparent_layer['selections'][select]['indices'][ind] = thickness


                            except:

                                log_file.write('An error occured while processing index ' + str(ind) + '\n')

                            finally:

                                sys.stdout.write('\rMeasure layer thicknessl - Selection %s: %.2f%% <%d/%d>' %(select,count/len(self.selections[select]['fd_index'])*100, count,len(self.selections[select]['fd_index'])))
                                count += 1
                                self.counter['count'] += 1

                        self.apparent_layer['selections'][select]['reference'] = reference
                        sys.stdout.write(' -- Done!\n')

                    elif select not in self.selections.keys():

                        print('ERROR! Selection', select,'is not a valid selection.')

            else:

                if not 'apparent_layer' in self.data.keys():

                    self.data['apparent_layer'] = dict()


                timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                sys.stdout.write('\rMeasure soft layer thickness: %.2f%% <%d/%d>' %(0, 0, self.settings['fd_indices']['total']))
                log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_apparent_layer.' + timestamp +'.txt'), 'w')

                count = 1
                self.counter['count'] = 0
                self.counter['max'] = self.settings['fd_indices']['total'] - 1

                data = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)

                for ind in self.settings['fd_indices']['list']:

                    y = int(ind / self.settings['grid']['y'])
                    x = (ind) % self.settings['grid']['x']

                    try:

                        fd = self.extract_fd_curve_batch(ind)

                        fd.correct_data(force_unit = self.corrections_pass_to_function['force_unit'],
                                        distance_unit = self.corrections_pass_to_function['distance_unit'],
                                        noise_lvl = self.corrections_pass_to_function['noise_lvl'],
                                        distance_correction = self.corrections_pass_to_function['distance_correction'],
                                        baseline_correction = self.corrections_pass_to_function['baseline_correction'],
                                        get_tip_sample_separation = self.corrections_pass_to_function['get_tip_sample_separation'])

                        if reference == 'hertz_fit':

                            thickness = fd.data['extend'][self.keys['ts_key']][self.hertz_fit['full_map']['indices'][ind]['best_fit']['contact_point']['index']] - fd.data['extend'][self.keys['ts_key']][-1]
                            self.apparent_layer['hertz_fit'][ind] = thickness
                            data[y][x] = thickness

                        elif reference == 'basic':

                           thickness = abs(fd.data['extend'][self.keys['ts_key']][-1])
                           self.apparent_layer['basic'][ind] = thickness
                           data[y][x] = thickness

                        elif reference == 'setpoint':



                           end_index = np.argmax(fd.data['extend'][self.keys['y_key']] > perc_setpoint * self.settings['setpoint']['force (N)'] / fd.units['force']['factor'])

                           if not end_index:

                               thickness = np.inf

                           else:

                               thickness = abs(fd.data['extend'][self.keys['ts_key']][end_index])

                           self.apparent_layer['basic'][ind] = thickness
                           data[y][x] = thickness



                    except:

                        log_file.write('An error occured while processing index ' + str(ind) + '\n')

                    finally:

                        sys.stdout.write('\rMeasure soft layer thickness: %.2f%% <%d/%d>' %(count/self.settings['fd_indices']['total']*100, count,self.settings['fd_indices']['total']))
                        count += 1
                        self.counter['count'] += 1


                self.data['apparent_layer'][reference] = copy.deepcopy(data)
                sys.stdout.write(' -- Done!\n')

        else:

            raise ValueError('ERROR! Set the corrections first!')




    def get_baseline_tilt(self, frac_data, selection = False):

        if self.control_variables['allow_analysis']:

#            if bool(selection) and selection in self.selections.keys():
            if bool(selection):

                if type(selection) is not list:

                    selection = [selection]

                for select in selection:

                    if select in self.selections.keys():

                        self.baseline_tilt['selections'][select] = dict()
                        self.baseline_tilt['selections'][select]['extend'] = dict()
                        self.baseline_tilt['selections'][select]['retract'] = dict()
                        self.baseline_tilt['selections'][select]['parameter'] = dict()
                        self.baseline_tilt['selections'][select]['parameter']['frac_data'] = frac_data

                        timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                        sys.stdout.write('\rDetermine baseline tilt - Selection %s: %.2f%% <%d/%d>' %(select,0, 0, self.settings['fd_indices']['total']))
                        log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_baseline_tilt.' + timestamp +'.txt'), 'w')

                        count = 1
                        #data = np.zeros((self.settings['grid']['y'], self.settings['grid']['x']))

                        self.baseline_tilt['selections'][select]['extend']['indices'] = dict()
                        self.baseline_tilt['selections'][select]['retract']['indices'] = dict()

                        for ind in self.selections[select]['fd_index']:

                            try:

                                fd = self.extract_fd_curve_batch(ind)

                                slope_ext, baseline_ext = np.polyfit(fd.data['extend'][fd.keys['x_key']][int(fd.settings['samples']['extend'] * frac_data[0]):int(fd.settings['samples']['extend'] * frac_data[1])],
                                                                     fd.data['extend'][fd.keys['y_key']][int(fd.settings['samples']['extend'] * frac_data[0]):int(fd.settings['samples']['extend'] * frac_data[1])],1)
                                slope_ret, baseline_ret = np.polyfit(fd.data['retract'][fd.keys['x_key']][-int(fd.settings['samples']['retract'] * frac_data[1])-1:-int(fd.settings['samples']['extend'] * frac_data[0])-1],
                                                                     fd.data['retract'][fd.keys['y_key']][-int(fd.settings['samples']['retract'] * frac_data[1])-1:-int(fd.settings['samples']['extend'] * frac_data[0])-1],1)


                                self.baseline_tilt['selections'][select]['extend']['indices'][ind] = slope_ext
                                self.baseline_tilt['selections'][select]['retract']['indices'][ind] = slope_ret


                            except:

                                log_file.write('An error occured while processing index ' + str(ind) + '\n')

                            finally:

                                sys.stdout.write('\rDetermine baseline tilt - Selection %s: %.2f%% <%d/%d>' %(select,count/len(self.selections[select]['fd_index'])*100, count,len(self.selections[select]['fd_index'])))
                                count += 1


                        sys.stdout.write(' -- Done!\n')

                    elif select not in self.selections.keys():

                        print('ERROR! Selection', select,'is not a valid selection.')

            else:

                self.data['baseline_tilt'] = dict()

                timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                sys.stdout.write('\rDetermine baseline tilt: %.2f%% <%d/%d>' %(0, 0, self.settings['fd_indices']['total']))
                log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_baseline_tilt.' + timestamp +'.txt'), 'w')

                count = 1
                data_extend = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_retract = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)

                for ind in self.settings['fd_indices']['list']:

                    y = int(ind / self.settings['grid']['y'])
                    x = (ind) % self.settings['grid']['x']

                    try:

                        fd = self.extract_fd_curve_batch(ind)

                        slope_ext, baseline_ext = np.polyfit(fd.data['extend'][fd.keys['x_key']][int(fd.settings['samples']['extend'] * frac_data[0]):int(fd.settings['samples']['extend'] * frac_data[1])],
                                                             fd.data['extend'][fd.keys['y_key']][int(fd.settings['samples']['extend'] * frac_data[0]):int(fd.settings['samples']['extend'] * frac_data[1])],1)
                        slope_ret, baseline_ret = np.polyfit(fd.data['retract'][fd.keys['x_key']][-int(fd.settings['samples']['retract'] * frac_data[1])-1:-int(fd.settings['samples']['extend'] * frac_data[0])-1],
                                                             fd.data['retract'][fd.keys['y_key']][-int(fd.settings['samples']['retract'] * frac_data[1])-1:-int(fd.settings['samples']['extend'] * frac_data[0])-1],1)



                        self.baseline_tilt['full_map']['extend'][ind] = slope_ext
                        self.baseline_tilt['full_map']['retract'][ind] = slope_ret
                        self.baseline_tilt['full_map']['parameter'] = dict()
                        self.baseline_tilt['full_map']['parameter']['frac_data'] = frac_data

                        data_extend[y][x] = slope_ext
                        data_retract[y][x] = slope_ret


                    except:

                        log_file.write('An error occured while processing index ' + str(ind) + '\n')

                    finally:

                        sys.stdout.write('\rDetermine baseline tilt: %.2f%% <%d/%d>' %(count/self.settings['fd_indices']['total']*100, count,self.settings['fd_indices']['total']))
                        count += 1




                self.data['baseline_tilt']['extend'] = copy.deepcopy(data_extend)
                self.data['baseline_tilt']['retract'] = copy.deepcopy(data_retract)

                sys.stdout.write(' -- Done!\n')


                try:

                    file_pickle_ext = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + '.baseline_tilt_extend.' + timestamp + '.pkl')
                    out_pkl_ext = open(file_pickle_ext, 'wb')

                    pickle.dump(data_extend, out_pkl_ext)

                except:

                     log_file.write('ERROR! Cannot open/write file ' + file_pickle_ext)

                finally:

                     out_pkl_ext.close()

                try:

                    file_pickle_ret = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + '.baseline_tilt_retract.' + timestamp + '.pkl')
                    out_pkl_ret = open(file_pickle_ret, 'wb')

                    pickle.dump(data_retract, out_pkl_ret)

                except:

                     log_file.write('ERROR! Cannot open/write file ' + file_pickle_ret)

                finally:

                     out_pkl_ret.close()

                log_file.close()


        else:

            raise ValueError('ERROR! Set the corrections first!')




    def get_slope_contact(self, frac_data = (0.95, 1), selection = False):

        if self.control_variables['allow_analysis']:

#            if bool(selection) and selection in self.selections.keys():
            if bool(selection):

                if type(selection) is not list:

                    selection = [selection]

                for select in selection:

                    if select in self.selections.keys():

                        self.slope_contact['selections'][select] = dict()
                        self.slope_contact['selections'][select]['extend'] = dict()
                        self.slope_contact['selections'][select]['retract'] = dict()
                        self.slope_contact['selections'][select]['parameter'] = dict()
                        self.slope_contact['selections'][select]['parameter']['frac_data'] = frac_data

                        timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                        sys.stdout.write('\rDetermine slope in contact - Selection %s: %.2f%% <%d/%d>' %(select,0, 0, self.settings['fd_indices']['total']))
                        log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_slope_in_contact.' + timestamp +'.txt'), 'w')

                        count = 1
                        #data = np.zeros((self.settings['grid']['y'], self.settings['grid']['x']))

                        self.baseline_tilt['selections'][select]['extend']['indices'] = dict()
                        self.baseline_tilt['selections'][select]['retract']['indices'] = dict()

                        for ind in self.selections[select]['fd_index']:

                            try:

                                fd = self.extract_fd_curve_batch(ind)

                                fd.correct_data(force_unit = self.corrections_pass_to_function['force_unit'],
                                                distance_unit = self.corrections_pass_to_function['distance_unit'],
                                                noise_lvl = self.corrections_pass_to_function['noise_lvl'],
                                                distance_correction = self.corrections_pass_to_function['distance_correction'],
                                                baseline_correction = self.corrections_pass_to_function['baseline_correction'],
                                                get_tip_sample_separation = self.corrections_pass_to_function['get_tip_sample_separation'])

                                result_fit = fd.get_slope_contact(frac_data = frac_data)

                                self.baseline_tilt['selections'][select]['extend']['indices'][ind] = result_fit['results']['extend']['slope']
                                self.baseline_tilt['selections'][select]['retract']['indices'][ind] = result_fit['results']['extend']['slope']


                            except:

                                log_file.write('An error occured while processing index ' + str(ind) + '\n')

                            finally:

                                sys.stdout.write('\rDetermine slope in contact - Selection %s: %.2f%% <%d/%d>' %(select,count/len(self.selections[select]['fd_index'])*100, count,len(self.selections[select]['fd_index'])))
                                count += 1


                        sys.stdout.write(' -- Done!\n')

                    elif select not in self.selections.keys():

                        print('ERROR! Selection', select,'is not a valid selection.')

            else:

                self.data['slope_in_contact'] = dict()

                timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                sys.stdout.write('\rDetermine slope in contact: %.2f%% <%d/%d>' %(0, 0, self.settings['fd_indices']['total']))
                log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_slope_in_contact.' + timestamp +'.txt'), 'w')

                count = 1
                data_extend = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_retract = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)

                for ind in self.settings['fd_indices']['list']:

                    y = int(ind / self.settings['grid']['y'])
                    x = (ind) % self.settings['grid']['x']

                    try:

                        fd = self.extract_fd_curve_batch(ind)

                        fd.correct_data(force_unit = self.corrections_pass_to_function['force_unit'],
                                        distance_unit = self.corrections_pass_to_function['distance_unit'],
                                        noise_lvl = self.corrections_pass_to_function['noise_lvl'],
                                        distance_correction = self.corrections_pass_to_function['distance_correction'],
                                        baseline_correction = self.corrections_pass_to_function['baseline_correction'],
                                        get_tip_sample_separation = self.corrections_pass_to_function['get_tip_sample_separation'])

                        result_fit = fd.get_slope_contact(frac_data = frac_data)



                        self.slope_contact['full_map']['extend'][ind] = result_fit['results']['extend']['slope']
                        self.slope_contact['full_map']['retract'][ind] = result_fit['results']['retract']['slope']
                        self.slope_contact['full_map']['parameter'] = dict()
                        self.slope_contact['full_map']['parameter']['frac_data'] = frac_data

                        data_extend[y][x] = result_fit['results']['extend']['slope']
                        data_retract[y][x] = result_fit['results']['retract']['slope']


                    except:

                        log_file.write('An error occured while processing index ' + str(ind) + '\n')

                    finally:

                        sys.stdout.write('\rDetermine slope in contact: %.2f%% <%d/%d>' %(count/self.settings['fd_indices']['total']*100, count,self.settings['fd_indices']['total']))
                        count += 1




                self.data['slope_in_contact']['extend'] = copy.deepcopy(data_extend)
                self.data['slope_in_contact']['retract'] = copy.deepcopy(data_retract)

                sys.stdout.write(' -- Done!\n')


                try:

                    file_pickle_ext = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + '.slope_in_contact_extend.' + timestamp + '.pkl')
                    out_pkl_ext = open(file_pickle_ext, 'wb')

                    pickle.dump(data_extend, out_pkl_ext)

                except:

                     log_file.write('ERROR! Cannot open/write file ' + file_pickle_ext)

                finally:

                     out_pkl_ext.close()

                try:

                    file_pickle_ret = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + '.slope_in_contact_retract.' + timestamp + '.pkl')
                    out_pkl_ret = open(file_pickle_ret, 'wb')

                    pickle.dump(data_retract, out_pkl_ret)

                except:

                     log_file.write('ERROR! Cannot open/write file ' + file_pickle_ret)

                finally:

                     out_pkl_ret.close()

                log_file.close()


        else:

            raise ValueError('ERROR! Set the corrections first!')




    def get_breakthrough_events(self, selection = False, sensitivity = 1, start_fraction = 0.5, event_sep = 1, **kwargs):

        if self.control_variables['allow_analysis']:

            if bool(selection):

                if type(selection) is not list:

                    selection = [selection]

                for select in selection:

                    if select in self.selections.keys():

                        self.breakthrough_events['selections'][select] = dict()


                        timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                        sys.stdout.write('\rFind breakthrough events - Selection %s: %.2f%% <%d/%d>' %(select,0, 0, self.settings['fd_indices']['total']))
                        log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_breakthrough_event.' + timestamp +'.txt'), 'w')

                        count = 1
                        self.counter['select'] = select
                        self.counter['count'] = 0
                        self.counter['max'] = len(self.selections[select]['fd_index']) - 1

                        self.breakthrough_events['selections'][select]['indices'] = dict()

                        for ind in self.selections[select]['fd_index']:

                            try:

                                fd = self.extract_fd_curve(ind)

                                fd.correct_data(force_unit = self.corrections_pass_to_function['force_unit'],
                                                distance_unit = self.corrections_pass_to_function['distance_unit'],
                                                noise_lvl = self.corrections_pass_to_function['noise_lvl'],
                                                distance_correction = self.corrections_pass_to_function['distance_correction'],
                                                baseline_correction = self.corrections_pass_to_function['baseline_correction'],
                                                get_tip_sample_separation = self.corrections_pass_to_function['get_tip_sample_separation'])

                                fd.get_breakthrough_events(sensitivity = sensitivity, start_fraction = start_fraction, event_sep = event_sep, **kwargs)

                                self.breakthrough_events['selections'][select]['indices'][ind] = fd.breakthrough_events



                            except:

                                log_file.write('An error occured while processing index ' + str(ind) + '\n')

                            finally:

                                sys.stdout.write('\rFind breakthrough events - Selection %s: %.2f%% <%d/%d>' %(select,count/len(self.selections[select]['fd_index'])*100, count,len(self.selections[select]['fd_index'])))
                                count += 1
                                self.counter['count'] += 1

                            self.breakthrough_events['selections'][select]['parameter'] = {'sensitivity': sensitivity, 'sensitivity_factor': 5 - math.log10(sensitivity), 'event_separation':event_sep}
                            self.breakthrough_events['selections'][select]['units'] = copy.deepcopy(self.units)
                            self.breakthrough_events['selections'][select]['corrections'] = copy.deepcopy(self.corrections_pass_to_function)

                        sys.stdout.write(' -- Done!\n')
                        log_file.close()

                    elif select not in self.selections.keys():

                        print('ERROR! Selection', select,'is not a valid selection.')



            elif ('plot_result' in kwargs and kwargs['plot_result']) or ('export_result' in kwargs and kwargs['export_result']):

                self.data['breakthrough_events'] = dict()

                timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                sys.stdout.write('\rFind breakthrough events - with plot/export results: %.2f%% <%d/%d>' %(0, 0, self.settings['fd_indices']['total']))
                log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_breakthrough_event.' + timestamp +'.txt'), 'w')

                count = 1
                self.counter['count'] = 0
                self.counter['max'] = self.settings['fd_indices']['total'] - 1

                #data_magn = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_exist = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_counts = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)

                self.breakthrough_events['full_map']['indices'] = dict()

                for ind in self.settings['fd_indices']['list']:

                    y = int(ind / self.settings['grid']['y'])
                    x = (ind) % self.settings['grid']['x']

                    try:

                        fd = self.extract_fd_curve(ind)

                        fd.correct_data(force_unit = self.corrections_pass_to_function['force_unit'],
                                        distance_unit = self.corrections_pass_to_function['distance_unit'],
                                        noise_lvl = self.corrections_pass_to_function['noise_lvl'],
                                        distance_correction = self.corrections_pass_to_function['distance_correction'],
                                        baseline_correction = self.corrections_pass_to_function['baseline_correction'],
                                        get_tip_sample_separation = self.corrections_pass_to_function['get_tip_sample_separation'])

                        fd.get_breakthrough_events(sensitivity = sensitivity, start_fraction = start_fraction, event_sep = event_sep, **kwargs)

                        self.breakthrough_events['full_map']['indices'][ind] = fd.breakthrough_events

                        #data_magn[y][x] = fd.breakthrough_event['magnitude']
                        data_exist[y][x] = fd.breakthrough_events['exists']
                        data_counts[y][x] = len(fd.breakthrough_events['events'])
                            #data_mult_noise[y][x] = fd.breakthrough_event['magnitude']/fd.breakthrough_event['noise_level']

                    except:

                        log_file.write('An error occured while processing index ' + str(ind) + '\n')

                    finally:

                        sys.stdout.write('\rFind breakthrough events - with plot/export results: %.2f%% <%d/%d>' %(count/self.settings['fd_indices']['total']*100, count,self.settings['fd_indices']['total']))
                        count += 1
                        self.counter['count'] += 1


                self.breakthrough_events['full_map']['parameter'] = {'sensitivity': sensitivity, 'sensitivity_factor': 5 - math.log10(sensitivity), 'event_separation':event_sep}
                self.breakthrough_events['full_map']['units'] = copy.deepcopy(self.units)
                self.breakthrough_events['full_map']['corrections'] = copy.deepcopy(self.corrections_pass_to_function)

                #self.data['breakthrough_events']['magnitude'] = copy.deepcopy(data_magn)
                self.data['breakthrough_events']['exists'] = copy.deepcopy(data_exist)
                self.data['breakthrough_events']['counts'] = copy.deepcopy(data_counts)

                sys.stdout.write(' -- Done!\n')
                log_file.close()

            else:

                self.data['breakthrough_events'] = dict()

                timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                sys.stdout.write('\rFind breakthrough events: %.2f%% <%d/%d>' %(0, 0, self.settings['fd_indices']['total']))
                log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_breakthrough_event.' + timestamp +'.txt'), 'w')

                count = 1
                self.counter['count'] = 0
                self.counter['max'] = self.settings['fd_indices']['total'] - 1

                #data_magn = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_exist = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                data_counts = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)

                self.breakthrough_events['full_map']['indices'] = dict()

                for ind in self.settings['fd_indices']['list']:

                    y = int(ind / self.settings['grid']['y'])
                    x = (ind) % self.settings['grid']['x']

                    try:

                        fd = self.extract_fd_curve_batch(ind)

                        fd.correct_data(force_unit = self.corrections_pass_to_function['force_unit'],
                                        distance_unit = self.corrections_pass_to_function['distance_unit'],
                                        noise_lvl = self.corrections_pass_to_function['noise_lvl'],
                                        distance_correction = self.corrections_pass_to_function['distance_correction'],
                                        baseline_correction = self.corrections_pass_to_function['baseline_correction'],
                                        get_tip_sample_separation = self.corrections_pass_to_function['get_tip_sample_separation'])

                        fd.get_breakthrough_events(sensitivity = sensitivity, start_fraction = start_fraction, event_sep = event_sep)

                        self.breakthrough_events['full_map']['indices'][ind] = fd.breakthrough_events

                        #data_magn[y][x] = fd.breakthrough_event['magnitude']
                        data_exist[y][x] = fd.breakthrough_events['exists']
                        data_counts[y][x] = len(fd.breakthrough_events['events'])
                        #data_mult_noise[y][x] = fd.breakthrough_event['magnitude']/fd.breakthrough_event['noise_level']

                    except:

                        log_file.write('An error occured while processing index ' + str(ind) + '\n')

                    finally:

                        sys.stdout.write('\rFind breakthrough events: %.2f%% <%d/%d>' %(count/self.settings['fd_indices']['total']*100, count,self.settings['fd_indices']['total']))
                        count += 1
                        self.counter['count'] += 1


                self.breakthrough_events['full_map']['parameter'] = {'sensitivity': sensitivity, 'sensitivity_factor': 5 - math.log10(sensitivity), 'event_separation':event_sep}
                self.breakthrough_events['full_map']['units'] = copy.deepcopy(self.units)
                self.breakthrough_events['full_map']['corrections'] = copy.deepcopy(self.corrections_pass_to_function)

                #self.data['breakthrough_events']['magnitude'] = copy.deepcopy(data_magn)
                self.data['breakthrough_events']['exists'] = copy.deepcopy(data_exist)
                self.data['breakthrough_events']['counts'] = copy.deepcopy(data_counts)

                sys.stdout.write(' -- Done!\n')


                # try:
                #
                #     file_pickle_ext = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + '.breakthrough_events.' + timestamp + '.pkl')
                #     out_pkl_ext = open(file_pickle_ext, 'wb')
                #
                #     pickle.dump(data_magn, out_pkl_ext)
                #
                # except:
                #
                #      log_file.write('ERROR! Cannot open/write file ' + file_pickle_ext)
                #
                # finally:
                #
                #      out_pkl_ext.close()


                log_file.close()


        else:

            raise ValueError('ERROR! Set the corrections first!')



# %% secondary data analysis/ data manipulation

    def select_fd_curves_in_aoi(self, select_key = str(), data_key = 'topography', show_selections = True,  gui = False, poly_array = None, **kwargs):

        if not os.path.isdir(self.file_info['save_directory']):
            os.makedirs(self.file_info['save_directory'])

        timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')

        title_key = ''

        if type(data_key) is not list:

            data_key = [data_key]


        data = self.data

        while len(data_key):

            key = data_key.pop(0)
            data = data[key]

            if title_key == '':

                title_key = str(key)

            else:

                title_key = title_key + '-' + str(key)




        #data_plot = self.data[data_key]
        data_plot = data

        if gui:

            plt.ioff()

            fig1 = plt.figure()
            ax1 = fig1.add_subplot(111)
            c1 = ax1.imshow(data_plot,**kwargs)
            cbar1 = fig1.colorbar(c1, ax=ax1)
            cbar1.set_label(data_key, rotation = 270, labelpad = 20)
            ax1.set_xlabel('Position / pixel')
            ax1.set_ylabel('Position / pixel')

            if show_selections:

                for key in self.selections.keys():

                    polygon = plt.Polygon(self.selections[key]['vertices'], closed = True, fill = None)
                    line = ax1.add_line(polygon)
                    line.set_linewidth(1)

                    center = np.mean(self.selections[key]['vertices'], 0)
                    plt.text(center[0], center[1], key, horizontalalignment = 'center')


            polygon = plt.Polygon(poly_array, closed = True, fill = None)
            line = ax1.add_line(polygon)
            line.set_color('blue')
            line.set_linewidth(1)

            polygon_path = polygon.get_path()

            inside = list()
            inside_index = list()

            for y in range(self.settings['grid']['y']):

                for x in range(self.settings['grid']['x']):

                    if polygon_path.contains_point([y,x]):

                        inside.append((y,x))
                        inside_index.append(x * self.settings['grid']['y'] + y)


            if len(select_key) > 0:

                self.selections[select_key] = {'type':'normal', 'root':'N/A', 'fd_index':inside_index, 'grid_index':inside, 'vertices': poly_array}
                ax1.set_title('selection:' + select_key + ' - from:'+ title_key)
                filename = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + '_selection_' + select_key + '_from_'+ title_key + '.' + timestamp + '.png')
                plt.savefig(filename)




            plt.ion()


        else:


            fig1 = plt.figure()
            ax1 = fig1.add_subplot(111)
            c1 = ax1.imshow(data_plot,**kwargs)
            cbar1 = fig1.colorbar(c1, ax=ax1)
            cbar1.set_label(data_key, rotation = 270, labelpad = 20)
            ax1.set_xlabel('Position / pixel')
            ax1.set_ylabel('Position / pixel')
            ax1.set_title('Select area of interest by drawing a polygon:\nLeft klick: Add point, Right klick: Remove last point, Middle klick: Done')

            if show_selections:

                for key in self.selections.keys():

                    polygon = plt.Polygon(self.selections[key]['vertices'], closed = True, fill = None)
                    line = plt.gca().add_line(polygon)
                    line.set_linewidth(1)

                    center = np.mean(self.selections[key]['vertices'], 0)
                    plt.text(center[0], center[1], key, horizontalalignment = 'center')




            poly_points = plt.ginput(-1, show_clicks = True, timeout = 120)

            poly_array = np.array(poly_points)


            polygon = plt.Polygon(poly_array, closed = True, fill = None)
            line = plt.gca().add_line(polygon)
            line.set_color('blue')
            line.set_linewidth(1)

            polygon_path = polygon.get_path()

            inside = list()
            inside_index = list()

            for y in range(self.settings['grid']['y']):

                for x in range(self.settings['grid']['x']):

                    if polygon_path.contains_point([y,x]):

                        inside.append((y,x))
                        inside_index.append(x * self.settings['grid']['y'] + y)


            if len(select_key) > 0:

                self.selections[select_key] = {'type':'normal', 'root':'N/A', 'fd_index':inside_index, 'grid_index':inside, 'vertices': poly_array}
                ax1.set_title('selection:' + select_key + ' - from:'+ title_key)
                filename = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + '_selection_' + select_key + '_from_'+ title_key + '.' + timestamp + '.png')
                plt.savefig(filename)

            else:

                return {'fd_index':inside_index,'grid_index':inside}





    def show_selections(self, data_key = 'topography_mod', **kwargs):

        if type(data_key) is not list:

            data_key = [data_key]

        data = self.data

        while len(data_key):

            key = data_key.pop(0)
            data = data[key]

        data_plot = data

#        if data_key in self.data.keys():
#
#            data_key = data_key
#
#        else:
#
#            data_key = 'topography'
#
#        data_plot = self.data[data_key]


        fig1 = plt.figure()
        ax1 = fig1.add_subplot(111)
        c1 = ax1.imshow(data_plot,**kwargs)
        cbar1 = fig1.colorbar(c1, ax=ax1)
        cbar1.set_label(data_key, rotation = 270, labelpad = 20)
        ax1.set_xlabel('Position / pixel')
        ax1.set_ylabel('Position / pixel')
        ax1.set_title('Original selections of fd-curves')

        for key in self.selections.keys():

            if self.selections[key]['type'] == 'normal':

                polygon = plt.Polygon(self.selections[key]['vertices'], closed = True, fill = None)
                line = plt.gca().add_line(polygon)
                line.set_linewidth(1)

                center = np.mean(self.selections[key]['vertices'], 0)
                plt.text(center[0], center[1], key, horizontalalignment = 'center')
                #an1 = ax1.annotate(key, xy=(center[0], center[1]))
                #an1.draggable()




    def combine_selections(self, selection, select_key_new):

        if type(selection) is not list:

            print('ERROR! Give a list of selections to combine')

        else:

            inside_index_new  = list()
            inside_new = list()
            poly_array_index_new = list()
            select_final = list()

            for select in selection:

                if select in self.selections.keys():

                    inside_index_new = inside_index_new + self.selections[select]['fd_index']
                    inside_new = inside_new + self.selections[select]['grid_index']
                    #poly_array_index_new = np.append(poly_array_index_new,self.selections[select]['vertices'], axis = 0) #does not work cause of list() - wrong shape
                    poly_array_index_new = np.append(poly_array_index_new,self.selections[select]['vertices'])
                    select_final.append(select)

            poly_array_index_new = np.reshape(poly_array_index_new,(int(len(poly_array_index_new)/2),2))

            self.selections[select_key_new] = {'type':'combined', 'root':select_final, 'fd_index':inside_index_new, 'grid_index':inside_new, 'vertices': poly_array_index_new}




    def copy_selection(self, selection, select_key_new):

        if selection not in self.selections.keys():

            print('ERROR! Selection', selection,' not found! Please choose a valid selection')

        else:

            self.selections[select_key_new] = copy.deepcopy(self.selections[selection])
            self.selections[select_key_new]['type'] = 'copied'
            self.selections[select_key_new]['root'] = selection




    def delete_selection(self, selection, remove_analyzed = True):

        if selection not in self.selections.keys():

            print('ERROR! Selection', selection,' not found! Please choose a valid selection')

        else:

            del self.selections[selection]

            if remove_analyzed:

                analyzed_selection = self.hertz_fit['selections'].pop(selection,None)
                analyzed_selection = self.apparent_layer['selections'].pop(selection,None)
                analyzed_selection = self.linearized_hertz_fit['selections'].pop(selection,None)
                analyzed_selection = self.two_layer_hertz['selections'].pop(selection,None)
                analyzed_selection = self.multi_layer_hertz['selections'].pop(selection,None)
                analyzed_selection = self.baseline_tilt['selections'].pop(selection,None)
                analyzed_selection = self.slope_contact['selections'].pop(selection,None)
                analyzed_selection = self.breakthrough_events['selections'].pop(selection,None)


            print('Successfully deleted Selection', selection)





    def invert_selection(self, selection, select_key_new = str()):

        if selection not in self.selections.keys():

            print('ERROR! Selection', selection,' not found! Please choose a valid selection')

        else:

            if select_key_new is '':

                select_key_new = selection + '_invers'

            self.selections[select_key_new] = dict()
            self.selections[select_key_new]['type'] = 'inverted'
            self.selections[select_key_new]['root'] = selection


            polygon = plt.Polygon(self.selections[selection]['vertices'], closed = True, fill = None)
            polygon_path = polygon.get_path()

            inside = list()
            inside_index = list()

            for y in range(self.settings['grid']['y']):

                for x in range(self.settings['grid']['x']):

                    if not polygon_path.contains_point([y,x]):

                        inside.append((y,x))
                        inside_index.append(x * self.settings['grid']['y'] + y)

            self.selections[select_key_new]['fd_index'] = inside_index
            self.selections[select_key_new]['grid_index'] = inside
            self.selections[select_key_new]['vertices'] = copy.deepcopy(self.selections[selection]['vertices'])




    def get_data(self, data_key, selection):

        if selection in self.selections.keys():

            if type(data_key) is not list:

                data_key = [data_key]


            data = self.data

            while len(data_key):

                key = data_key.pop(0)
                data = data[key]


            ret = list()

            for ind in self.selections[selection]['grid_index']:

                ret = np.append(ret, data[ind[1]][ind[0]])


            return ret

        else:

            print('ERROR! Selection', selection,'is not a valid selection.')




    @staticmethod
    def get_data_snapshot(qi_snapshot, data_key, selection):

        if selection in qi_snapshot['selections'].keys():

            if type(data_key) is not list:

                data_key = [data_key]


            data = qi_snapshot['data']

            while len(data_key):

                key = data_key.pop(0)
                data = data[key]


            ret = list()

            for ind in qi_snapshot['selections'][selection]['grid_index']:

                ret = np.append(ret, data[ind[1]][ind[0]])


            return ret

        else:

            print('ERROR! Selection', selection,'is not a valid selection.')





    def plane_fit_topography(self):

        #data_original = copy.deepcopy(self.data['topography'])

        #1. transform data into a list of datapoints

        data_as_list = np.full((self.settings['grid']['x']*self.settings['grid']['y'],3),np.nan)

        for y in range(self.settings['grid']['y']):

            for x in range(self.settings['grid']['x']):

                data_as_list[x+y*self.settings['grid']['y']][0] = x
                data_as_list[x+y*self.settings['grid']['y']][1] = y
                data_as_list[x+y*self.settings['grid']['y']][2] = self.data['topography'][y][x]

        #remove all entries with nans
        data_as_list = data_as_list[~np.isnan(data_as_list[:,2])]

        A = np.c_[data_as_list[:,0],data_as_list[:,1], np.ones(data_as_list.shape[0])]
        C,_,_,_ = scipy.linalg.lstsq(A, data_as_list[:,2])

        data_mod = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)


        for y in range(self.settings['grid']['y']):

            for x in range(self.settings['grid']['x']):

                data_mod[y][x] = self.data['topography'][y][x] - (C[0]*x + C[1]*y + C[2])


        self.data['topography_mod'] = copy.deepcopy(data_mod)

#
#        X,Y = np.meshgrid(np.arange(0,self.settings['grid']['x'],1), np.arange(0,self.settings['grid']['y'],1))
#        #XX = X.flatten()
#        #YY = Y.flatten()
#        Z = C[0]*X + C[1]*Y + C[2]
#
#        fig = plt.figure()
#        ax = fig.gca(projection='3d')
#        ax.plot_surface(X, Y, Z, rstride=1, cstride=1, alpha=0.2)
#        ax.scatter(data_as_list[:,0], data_as_list[:,1], data_as_list[:,2], c='r', s=1)
#        plt.xlabel('X')
#        plt.ylabel('Y')
#        ax.set_zlabel('Z')
#        ax.axis('equal')
#        ax.axis('tight')
        #X,Y = np.meshgrid()


    def flatten(self, order = 1):

        if 'topography_mod' in self.data.keys():

            key = 'topography_mod'

        else:

            key = 'topography'


        x = np.array([i for i in range(self.data[key].shape[1])])

        data_mod = copy.deepcopy(self.data[key])

        for line in range(self.data[key].shape[0]):

            slope, intercept = np.polyfit(x,self.data[key][line],order)

            data_mod[line] = data_mod[line] - intercept - slope * x


        self.data['topography_mod'] = copy.deepcopy(data_mod)








    def plane_fit_topography_contact_point(self):

        #data_original = copy.deepcopy(self.data['topography'])

        #1. transform data into a list of datapoints

        data_as_list = np.full((self.settings['grid']['x']*self.settings['grid']['y'],3),np.nan)

        for y in range(self.settings['grid']['y']):

            for x in range(self.settings['grid']['x']):

                data_as_list[x+y*self.settings['grid']['y']][0] = x
                data_as_list[x+y*self.settings['grid']['y']][1] = y
                data_as_list[x+y*self.settings['grid']['y']][2] = self.data['topography_contact_point'][y][x]

        #remove all entries with nans
        data_as_list = data_as_list[~np.isnan(data_as_list[:,2])]

        A = np.c_[data_as_list[:,0],data_as_list[:,1], np.ones(data_as_list.shape[0])]
        C,_,_,_ = scipy.linalg.lstsq(A, data_as_list[:,2])

        data_mod = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)


        for y in range(self.settings['grid']['y']):

            for x in range(self.settings['grid']['x']):

                data_mod[y][x] = self.data['topography_contact_point'][y][x] - (C[0]*x + C[1]*y + C[2])


        self.data['topography_contact_point_mod'] = copy.deepcopy(data_mod)

#
#        X,Y = np.meshgrid(np.arange(0,self.settings['grid']['x'],1), np.arange(0,self.settings['grid']['y'],1))
#        #XX = X.flatten()
#        #YY = Y.flatten()
#        Z = C[0]*X + C[1]*Y + C[2]
#
#        fig = plt.figure()
#        ax = fig.gca(projection='3d')
#        ax.plot_surface(X, Y, Z, rstride=1, cstride=1, alpha=0.2)
#        ax.scatter(data_as_list[:,0], data_as_list[:,1], data_as_list[:,2], c='r', s=1)
#        plt.xlabel('X')
#        plt.ylabel('Y')
#        ax.set_zlabel('Z')
#        ax.axis('equal')
#        ax.axis('tight')
        #X,Y = np.meshgrid()







    def young_modulus_hertz(self, index = 'all', return_type = 'dict'):

        ret_dict = dict()
        ret_dict_complete = dict()
        ret_list = list()
        ret = None

        # 1. create an index list
        index_list = list()

        if index == 'all':

            index_list = self.settings['fd_indices']['list']


        elif type(index) is list:

            index_list = create_index_list(index)


        elif type(index) is tuple and len(index) == 2:

            index_list = create_index_list([index])


        elif type(index) is int:

            index_list = list(index)

        # 2. remove all indices for which no file is existing
        index_final = list()

        for i in index_list:

            if i in self.settings['fd_indices']['list']:

                index_final.append(i)


        for key in index_final:

            ret_dict[key] = self.hertz_fit[key]['young_modulus']['value']
            ret_dict_complete[key] = self.hertz_fit[key]['young_modulus']
            ret_list.append(self.hertz_fit[key]['young_modulus']['value'])


        if return_type == 'dict':

            ret = ret_dict

        elif return_type == 'list':

            ret = ret_list

        elif return_type == 'dict_complete':

            ret = ret_dict_complete


        return ret




#%% further data manipulation


    def calibrated_cantilever(self, sensitivity, spring_constant):

        if self.control_variables['cantilever_calibrated']:

            sys.stdout.write('Cantilever is already calibrated. Change calibration via set_sensitivity() and set_spring_constant()\n')

        else:

            self.settings['sensitivity'] = sensitivity
            self.settings['spring_constant'] = spring_constant

            self.channel_units[self.keys['x_key']] = 'N'


            self.calibrations['spring_constant_calibrated'] = True
            self.calibrations['sensitivity_calibrated'] = True
            self.calibrations['modified']['sensitivity'] = True
            self.calibrations['modified']['spring_constant'] = True
            self.control_variables['cantilever_calibrated'] = True






    def set_spring_constant(self, value):

        self.calibrations['spring_constant'] = value
        self.calibrations['modified']['spring_constant'] = True

        #do not change adhesion force etc...because tip sample separation stuff has also influence e.g. on the adhesion energy and location of rupture events



    def reset_spring_constant(self):

        self.calibrations['spring_constant'] = self.jpk_qi_data.calibrations['spring_constant']
        self.calibrations['modified']['spring_constant'] = False


    def set_sensitivity(self, value):

        self.calibrations['sensitivity'] = value
        self.calibrations['modified']['sensitivity'] = True



    def reset_sensitivity(self):

        self.calibrations['sensitivity'] = self.jpk_qi_data.calibrations['sensitivity']
        self.calibrations['modified']['sensitivity'] = False



# %% data import stuff   and extract fd-curves

    def _import_jpk_qi_file(self, filepath, x_key):

        self.jpk_qi_data = JPK_QIFile()
        self.jpk_qi_data.open_qi_file(filepath)

        if x_key in self.jpk_qi_data.channels:

            self.channels = [x_key, 'vDeflection']

        else:

            self.channels = [self.get_jpk_x_key(), 'vDeflection']


        for channel in self.channels:

            self.channel_units[channel] = self.jpk_qi_data.channel_units[channel]


        self.set_keys(x_key = x_key)

        self.calibrations = copy.deepcopy(self.jpk_qi_data.calibrations)
        self.settings = copy.deepcopy(self.jpk_qi_data.settings)
        self.file_info['date'] = self.jpk_qi_data.file_info['date']
        self.file_info['time'] = self.jpk_qi_data.file_info['time']
        self.file_info['file_org'] = self.jpk_qi_data.file_info['file_org']

        save_dir = os.path.normpath(self.file_info['filename'][:self.file_info['filename'].rfind(os.path.sep)])
        self.file_info['save_directory'] = os.path.normpath(os.path.join(save_dir, self.file_info['file_org']))


        self.control_variables['file_imported'] = True

        if self.calibrations['spring_constant_calibrated'] and self.calibrations['sensitivity_calibrated']:

            self.control_variables['cantilever_calibrated'] = True


        self.units['distance'] = dict()
        self.units['distance']['unit'] = 'm'
        self.units['distance']['factor'] = 1
        self.units['force'] = dict()
        self.units['force']['unit'] = 'N'
        self.units['force']['factor'] = 1

        self.calibrations['modified'] = dict()
        self.calibrations['modified']['sensitivity'] = False
        self.calibrations['modified']['spring_constant'] = False




    def extract_fd_curve(self, index):

        #head_data = self.jpk_qi_data.contents[self.jpk_qi_data.dict_sort_files['index'][str(index)]['header.properties']].decode().split(self.jpk_qi_data.line_sep)
        #head_data_dict = JPK_QIFile._generate_dict(head_data)

        head_data_dict = self.jpk_qi_data.headers[str(index)]['header.properties']



        fd = ForceDistanceCurve()
        fd.file_info['filename'] = self.file_info['file_org'] + '_' + str(index) + '.extracted-jpk'
        fd.file_info['date'] = self.file_info['date']
        fd.file_info['file_org'] = self.file_info['file_org'] + '_' + str(index)
        fd.file_info['save_directory'] = self.file_info['save_directory']


        fd.calibrations = copy.deepcopy(self.calibrations)
        fd.keys = copy.deepcopy(self.keys)
        #fd.units = copy.deepcopy(self.units)
        fd.units = {'distance': {'unit':'m', 'factor': 1}, 'force': {'unit':'N', 'factor': 1}}

        # self.units['distance'] = dict()
        # self.units['distance']['unit'] = 'm'
        # self.units['distance']['factor'] = 1
        # self.units['force'] = dict()
        # self.units['force']['unit'] = 'N'
        # self.units['force']['factor'] = 1


        fd.settings['duration'] = dict()
        fd.settings['duration']['extend'] = float(head_data_dict['quantitative-imaging-series']['header']['quantitative-imaging-settings']['extend']['duration'])
        fd.settings['duration']['retract'] = float(head_data_dict['quantitative-imaging-series']['header']['quantitative-imaging-settings']['retract']['duration'])

        fd.settings['samples'] = dict()
        #fd.settings['samples']['extend'] = int(head_data_dict['quantitative-imaging-series']['header']['quantitative-imaging-settings']['extend']['num-points'])
        #fd.settings['samples']['retract'] = int(head_data_dict['quantitative-imaging-series']['header']['quantitative-imaging-settings']['retract']['num-points'])

        fd.settings['sample_rate'] = dict()
        #fd.settings['sample_rate']['extend'] = fd.settings['samples']['extend'] / fd.settings['duration']['extend']
        #fd.settings['sample_rate']['retract'] = fd.settings['samples']['retract'] / fd.settings['duration']['retract']

        fd.settings['z_pos'] = dict()
        fd.settings['z_pos']['relative_z_start'] = float(head_data_dict['quantitative-imaging-series']['header']['quantitative-imaging-settings']['extend']['z-start'])
        fd.settings['z_pos']['relative_z_end'] = float(head_data_dict['quantitative-imaging-series']['header']['quantitative-imaging-settings']['extend']['z-end'])

        fd.settings['position'] = dict()
        fd.settings['position']['index'] = int(head_data_dict['quantitative-imaging-series']['header']['position-index'])
        fd.settings['position']['x'] = float(head_data_dict['quantitative-imaging-series']['header']['position']['x'])
        fd.settings['position']['y'] = float(head_data_dict['quantitative-imaging-series']['header']['position']['y'])

        fd.channels = copy.deepcopy(self.channels)
        fd.channel_units = copy.deepcopy(self.channel_units)


        data_decoded = dict()
        channel_conversion = dict()

        for channel in self.channels:

            channel_conversion[channel] = channel


        for seg in self.jpk_qi_data.headers[str(index)]['segments'].keys():

            seg_info_dict = self.jpk_qi_data.headers[str(index)]['segments'][seg]
            # seg is based upon the first fd curves. if it doesn't have a extend then retract will be 0.
            # but later on if there is an extend cycle, the extend data is in the folder "0" and only the header file inside the order specifies which segment it is

            #assign data to correct segment
            segment = self.jpk_qi_data.segment_info[int(seg_info_dict['force-segment-header']['force-segment-header-info']['*'])]

            data_decoded[segment] = dict()
            #data_decoded[self.jpk_qi_data.segment_info[seg_ind]] = dict()

            for channel in self.channels:

                #data_decoded[self.jpk_qi_data.segment_info[seg_ind]][channel_conversion[channel]] = list()
                data_decoded[segment][channel_conversion[channel]] = list()

                # check whether there is a file for that channel
                if self.jpk_qi_data.channels_info[channel]['file']['has_file']:

                    point_length, type_code = DATA_TYPES[self.jpk_qi_data.channels_info[channel]['data_type']]
                    raw_data = self.jpk_qi_data.contents[self.jpk_qi_data.dict_sort_files['index'][str(index)]['segments'][seg]['channels'][channel + '.dat']]

                    #data = np.zeros(fd.settings['samples'][self.jpk_qi_data.segment_info[seg_ind]])
                    data = np.zeros(int(len(raw_data)/point_length)) #number of samples is not reliable

                    for n in range(int(len(raw_data)/point_length)):

                        data[n] = unpack('!'+type_code, raw_data[n * point_length:(n+1) * point_length])[0]

                     # 1. apply encoder
                    if self.jpk_qi_data.channels_info[channel]['encoder']['defined']:

                        data = data * self.jpk_qi_data.channels_info[channel]['encoder']['multiplier'] + self.jpk_qi_data.channels_info[channel]['encoder']['offset']

                     # 2. apply conversions
                    for conv in self.jpk_qi_data.channels_info[channel]['conversions_list']:

                        if self.jpk_qi_data.channels_info[channel]['conversions'][conv]['defined']:

                            data = data * self.jpk_qi_data.channels_info[channel]['conversions'][conv]['multiplier'] + self.jpk_qi_data.channels_info[channel]['conversions'][conv]['offset']

                    data_decoded[segment][channel_conversion[channel]] = data
                    #data_decoded[self.jpk_qi_data.segment_info[seg_ind]][channel_conversion[channel]] = data


        if 'extend' in data_decoded.keys():

            fd.settings['samples']['extend'] = np.size(data_decoded['extend'][self.keys['x_key']])
            fd.settings['sample_rate']['extend'] = fd.settings['samples']['extend'] / fd.settings['duration']['extend']

        if 'retract' in data_decoded.keys():

            fd.settings['samples']['retract'] = np.size(data_decoded['retract'][self.keys['x_key']])
            fd.settings['sample_rate']['retract'] = fd.settings['samples']['retract'] / fd.settings['duration']['retract']


        fd.jpk_force_data = JPK_ForceFile() # one copy.deepcopy is enough
        fd.jpk_force_data.data = data_decoded # one copy.deepcopy is enough
        fd.jpk_force_data.settings = copy.deepcopy(fd.settings)
        fd.jpk_force_data.calibrations = copy.deepcopy(self.jpk_qi_data.calibrations)
        fd.jpk_force_data.channels = copy.deepcopy(self.jpk_qi_data.channels)
        fd.jpk_force_data.channel_units = copy.deepcopy(self.jpk_qi_data.channel_units)

        fd.data = copy.deepcopy(data_decoded)


        if self.calibrations['modified']['sensitivity']:


            fac = self.calibrations['sensitivity'] / self.jpk_qi_data.calibrations['sensitivity']

            for seg in fd.data.keys():

                fd.data[seg][fd.keys['y_key']] = fd.data[seg][fd.keys['y_key']] * fac


        if self.calibrations['modified']['spring_constant']:

            fac = self.calibrations['spring_constant'] / self.jpk_qi_data.calibrations['spring_constant']

            for seg in fd.data.keys():

                fd.data[seg][fd.keys['y_key']] = fd.data[seg][fd.keys['y_key']] * fac

        fd.control_variables['file_imported'] = True
        fd.control_variables['cantilever_calibrated'] = self.control_variables['cantilever_calibrated']

        return fd




    def extract_fd_curve_batch(self, index):

        #head_data = self.jpk_qi_data.contents[self.jpk_qi_data.dict_sort_files['index'][str(index)]['header.properties']].decode().split(self.jpk_qi_data.line_sep)
        #head_data_dict = JPK_QIFile._generate_dict(head_data)
        head_data_dict = self.jpk_qi_data.headers[str(index)]['header.properties']

        fd = ForceDistanceCurve_Batch()
        fd.file_info['filename'] = self.file_info['file_org'] + '_' + str(index) + '.extracted-jpk'
        fd.file_info['date'] = self.file_info['date']
        fd.file_info['file_org'] = self.file_info['file_org'] + '_' + str(index)
        fd.file_info['save_directory'] = self.file_info['save_directory']

        fd.calibrations = self.calibrations
        fd.keys = self.keys
        #fd.units = copy.deepcopy(self.units)
        fd.units = {'distance': {'unit':'m', 'factor': 1}, 'force': {'unit':'N', 'factor': 1}}

        #fd.settings['duration'] = dict()
        #fd.settings['duration']['extend'] = float(head_data_dict['quantitative-imaging-series']['header']['quantitative-imaging-settings']['extend']['duration'])
        #fd.settings['duration']['retract'] = float(head_data_dict['quantitative-imaging-series']['header']['quantitative-imaging-settings']['retract']['duration'])

        fd.settings['samples'] = dict() # number of samples might be smaller than that given in the header file
        #fd.settings['samples']['extend'] = int(head_data_dict['quantitative-imaging-series']['header']['quantitative-imaging-settings']['extend']['num-points'])
        #fd.settings['samples']['retract'] = int(head_data_dict['quantitative-imaging-series']['header']['quantitative-imaging-settings']['retract']['num-points'])

        #fd.settings['samples']['extend'] = int(head_data_dict['quantitative-imaging-series']['header']['quantitative-imaging-settings']['extend']['num-points'])
        #fd.settings['samples']['retract'] = int(head_data_dict['quantitative-imaging-series']['header']['quantitative-imaging-settings']['retract']['num-points'])


        #fd.settings['sample_rate'] = dict()
        #fd.settings['sample_rate']['extend'] = fd.settings['samples']['extend'] / fd.settings['duration']['extend']
        #fd.settings['sample_rate']['retract'] = fd.settings['samples']['retract'] / fd.settings['duration']['retract']

        #fd.settings['z_pos'] = dict()
        #fd.settings['z_pos']['relative_z_start'] = float(head_data_dict['quantitative-imaging-series']['header']['quantitative-imaging-settings']['extend']['z-start'])
        #fd.settings['z_pos']['relative_z_end'] = float(head_data_dict['quantitative-imaging-series']['header']['quantitative-imaging-settings']['extend']['z-end'])

        fd.settings['position'] = dict()
        fd.settings['position']['index'] = int(head_data_dict['quantitative-imaging-series']['header']['position-index'])
        fd.settings['position']['x'] = float(head_data_dict['quantitative-imaging-series']['header']['position']['x'])
        fd.settings['position']['y'] = float(head_data_dict['quantitative-imaging-series']['header']['position']['y'])

        fd.channels = copy.deepcopy(self.channels)
        fd.channel_units = copy.deepcopy(self.channel_units)


        data_decoded = dict()
        channel_conversion = dict()

        for channel in self.channels:

            channel_conversion[channel] = channel


        #for seg_ind in self.jpk_qi_data.dict_sort_files['index'][str(index)]['segments'].keys():

            #if seg_ind in self.jpk_qi_data.segment_info.keys():


        for seg in self.jpk_qi_data.headers[str(index)]['segments'].keys():

            seg_info_dict = self.jpk_qi_data.headers[str(index)]['segments'][seg]
            segment = self.jpk_qi_data.segment_info[int(seg_info_dict['force-segment-header']['force-segment-header-info']['*'])]

            data_decoded[segment] = dict()

            for channel in self.channels:

                data_decoded[segment][channel_conversion[channel]] = list()

                # check whether there is a file for that channel
                if self.jpk_qi_data.channels_info[channel]['file']['has_file']:

                    point_length, type_code = DATA_TYPES[self.jpk_qi_data.channels_info[channel]['data_type']]
                    raw_data = self.jpk_qi_data.contents[self.jpk_qi_data.dict_sort_files['index'][str(index)]['segments'][str(seg)]['channels'][channel + '.dat']]

                    data = np.zeros(int(len(raw_data)/point_length)) #number of samples is not reliable

                    for n in range(int(len(raw_data)/point_length)):

                        data[n] = unpack('!'+type_code, raw_data[n * point_length:(n+1) * point_length])[0]

                     # 1. apply encoder
                    if self.jpk_qi_data.channels_info[channel]['encoder']['defined']:

                        data = data * self.jpk_qi_data.channels_info[channel]['encoder']['multiplier'] + self.jpk_qi_data.channels_info[channel]['encoder']['offset']

                     # 2. apply conversions
                    for conv in self.jpk_qi_data.channels_info[channel]['conversions_list']:

                        if self.jpk_qi_data.channels_info[channel]['conversions'][conv]['defined']:

                            data = data * self.jpk_qi_data.channels_info[channel]['conversions'][conv]['multiplier'] + self.jpk_qi_data.channels_info[channel]['conversions'][conv]['offset']


                    data_decoded[segment][channel_conversion[channel]] = data


        fd.settings['samples']['extend'] = np.size(data_decoded['extend'][self.keys['x_key']])
        fd.settings['samples']['retract'] = np.size(data_decoded['retract'][self.keys['x_key']])
        fd.jpk_force_data = JPK_ForceFile()
        fd.jpk_force_data.calibrations = self.jpk_qi_data.calibrations
        fd.data = data_decoded


        if self.calibrations['modified']['sensitivity']:


            fac = self.calibrations['sensitivity'] / self.jpk_qi_data.calibrations['sensitivity']

            for seg in fd.data.keys():

                fd.data[seg][fd.keys['y_key']] = fd.data[seg][fd.keys['y_key']] * fac


        if self.calibrations['modified']['spring_constant']:

            fac = self.calibrations['spring_constant'] / self.jpk_qi_data.calibrations['spring_constant']

            for seg in fd.data.keys():

                fd.data[seg][fd.keys['y_key']] = fd.data[seg][fd.keys['y_key']] * fac

        fd.control_variables['file_imported'] = True
        fd.control_variables['cantilever_calibrated'] = self.control_variables['cantilever_calibrated']

        return fd




#%% accessing data stuff
    def get_jpk_x_key(self):

        if 'measuredHeight' in self.jpk_qi_data.channels:

            x_key = 'measuredHeight'

        elif 'capacitiveSensorHeight' in self.jpk_qi_data.channels:

            x_key = 'capacitiveSensorHeight'

        elif 'strainGaugeHeight' in self.jpk_qi_data.channels:

            x_key = 'strainGaugeHeight'

        elif 'smoothedMeasuredHeight' in self.jpk_qi_data.channels:

            x_key = 'smoothedMeasuredHeight'

        elif 'head-height' in self.jpk_qi_data.channels:

            x_key = 'head-height'

        elif 'smoothedCapacitiveSensorHeight' in self.jpk_qi_data.channels:

            x_key = 'smoothedCapacitiveSensorHeight'

        elif 'smoothedStrainGaugeHeight' in self.jpk_qi_data.channels:

            x_key = 'smoothedStrainGaugeHeight'

        elif 'height' in self.jpk_qi_data.channels:

            x_key = 'height'

        return x_key


    def get_x_key(self):

        if 'measuredHeight' in self.channels:

            x_key = 'measuredHeight'

        elif 'capacitiveSensorHeight' in self.channels:

            x_key = 'capacitiveSensorHeight'

        elif 'strainGaugeHeight' in self.channels:

            x_key = 'strainGaugeHeight'

        elif 'smoothedMeasuredHeight' in self.channels:

            x_key = 'smoothedMeasuredHeight'

        elif 'head-height' in self.channels:

            x_key = 'head-height'

        elif 'smoothedCapacitiveSensorHeight' in self.channels:

            x_key = 'smoothedCapacitiveSensorHeight'

        elif 'smoothedStrainGaugeHeight' in self.channels:

            x_key = 'smoothedStrainGaugeHeight'

        elif 'height' in self.channels:

            x_key = 'height'

        return x_key




    def get_y_key(self):


        return 'vDeflection'




    def get_ts_key(self):


        return 'separation'




    def get_keys(self):

        return self.keys




    def set_x_key(self, channel = str()):

        if channel == str():

            self.keys['x_key'] = self.get_x_key()

        elif channel in self.channels and channel is not 'vDeflection':

            self.keys['x_key'] = channel

        else:

            self.keys['x_key'] = self.get_x_key()




    def set_keys(self, x_key):

        self.set_x_key(x_key)
        self.keys['y_key'] = 'vDeflection'
        self.keys['ts_key'] = 'separation'



#%% debugging methods


    def fit_two_layer_linearized_hertz_model_debug(self, selection = False,
                            poisson_ratio = 0.5,
                            indenter_characteristics = {'geometry': 'parabolic', 'radius [nm]': 10},
                            transition_sensitivity = 1,
                            filter_correction_fraction = 0.5,
                            **kwargs):

            layer1_parameters = {'start_fit_length': 'automatic',
                                 'savgol_filter_characteristics': {'length': 51, 'order': 1, 'deriv': 0, 'delta': 1.0, 'axis': -1, 'mode': 'interp', 'cval': 0.0},
                                 'r_squared_limit':  0.98,
                                 'residual_sensitivity': 1,
                                 'final_fit_fraction': 0.8,
                                 'with_residuals': True}

            layer2_parameters = {'start_fit_length': 'automatic',
                                 #'savgol_filter_characteristics': {'length': 51, 'order': 1},
                                 'r_squared_limit':  0.98,
                                 'residual_sensitivity': 1,
                                 'final_fit_fraction': 0.9,
                                 'with_residuals': True,
                                 'fit_limit': 0.8}


            if 'layer1_parameters' in kwargs:

                for key in kwargs['layer1_parameters'].keys():

                    layer1_parameters[key] = kwargs['layer1_parameters'][key]


            if 'layer2_parameters' in kwargs:

                for key in kwargs['layer2_parameters'].keys():

                    layer2_parameters[key] = kwargs['layer2_parameters'][key]

            if 'layer1_parameters' in kwargs: del kwargs['layer1_parameters']
            if 'layer2_parameters' in kwargs: del kwargs['layer2_parameters']

            residual_fac_layer1 = 5 - math.log10(layer1_parameters['residual_sensitivity'])
            residual_fac_layer2 = 5 - math.log10(layer2_parameters['residual_sensitivity'])
            transition_fac = 5 - math.log10(transition_sensitivity)

            kwargs.pop('layer1_parameters',None)
            kwargs.pop('layer2_parameters',None)

            if self.control_variables['allow_analysis']:

                if bool(selection) and selection in self.selections.keys():

                    self.two_layer_hertz['selections'][selection] = dict()

                    self.two_layer_hertz['selections'][selection]['indenter'] = indenter_characteristics

                    self.two_layer_hertz['selections'][selection]['method'] = dict()
                    self.two_layer_hertz['selections'][selection]['method']['type'] = 'linear'

                    self.two_layer_hertz['selections'][selection]['method']['parameter'] = dict()
                    self.two_layer_hertz['selections'][selection]['method']['parameter']['transition_sensitivity'] = transition_sensitivity
                    self.two_layer_hertz['selections'][selection]['method']['parameter']['transition_factor'] = transition_fac

                    self.two_layer_hertz['selections'][selection]['method']['parameter']['layer1'] = dict()
                    self.two_layer_hertz['selections'][selection]['method']['parameter']['layer1']['r_squared_limit'] = layer1_parameters['r_squared_limit']
                    self.two_layer_hertz['selections'][selection]['method']['parameter']['layer1']['with_residuals'] = layer1_parameters['with_residuals']
                    self.two_layer_hertz['selections'][selection]['method']['parameter']['layer1']['residual_sensitivity'] = layer1_parameters['residual_sensitivity']
                    self.two_layer_hertz['selections'][selection]['method']['parameter']['layer1']['residual_factor'] = residual_fac_layer1
                    self.two_layer_hertz['selections'][selection]['method']['parameter']['layer1']['final_fit_fraction'] = layer1_parameters['final_fit_fraction']

                    self.two_layer_hertz['selections'][selection]['method']['parameter']['layer2'] = dict()
                    self.two_layer_hertz['selections'][selection]['method']['parameter']['layer2']['r_squared_limit'] = layer2_parameters['r_squared_limit']
                    self.two_layer_hertz['selections'][selection]['method']['parameter']['layer2']['with_residuals'] = layer2_parameters['with_residuals']
                    self.two_layer_hertz['selections'][selection]['method']['parameter']['layer2']['residual_sensitivity'] = layer2_parameters['residual_sensitivity']
                    self.two_layer_hertz['selections'][selection]['method']['parameter']['layer2']['residual_factor'] = residual_fac_layer2
                    self.two_layer_hertz['selections'][selection]['method']['parameter']['layer2']['final_fit_fraction'] = layer2_parameters['final_fit_fraction']


                    self.two_layer_hertz['selections'][selection]['filter'] = dict()
                    self.two_layer_hertz['selections'][selection]['filter']['layer1'] = dict()
                    self.two_layer_hertz['selections'][selection]['filter']['layer1']['type'] = 'savitzky-golay'
                    self.two_layer_hertz['selections'][selection]['filter']['layer1']['parameter'] = dict()
                    self.two_layer_hertz['selections'][selection]['filter']['layer1']['parameter']['length'] = layer1_parameters['savgol_filter_characteristics']['length']
                    self.two_layer_hertz['selections'][selection]['filter']['layer1']['parameter']['order'] = layer1_parameters['savgol_filter_characteristics']['order']



                    timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                    sys.stdout.write('\rFitting Two-Layer Linearized Hertz model: %.2f%% <%d/%d>' %(0, 0, len(self.selections[selection]['fd_index'])))
                    log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_two_layer_linearized_hertz.' + timestamp +'.txt'), 'w')

                    #if not os.path.isdir(os.path.join(self.file_info['save_directory'], 'two_layer_linearized_hertz')):

                    #    os.makedirs(os.path.join(self.file_info['save_directory'], 'two_layer_linearized_hertz'))



                    count = 1

                    self.two_layer_hertz['selections'][selection]['indices'] = dict()

                    for ind in self.selections[selection]['fd_index']:

                        #y = int(ind / self.settings['grid']['y'])
                        #x = (ind) % self.settings['grid']['x']

                        self.two_layer_hertz['selections'][selection][ind] = dict()

                        try:

                            fd = self.extract_fd_curve_batch(ind)

                            fd.set_save_directory(self.file_info['save_directory'])
                                 # 3. correct data
                            fd.correct_data(force_unit = self.corrections_pass_to_function['force_unit'],
                                            distance_unit = self.corrections_pass_to_function['distance_unit'],
                                            noise_lvl = self.corrections_pass_to_function['noise_lvl'],
                                            distance_correction = self.corrections_pass_to_function['distance_correction'],
                                            baseline_correction = self.corrections_pass_to_function['baseline_correction'],
                                            get_tip_sample_separation = self.corrections_pass_to_function['get_tip_sample_separation'])

                            fd.fit_two_layer_linearized_hertz_model(
                                                            poisson_ratio = poisson_ratio,
                                                            indenter_characteristics = indenter_characteristics,
                                                            transition_sensitivity = transition_sensitivity,
                                                            filter_correction_fraction = filter_correction_fraction,
                                                            layer1_parameters = layer1_parameters,
                                                            layer2_parameters = layer2_parameters,
                                                            **kwargs)



                            self.two_layer_hertz['selections'][selection]['indices'][ind]['young_modulus'] = fd.two_layer_hertz['young_modulus']

                            self.two_layer_hertz['selections'][selection]['indices'][ind]['best_fit'] = fd.two_layer_hertz['best_fit']
                            self.two_layer_hertz['selections'][selection]['indices'][ind]['residuals'] = fd.two_layer_hertz['residuals']

                            self.two_layer_hertz['selections'][selection]['indices'][ind]['except'] = False

                        except:

                            self.two_layer_hertz['selections'][selection]['indices'][ind]['except'] = True
                            log_file.write('An error occured while processing index ' + str(ind) + '\n')


                        finally:

                                 #self.youngs_modulus[ind] = copy.deepcopy(ret_dict_complete[ind])
                            sys.stdout.write('\rFitting Hertz model: %.2f%% <%d/%d>' %(count/len(self.selections[selection]['fd_index'])*100, count,len(self.selections[selection]['fd_index'])))
                            count += 1

                    self.two_layer_hertz['selections'][selection]['poisson_ratio'] = poisson_ratio


                    self.two_layer_hertz['selections'][selection]['units'] = copy.deepcopy(self.units)
                    self.two_layer_hertz['selections'][selection]['e_modul_unit'] = 'Pa'
                    self.two_layer_hertz['selections'][selection]['e_modul_factor'] = 1
                    self.two_layer_hertz['selections'][selection]['corrections'] = copy.deepcopy(self.corrections)

                    sys.stdout.write(' -- Done!\n')


                    try:

                        file_pickle = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + '.two_layer_linearized_hertz.'+ selection+ '.'+ timestamp + '.pkl')
                        out_pkl = open(file_pickle, 'wb')
                        pickle.dump(self.two_layer_hertz['selections'][selection], out_pkl)

                    except:

                        log_file.write('ERROR! Cannot open/write file ' + file_pickle)

                    finally:

                        out_pkl.close()

                    log_file.close()


                elif bool(selection) and selection not in self.selections.keys():

                    print('ERROR! Choose a correct selection.')


                else:

                    self.two_layer_hertz['full_map']= dict()

                    self.two_layer_hertz['full_map']['indenter'] = indenter_characteristics

                    self.two_layer_hertz['full_map']['method'] = dict()
                    self.two_layer_hertz['full_map']['method']['type'] = 'linear'

                    self.two_layer_hertz['full_map']['method']['parameter'] = dict()
                    self.two_layer_hertz['full_map']['method']['parameter']['transition_sensitivity'] = transition_sensitivity
                    self.two_layer_hertz['full_map']['method']['parameter']['transition_factor'] = transition_fac

                    self.two_layer_hertz['full_map']['method']['parameter']['layer1'] = dict()
                    self.two_layer_hertz['full_map']['method']['parameter']['layer1']['r_squared_limit'] = layer1_parameters['r_squared_limit']
                    self.two_layer_hertz['full_map']['method']['parameter']['layer1']['with_residuals'] = layer1_parameters['with_residuals']
                    self.two_layer_hertz['full_map']['method']['parameter']['layer1']['residual_sensitivity'] = layer1_parameters['residual_sensitivity']
                    self.two_layer_hertz['full_map']['method']['parameter']['layer1']['residual_factor'] = residual_fac_layer1
                    self.two_layer_hertz['full_map']['method']['parameter']['layer1']['final_fit_fraction'] = layer1_parameters['final_fit_fraction']

                    self.two_layer_hertz['full_map']['method']['parameter']['layer2'] = dict()
                    self.two_layer_hertz['full_map']['method']['parameter']['layer2']['r_squared_limit'] = layer2_parameters['r_squared_limit']
                    self.two_layer_hertz['full_map']['method']['parameter']['layer2']['with_residuals'] = layer2_parameters['with_residuals']
                    self.two_layer_hertz['full_map']['method']['parameter']['layer2']['residual_sensitivity'] = layer2_parameters['residual_sensitivity']
                    self.two_layer_hertz['full_map']['method']['parameter']['layer2']['residual_factor'] = residual_fac_layer2
                    self.two_layer_hertz['full_map']['method']['parameter']['layer2']['final_fit_fraction'] = layer2_parameters['final_fit_fraction']


                    self.two_layer_hertz['full_map']['filter'] = dict()
                    self.two_layer_hertz['full_map']['filter']['layer1'] = dict()
                    self.two_layer_hertz['full_map']['filter']['layer1']['type'] = 'savitzky-golay'
                    self.two_layer_hertz['full_map']['filter']['layer1']['parameter'] = dict()
                    self.two_layer_hertz['full_map']['filter']['layer1']['parameter']['length'] = layer1_parameters['savgol_filter_characteristics']['length']
                    self.two_layer_hertz['full_map']['filter']['layer1']['parameter']['order'] = layer1_parameters['savgol_filter_characteristics']['order']



                    timestamp = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
                    sys.stdout.write('\rFitting Two-Layer Linearized Hertz model: %.2f%% <%d/%d>' %(0, 0, self.settings['fd_indices']['total']))
                    log_file = open(os.path.join(self.file_info['save_directory'], '.error_log_two_layer_linearized_hertz.' + timestamp +'.txt'), 'w')

                    #if not os.path.isdir(os.path.join(self.file_info['save_directory'], 'two_layer_linearized_hertz')):

                    #    os.makedirs(os.path.join(self.file_info['save_directory'], 'two_layer_linearized_hertz'))



                    count = 1
                    #data = np.zeros((self.settings['grid']['y'], self.settings['grid']['x']))
                    #data_error = np.zeros((self.settings['grid']['y'], self.settings['grid']['x']))
                    #data_fit_length_index = np.zeros((self.settings['grid']['y'], self.settings['grid']['x']))
                    #data_fit_length_interval = np.zeros((self.settings['grid']['y'], self.settings['grid']['x']))
                    #data_soft_layer_thickness = np.zeros((self.settings['grid']['y'], self.settings['grid']['x']))

                    data_layer1 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                    data_layer2 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                    data_error_layer1 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                    data_error_layer2 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                    data_fit_length_index_layer1 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                    data_fit_length_index_layer2 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                    data_fit_length_interval_layer1 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                    data_fit_length_interval_layer2 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)
                    data_apparent_layer_thickness_layer1 = np.full((self.settings['grid']['y'], self.settings['grid']['x']), np.nan)

                    self.two_layer_hertz['full_map']['indices'] = dict()

                    for ind in self.settings['fd_indices']['list']:

                        y = int(ind / self.settings['grid']['y'])
                        x = (ind) % self.settings['grid']['x']

                        self.two_layer_hertz['full_map']['indices'][ind] = dict()

                        #try:

                        fd = self.extract_fd_curve_batch(ind)

                        fd.set_save_directory(self.file_info['save_directory'])
                             # 3. correct data
                        fd.correct_data(force_unit = self.corrections_pass_to_function['force_unit'],
                                        distance_unit = self.corrections_pass_to_function['distance_unit'],
                                        noise_lvl = self.corrections_pass_to_function['noise_lvl'],
                                        distance_correction = self.corrections_pass_to_function['distance_correction'],
                                        baseline_correction = self.corrections_pass_to_function['baseline_correction'],
                                        get_tip_sample_separation = self.corrections_pass_to_function['get_tip_sample_separation'])

                        fd.fit_two_layer_linearized_hertz_model(
                                                        poisson_ratio = poisson_ratio,
                                                        indenter_characteristics = indenter_characteristics,
                                                        transition_sensitivity = transition_sensitivity,
                                                        filter_correction_fraction = filter_correction_fraction,
                                                        layer1_parameters = layer1_parameters,
                                                        layer2_parameters = layer2_parameters,
                                                        **kwargs)




                        self.two_layer_hertz['full_map']['indices'][ind]['young_modulus'] = fd.two_layer_hertz['young_modulus']

                        self.two_layer_hertz['full_map']['indices'][ind]['best_fit'] = fd.two_layer_hertz['best_fit']
                        self.two_layer_hertz['full_map']['indices'][ind]['residuals'] = fd.two_layer_hertz['residuals']

                        if fd.two_layer_hertz['best_fit']['layer1']['line_found']:

                            data_layer1[y][x] = fd.two_layer_hertz['young_modulus']['layer1']['value']
                            data_error_layer1[y][x] = fd.two_layer_hertz['residuals']['layer1']['mean_linear_fit']
                            data_fit_length_interval_layer1[y][x] = fd.two_layer_hertz['best_fit']['layer1']['interval'][0] - fd.two_layer_hertz['best_fit']['layer1']['interval'][1]
                            data_fit_length_index_layer1[y][x] = fd.two_layer_hertz['best_fit']['layer1']['index'][1] - fd.two_layer_hertz['best_fit']['layer1']['index'][0]
                            data_apparent_layer_thickness_layer1[y][x] = fd.two_layer_hertz['best_fit']['layer1']['contact_point']['value'] - fd.two_layer_hertz['best_fit']['layer1']['interval'][1]


                        if fd.two_layer_hertz['best_fit']['layer2']['line_found']:

                            data_layer2[y][x] = fd.two_layer_hertz['young_modulus']['layer2']['value']
                            data_error_layer2[y][x] = fd.two_layer_hertz['residuals']['layer2']['mean_linear_fit']
                            data_fit_length_interval_layer2[y][x] = fd.two_layer_hertz['best_fit']['layer2']['interval'][0] - fd.two_layer_hertz['best_fit']['layer2']['interval'][1]
                            data_fit_length_index_layer2[y][x] = fd.two_layer_hertz['best_fit']['layer2']['index'][1] - fd.two_layer_hertz['best_fit']['layer2']['index'][0]



                        self.two_layer_hertz['full_map']['indices'][ind]['except'] = False

                        #except:

                        #    self.two_layer_hertz['full_map']['indices'][ind]['except'] = True
                        #    log_file.write('An error occured while processing index ' + str(ind) + '\n')

                        #finally:

                                 #self.youngs_modulus[ind] = copy.deepcopy(ret_dict_complete[ind])
                        sys.stdout.write('\rFitting Two-Layer Linearized Hertz model: %.2f%% <%d/%d>' %(count/self.settings['fd_indices']['total']*100, count,self.settings['fd_indices']['total']))
                        count += 1

                    self.data['linearized_hertz_fit_two_layer'] = dict()
                    self.data['linearized_hertz_fit_two_layer']['layer1'] = dict()
                    self.data['linearized_hertz_fit_two_layer']['layer1']['value'] = copy.deepcopy(data_layer1)
                    self.data['linearized_hertz_fit_two_layer']['layer1']['error'] = copy.deepcopy(data_error_layer1)
                    self.data['linearized_hertz_fit_two_layer']['layer1']['fit_length_interval'] = copy.deepcopy(data_fit_length_interval_layer1)
                    self.data['linearized_hertz_fit_two_layer']['layer1']['fit_length_datapoints'] = copy.deepcopy(data_fit_length_index_layer1)
                    self.data['linearized_hertz_fit_two_layer']['layer1']['apparent_layer_thickness'] = copy.deepcopy(data_apparent_layer_thickness_layer1)

                    self.data['linearized_hertz_fit_two_layer']['layer2'] = dict()
                    self.data['linearized_hertz_fit_two_layer']['layer2']['value'] = copy.deepcopy(data_layer2)
                    self.data['linearized_hertz_fit_two_layer']['layer2']['error'] = copy.deepcopy(data_error_layer2)
                    self.data['linearized_hertz_fit_two_layer']['layer2']['fit_length_interval'] = copy.deepcopy(data_fit_length_interval_layer2)
                    self.data['linearized_hertz_fit_two_layer']['layer2']['fit_length_datapoints'] = copy.deepcopy(data_fit_length_index_layer2)





                    self.two_layer_hertz['full_map']['poisson_ratio'] = poisson_ratio
                    self.two_layer_hertz['full_map']['units'] = copy.deepcopy(self.units)
                    self.two_layer_hertz['full_map']['e_modul_unit'] = 'Pa'
                    self.two_layer_hertz['full_map']['e_modul_factor'] = 1
                    self.two_layer_hertz['full_map']['corrections'] = copy.deepcopy(self.corrections)
                    self.two_layer_hertz['full_map']['analyzed'] = True
                    self.two_layer_hertz['full_map']['successfully_analyzed'] = dict()
                    self.two_layer_hertz['full_map']['successfully_analyzed']['layer1'] = np.sum(~np.isnan(np.reshape(data_layer1,-1)))
                    self.two_layer_hertz['full_map']['successfully_analyzed']['layer2'] = np.sum(~np.isnan(np.reshape(data_layer2,-1)))
                    self.two_layer_hertz['full_map']['successfully_analyzed_percent'] = dict()
                    self.two_layer_hertz['full_map']['successfully_analyzed_percent']['layer1'] = 100 * self.two_layer_hertz['full_map']['successfully_analyzed']['layer1']/np.reshape(data_layer1,-1).size
                    self.two_layer_hertz['full_map']['successfully_analyzed_percent']['layer2'] = 100 * self.two_layer_hertz['full_map']['successfully_analyzed']['layer2']/np.reshape(data_layer2,-1).size

                    sys.stdout.write(' -- Done!\n')


                    try:

                        file_pickle = os.path.join(self.file_info['save_directory'], self.file_info['file_org'] + '.two_layer_linearized_hertz.' + timestamp + '.pkl')
                        out_pkl = open(file_pickle, 'wb')
                        pickle.dump(self.two_layer_hertz['full_map'], out_pkl)

                    except:

                        log_file.write('ERROR! Cannot open/write file ' + file_pickle)

                    finally:

                        out_pkl.close()

                    log_file.close()


            else:

                raise ValueError('ERROR! Set the corrections first!')




class ForceDistanceCurve():

    def __init__(self):

        self.file_info = dict()
        self.file_info['save_directory'] = os.getcwd()

        self.jpk_force_data = None
        self.data = dict()

        self.channels = list()
        self.channel_units = dict()

        self.settings = dict()

        self.calibrations = dict()


        self.keys = dict()

        self.corrections = dict()

        self.units = dict()


        self.noise_level = dict()
        self.max_adhesion_force = dict()
        self.adhesion_energy = dict()
        self.snap_in = dict()
        self.rupture_length = dict()
        self.adhesion_signatures = dict()
        self.breakthrough_events = dict()
        self.hertz_fit = dict()
        self.linearized_hertz_fit = dict()
        self.two_layer_hertz = dict()
        self.multi_layer_hertz = dict()


        self.control_variables = dict()
        self.control_variables['file_imported'] = False
        self.control_variables['cantilever_calibrated'] = False
        self.control_variables['baseline_corrected'] = False
        self.control_variables['distance_corrected'] = False
        self.control_variables['tip_sample_separation_correction_performed'] = False
        self.control_variables['allow_analysis'] = False



#%%
    def import_data(self, filepath = str(), x_key = str()):

        if len(filepath) == 0:

            filepath = self.file_info['filename']

        if os.path.isfile(filepath):

            if filepath[filepath.rfind('.'):] == '.jpk-force' or filepath[filepath.rfind('.'):] == '.jpk-qi-series':

                self.file_info['filename'] = filepath
                self.import_data_jpk_force(filepath, x_key)

            else:

                raise TypeError('ERROR! Given file is not a jpk-force/jpk-qi-series file!')


        else:

            raise ValueError('ERROR! Given filepath or filename is incorrect!')




    def correct_data(self, **kwargs):

        if self.control_variables['file_imported']:

            if not self.control_variables['cantilever_calibrated']:

                sys.stdout.write('WARNING! Cantilever was not calibrated. Calibrate cantilever first!')

            else:

                reference = ['extend', 'retract', 'mean', 'individual']


                if 'force_unit' in kwargs and kwargs['force_unit'] in ['N', 'nN', 'pN']:
                    self.set_force_unit(kwargs['force_unit'])
                elif 'force_unit' in kwargs and kwargs['force_unit']:
                    self.set_force_unit()
                elif 'force_unit' not in kwargs:
                    self.set_force_unit()



                if 'distance_unit' in kwargs and kwargs['distance_unit'] in ['m', 'um', 'nm']:
                    self.set_distance_unit(kwargs['distance_unit'])
                elif 'distance_unit' in kwargs and kwargs['distance_unit']:
                    self.set_distance_unit()
                elif 'distance_unit' not in kwargs:
                    self.set_distance_unit()


                if 'noise_lvl' in kwargs:
                    if 'method' in kwargs['noise_lvl']:
                        if kwargs['noise_lvl']['method'] in ['std_dev', 'linear']:
                            meth = kwargs['noise_lvl']['method']
                        else:
                            meth = 'std_dev'
                    else:
                        meth = 'std_dev'
                    if 'frac_data' in kwargs['noise_lvl']:
                        if type(kwargs['noise_lvl']['frac_data']) is float:
                            frac = kwargs['noise_lvl']['frac_data']
                        else:
                            frac = 0.5
                    else:
                        frac = 0.5
                    dict_noise = {'frac_data': frac, 'method': meth}
                    self.get_noise_level(frac_data = frac, method = meth)
                else:
                    dict_noise = {'frac_data': 0.5, 'method': 'std_dev'}
                    self.get_noise_level(frac_data = 0.5, method = 'std_dev')




                if 'baseline_correction' in kwargs: # baseline stuff

                    pos_method = ['constant', 'linear', 'quadratic']

                    if type(kwargs['baseline_correction']) is bool and kwargs['baseline_correction']:

                        ret_base_corr = self.baseline_correction('constant')

                    elif type(kwargs['baseline_correction']) is bool and not kwargs['baseline_correction']:

                        ret_base_corr = False

                    elif type(kwargs['baseline_correction']) is str:# and len(kwargs['baseline']) == 1:

                        if kwargs['baseline_correction'] in pos_method:

                            ret_base_corr = self.baseline_correction(kwargs['baseline_correction'])

                        else:

                            ret_base_corr = self.baseline_correction('linear')

                    elif type(kwargs['baseline_correction']) is dict:

                        if  'method' in kwargs['baseline_correction'].keys() and kwargs['baseline_correction']['method'] in pos_method:

                            met = kwargs['baseline_correction']['method']

                        else:

                            met = 'linear'


                        if 'reference' in kwargs['baseline_correction'].keys() and kwargs['baseline_correction']['reference'] in reference:

                            ref = kwargs['baseline_correction']['reference']

                        else:

                            ref = 'individual'


                        if 'frac_data' in kwargs['baseline_correction'].keys():

                            frac_data = kwargs['baseline_correction']['frac_data']

                        else:

                            frac_data = (0,0.5)


                        ret_base_corr = self.baseline_correction(met, ref, frac_data)


                    else:

                        ret_base_corr = self.baseline_correction('constant')

                else:

                    ret_base_corr = self.baseline_correction('constant')



                if 'distance_correction' in kwargs:

                    corr_type = ['constant', 'zero_force', 'fit']
                    #start_type = ['contact', 'distance']

                    if type(kwargs['distance_correction']) is bool and kwargs['distance_correction']:

                        ret_diff_corr = self.distance_correction()


                    elif type(kwargs['distance_correction']) is str:

                        if kwargs['distance_correction'] in corr_type:

                            ret_diff_corr = self.distance_correction(kwargs['distance_correction'])

                        else:

                            ret_diff_corr = self.distance_correction()


                    elif type(kwargs['distance_correction']) is dict:

                        if 'method' in kwargs['distance_correction'].keys() and kwargs['distance_correction']['method'] in corr_type:

                            met = kwargs['distance_correction']['method']

                        else:

                            met = 'zero_force'


                        if 'reference' in kwargs['distance_correction'].keys() and kwargs['distance_correction']['reference'] in reference:

                            ref = kwargs['distance_correction']['reference']

                        else:

                            ref = 'extend'


                        if met == 'constant':

                            ret_diff_corr = self.distance_correction(corr_type = 'constant', reference = ref)


                        elif met == 'zero_force':

                            if 'smooth_applied' in kwargs['distance_correction'].keys() and type(kwargs['distance_correction']['smooth_applied']) is bool:

                                smooth = kwargs['distance_correction']['smooth_applied']

                            else:

                                smooth = False


                            if 'smooth_length' in kwargs['distance_correction'].keys() and kwargs['distance_correction']['smooth_length'] is int:

                                smooth_length = kwargs['distance_correction']['smooth_length']

                            else:

                                smooth_length = 51


                            ret_diff_corr = self.distance_correction(corr_type = 'zero_force', reference = ref, smooth_applied = smooth, smooth_length = smooth_length)


                        elif met == 'fit':


                            if 'length_fit' in kwargs['distance_correction'].keys() and kwargs['distance_correction']['length_fit'] is int:

                                length_fit = kwargs['distance_correction']['length_fit']

                            else:

                                length_fit = 20


                            ret_diff_corr = self.distance_correction(corr_type = 'fit', reference = ref, length_fit = length_fit)



                    elif type(kwargs['distance_correction']) is bool and not kwargs['distance_correction']:

                       ret_diff_corr = False

                else:

                    ret_diff_corr = self.distance_correction()



                if 'get_tip_sample_separation' in kwargs:

                    if kwargs['get_tip_sample_separation']: # if that is true

                        self.get_tip_sample_separation()

                        ret_ts_sep = True

                    else:

                        ret_ts_sep = False

                elif 'get_tip_sample_separation' not in kwargs:

                    self.get_tip_sample_separation()
                    ret_ts_sep = True


                self.get_noise_level(frac_data = dict_noise['frac_data'], method = dict_noise['method'])

                self.corrections = {'force_unit': self.units['force']['unit'], 'distance_unit': self.units['distance']['unit'],'noise_lvl': dict_noise ,'baseline_correction': ret_base_corr, 'distance_correction': ret_diff_corr, 'get_tip_sample_separation': ret_ts_sep}

        else:

            raise ValueError('ERROR! Import file first!')





#%% data import stuff
    def import_data_jpk_force(self, filepath, x_key):

        if not self.control_variables['file_imported']:

            self.jpk_force_data = JPK_ForceFile()
            self.jpk_force_data.open_force_file(filepath)

            if x_key in self.jpk_force_data.channels:

                self.channels = [x_key, 'vDeflection']

            else:

                self.channels = [self.get_jpk_x_key(), 'vDeflection']


            for channel in self.channels:

                self.channel_units[channel] = self.jpk_force_data.channel_units[channel]


            self.set_keys(x_key = x_key)

            self.calibrations = copy.deepcopy(self.jpk_force_data.calibrations)
            self.settings = copy.deepcopy(self.jpk_force_data.settings)
            self.file_info['date'] =self.jpk_force_data.file_info['date']
            self.file_info['time'] =self.jpk_force_data.file_info['time']
            self.file_info['file_org'] =self.jpk_force_data.file_info['file_org']


            for seg in self.jpk_force_data.data.keys():

                self.data[seg] = dict()

                for channel in self.channels:

                    self.data[seg][channel] = copy.deepcopy(self.jpk_force_data.data[seg][channel])



            self.control_variables['file_imported'] = True

            if self.calibrations['spring_constant'] and self.calibrations['spring_constant']:

                self.control_variables['cantilever_calibrated'] = True

            else:

                self.control_variables['cantilever_calibrated'] = False



            self.units['distance'] = dict()
            self.units['distance']['unit'] = 'm'
            self.units['distance']['factor'] = 1
            self.units['force'] = dict()
            self.units['force']['unit'] = 'N'
            self.units['force']['factor'] = 1

        else:

            raise ValueError('ERROR! Import file first!')




#%% data correction stuff
    def set_force_unit(self, magn = 'nN'):

        if self.control_variables['file_imported']:

            if magn in ['N', 'nN', 'pN']:

                if magn == 'N':

                    fac = 1

                elif magn == 'nN':

                    fac = 10**-9

                elif magn == 'pN':

                    fac = 10**-12


                change_magn = self.units['force']['factor'] / fac

                self.units['force']['unit'] = magn
                self.units['force']['factor'] = self.units['force']['factor'] / change_magn

                for seg in self.data.keys():

                    self.data[seg][self.keys['y_key']] = self.data[seg][self.keys['y_key']] * change_magn


                self.channel_units[self.keys['y_key']] = magn

            else:

                raise ValueError('ERROR! Given str is not a valid magnitude!')

        else:

            raise ValueError('ERROR! Import file first!')




    def set_distance_unit(self, magn = 'nm'):

        if self.control_variables['file_imported']:

            if magn in ['m', 'um', 'nm']:

                if magn == 'm':

                    fac = 1

                elif magn == 'um':

                    fac = 10**-6

                elif magn == 'nm':

                    fac = 10**-9


                change_magn = self.units['distance']['factor'] / fac

                self.units['distance']['unit'] = magn
                self.units['distance']['factor'] = self.units['distance']['factor'] / change_magn

                for seg in self.data.keys():

                    for channel in self.data[seg].keys():

                        if channel in JPK_ForceFile._distance_channel:

                            self.data[seg][channel] = self.data[seg][channel] * change_magn
                            self.channel_units[channel] = magn

            else:

                raise ValueError('ERROR! Given str is not a valid magnitude!')
        else:

            raise ValueError('ERROR! Import file first!')




    def get_noise_level(self, frac_data = 0.5, method = 'std_dev'):


        if self.control_variables['file_imported']:

            if method == 'std_dev':

                stddev_ext = np.std(self.data['extend'][self.keys['y_key']][0:int(self.settings['samples']['extend'] * frac_data)])
                stddev_ret = np.std(self.data['retract'][self.keys['y_key']][-int(self.settings['samples']['retract'] * frac_data):-1])

                self.noise_level['value'] = max([stddev_ext, stddev_ret])
                self.noise_level['unit'] = copy.deepcopy(self.units['force']['unit'])
                self.noise_level['factor'] = copy.deepcopy(self.units['force']['factor'])
                self.noise_level['method'] = 'std_dev'
                self.noise_level['extend'] = stddev_ext
                self.noise_level['retract'] = stddev_ret

            elif method == 'linear':

                linear_ext = np.mean(np.absolute(self.data['extend'][self.keys['y_key']][0:int(self.settings['samples']['extend'] * frac_data)]) - np.mean(self.data['extend'][self.keys['y_key']][0:int(self.settings['samples']['extend'] * frac_data)]))
                linear_ret = np.mean(np.absolute(self.data['retract'][self.keys['y_key']][-int(self.settings['samples']['retract'] * frac_data):-1]) - np.mean(self.data['retract'][self.keys['y_key']][-int(self.settings['samples']['retract'] * frac_data):-1]))

                self.noise_level['value'] = max([linear_ext, linear_ret])
                self.noise_level['unit'] = copy.deepcopy(self.units['force']['unit'])
                self.noise_level['factor'] = copy.deepcopy(self.units['force']['factor'])
                self.noise_level['method'] = 'linear'
                self.noise_level['extend'] = stddev_ext
                self.noise_level['retract'] = stddev_ret


        else:

            raise ValueError('ERROR! Import file first!')




    def baseline_correction(self, method = 'linear', reference = 'individual', frac_data = (0,0.5)):

        ret_dict = dict()

        if method == 'constant':

            corr_ext = np.mean(self.data['extend'][self.keys['y_key']][int((self.settings['samples']['extend']-1) * frac_data[0]):int((self.settings['samples']['extend']-1) * frac_data[1])])
            corr_ret = np.mean(self.data['retract'][self.keys['y_key']][-int(self.settings['samples']['retract'] * frac_data[1])-1:-int(self.settings['samples']['extend'] * frac_data[0])-1])

            ret_dict['parameter'] = {'corr_ext': corr_ext, 'corr_ret': corr_ret}

            if reference == 'individual':

                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - corr_ext
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - corr_ret

            elif reference == 'mean':

                corr_mean = 0.5 * (corr_ext + corr_ret)

                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - corr_mean
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - corr_mean

            elif reference == 'extend':

                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - corr_ext
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - corr_ext

            elif reference == 'retract':

                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - corr_ret
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - corr_ret


        elif method == 'linear':

            slope_ext, baseline_ext = np.polyfit(self.data['extend'][self.keys['x_key']][int((self.settings['samples']['extend']-1) * frac_data[0]):int((self.settings['samples']['extend']-1) * frac_data[1])],
                                                 self.data['extend'][self.keys['y_key']][int((self.settings['samples']['extend']-1) * frac_data[0]):int((self.settings['samples']['extend']-1) * frac_data[1])],1)
            slope_ret, baseline_ret = np.polyfit(self.data['retract'][self.keys['x_key']][-int(self.settings['samples']['retract'] * frac_data[1])-1:-int(self.settings['samples']['extend'] * frac_data[0])-1],
                                                 self.data['retract'][self.keys['y_key']][-int(self.settings['samples']['retract'] * frac_data[1])-1:-int(self.settings['samples']['extend'] * frac_data[0])-1],1)

            ret_dict['parameter'] = {'slope_ext': slope_ext, 'y_intercept_ext': baseline_ext,'slope_ret': slope_ret, 'y_intercept_ret': baseline_ret}

            if reference == 'individual':


                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - baseline_ext - (slope_ext * self.data['extend'][self.keys['x_key']])
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - baseline_ret - (slope_ret * self.data['retract'][self.keys['x_key']])

            elif reference == 'mean':

                slope_mean = 0.5 * (slope_ext + slope_ret)
                baseline_mean = 0.5 * (baseline_ext + baseline_ret)

                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - baseline_mean - (slope_mean * self.data['extend'][self.keys['x_key']])
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - baseline_mean - (slope_mean * self.data['retract'][self.keys['x_key']])

            elif reference == 'extend':

                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - baseline_ext - (slope_ext * self.data['extend'][self.keys['x_key']])
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - baseline_ext - (slope_ext * self.data['retract'][self.keys['x_key']])


            elif reference == 'retract':

                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - baseline_ret - (slope_ret * self.data['extend'][self.keys['x_key']])
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - baseline_ret - (slope_ret * self.data['retract'][self.keys['x_key']])


        elif method == 'quadratic':

            a2_ext, a1_ext, a0_ext = np.polyfit(self.data['extend'][self.keys['x_key']][int((self.settings['samples']['extend']-1) * frac_data[0]):int((self.settings['samples']['extend']-1) * frac_data[1])],
                                                 self.data['extend'][self.keys['y_key']][int((self.settings['samples']['extend']-1) * frac_data[0]):int((self.settings['samples']['extend']-1) * frac_data[1])],2)

            a2_ret, a1_ret, a0_ret = np.polyfit(self.data['retract'][self.keys['x_key']][-int(self.settings['samples']['retract'] * frac_data[1])-1:-int(self.settings['samples']['extend'] * frac_data[0])-1],
                                                 self.data['retract'][self.keys['y_key']][-int(self.settings['samples']['retract'] * frac_data[1])-1:-int(self.settings['samples']['extend'] * frac_data[0])-1],2)

            ret_dict['parameter']: {'a2_ext': a2_ext, 'a1_ext': a1_ext, 'a0_ext': a0_ext, 'a2_ret': a2_ret, 'a1_ret': a1_ret, 'a0_ret': a0_ret}


            if reference == 'individual':

                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - (a2_ext * self.data['extend'][self.keys['x_key']] * self.data['extend'][self.keys['x_key']] + a1_ext * self.data['extend'][self.keys['x_key']] + a0_ext)
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - (a2_ret * self.data['retract'][self.keys['x_key']] * self.data['retract'][self.keys['x_key']] + a1_ret * self.data['retract'][self.keys['x_key']] + a0_ret)

            elif reference == 'mean':

                a2_mean = 0.5 * (a2_ext + a2_ret)
                a1_mean = 0.5 * (a1_ext + a1_ret)
                a0_mean = 0.5 * (a0_ext + a0_ret)

                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - (a2_mean * self.data['extend'][self.keys['x_key']] * self.data['extend'][self.keys['x_key']] + a1_mean * self.data['extend'][self.keys['x_key']] + a0_mean)
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - (a2_mean * self.data['retract'][self.keys['x_key']] * self.data['retract'][self.keys['x_key']] + a1_mean * self.data['retract'][self.keys['x_key']] + a0_mean)

            elif reference == 'extend':

                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - (a2_ext * self.data['extend'][self.keys['x_key']] * self.data['extend'][self.keys['x_key']] + a1_ext * self.data['extend'][self.keys['x_key']] + a0_ext)
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - (a2_ext * self.data['retract'][self.keys['x_key']] * self.data['retract'][self.keys['x_key']] + a1_ext * self.data['retract'][self.keys['x_key']] + a0_ext)


            elif reference == 'retract':

                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - (a2_ret * self.data['extend'][self.keys['x_key']] * self.data['extend'][self.keys['x_key']] + a1_ret * self.data['extend'][self.keys['x_key']] + a0_ret)
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - (a2_ret * self.data['retract'][self.keys['x_key']] * self.data['retract'][self.keys['x_key']] + a1_ret * self.data['retract'][self.keys['x_key']] + a0_ret)


        self.control_variables['baseline_corrected'] = True

        if self.control_variables['baseline_corrected'] and self.control_variables['distance_corrected'] and self.control_variables['tip_sample_separation_correction_performed']:

            self.control_variables['allow_analysis'] = True


        ret_dict['method'] = method
        ret_dict['reference'] = reference
        ret_dict['frac_data'] = frac_data


        return ret_dict




    def get_tip_sample_separation(self):

        for seg in self.data.keys():

            self.data[seg]['separation'] = self.data[seg][self.keys['x_key']] + self.data[seg][self.keys['y_key']] * self.units['force']['factor']/(self.calibrations['spring_constant'] * self.units['distance']['factor'])


        self.channels.append('separation')
        self.channel_units['separation'] = self.channel_units[self.keys['x_key']]

        self.control_variables['tip_sample_separation_correction_performed'] = True

        if self.control_variables['baseline_corrected'] and self.control_variables['distance_corrected'] and self.control_variables['tip_sample_separation_correction_performed']:

            self.control_variables['allow_analysis'] = True


    def distance_correction(self, corr_type = 'zero_force', reference = 'extend', **kwargs):

        ret_dict = dict()
        ret_dict['method'] = corr_type
        ret_dict['reference'] = reference



        if corr_type == 'constant':

            ret_dict['parameter'] = self.distance_correction_constant(reference)


        elif corr_type == 'zero_force':

            #start_type = ['contact', 'distance']

            if 'smooth_applied' in kwargs and type(kwargs['smooth_applied']) is bool:

                s_type = kwargs['smooth_applied']

            else:

                s_type = False


            if 'smooth_length' in kwargs and type(kwargs['smooth_length']) == int and kwargs['smooth_length'] > 0:

                s_length = kwargs['smooth_length']

            else:

                s_length = 51

            ret_dict['parameter'] = self.distance_correction_zero_force_intersect(reference, s_type, s_length)
            ret_dict['smooth_applied'] = s_type
            ret_dict['smooth_length'] = s_length




        elif corr_type == 'fit':

            if 'length_fit' in kwargs:

                ret_dict['parameter'] = self.distance_correction_fit(reference, kwargs['length_fit'])
                ret_dict['length_fit'] = kwargs['length_fit']

            else:

                ret_dict['parameter'] = self.distance_correction_fit(reference)
                ret_dict['length_fit'] = 20

        else:

            ret_dict['parameter'] = self.distance_correction_constant()
            ret_dict['method'] = 'constant'


        self.control_variables['distance_corrected'] = True

        if self.control_variables['baseline_corrected'] and self.control_variables['distance_corrected'] and self.control_variables['tip_sample_separation_correction_performed']:

            self.control_variables['allow_analysis'] = True


        return ret_dict




#%% data analysis


    def get_max_adhesion_force(self, **kwargs):

        if self.control_variables['allow_analysis']:

            index = np.argmin(self.data['retract'][self.keys['y_key']])

            self.max_adhesion_force['value'] = abs(self.data['retract'][self.keys['y_key']][index])
            self.max_adhesion_force['index'] = index
            self.max_adhesion_force['at_x_value'] = self.data['retract'][self.keys['ts_key']][index]
            self.max_adhesion_force['units'] = copy.deepcopy(self.units)


            if 'plot_result' in kwargs and kwargs['plot_result']:


                fig = plt.figure()
                ax = fig.add_axes([0.15, 0.15, 0.75, 0.75])


                text2 = '%.2f' % self.max_adhesion_force['at_x_value'] + ' ' + self.max_adhesion_force['units']['distance']['unit']
                text1 = '%.2f' % self.max_adhesion_force['value'] + ' ' + self.max_adhesion_force['units']['force']['unit']
                textstr = 'Adhesion force: ' + text1 + '\nIndex: ' + str(self.max_adhesion_force['index']) + '\nx-value: ' + text2
                ax.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend')
                ax.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['y_key']], label = 'retract')
                #point_plot = ax.plot(x_max_adh, max_f, marker = 'x', color = 'red', markersize = 20, markeredgewidth = 1)
                ax.plot(self.max_adhesion_force['at_x_value'], -self.max_adhesion_force['value'], marker = 'o', color = 'red', markersize = 10, markerfacecolor = 'None')

                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                ax.legend()
                ax.tick_params(direction = 'in', top = True, right = True)

                bbox_args = dict(boxstyle="round", fc= (1,1,1))
                an1 = ax.annotate(textstr, xy=(.7, .05), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox=bbox_args)
                an1.draggable()


            export = False

            if 'export_result' in kwargs:

                if type(kwargs['export_result']) is bool:

                    export = kwargs['export_result']
                    fileformat = ['svg', 'pdf', 'png', 'pkl']

                elif type(kwargs['export_result']) is str:

                    fileformat = [kwargs['export_result']]
                    export = True

                elif type(kwargs['export_result']) is list:

                    fileformat = kwargs['export_result']
                    export = True


            if export:

                plt.ioff()
                #fig_formats = ['svg', 'pdf', 'png', 'jpg']
                fig_export = [f for f in fileformat if f in ['svg', 'pdf', 'png', 'jpg']]

                fig_exp = plt.figure()
                ax_exp = fig_exp.add_axes([0.15, 0.15, 0.75, 0.75])


                text2 = '%.2f' % self.max_adhesion_force['at_x_value'] + ' ' + self.max_adhesion_force['units']['distance']['unit']
                text1 = '%.2f' % self.max_adhesion_force['value'] + ' ' + self.max_adhesion_force['units']['force']['unit']
                textstr = 'Adhesion force: ' + text1 + '\nIndex: ' + str(self.max_adhesion_force['index']) + '\nx-value: ' + text2
                ax_exp.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend')
                ax_exp.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['y_key']], label = 'retract')
                #point_plot = ax.plot(x_max_adh, max_f, marker = 'x', color = 'red', markersize = 20, markeredgewidth = 1)
                ax_exp.plot(self.max_adhesion_force['at_x_value'], -self.max_adhesion_force['value'], marker = 'o', color = 'red', markersize = 10, markerfacecolor = 'None')

                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                ax_exp.legend()
                ax_exp.tick_params(direction = 'in', top = True, right = True)

                bbox_args = dict(boxstyle="round", fc= (1,1,1))
                ax_exp.annotate(textstr, xy=(.7, .05), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox=bbox_args)


                if not os.path.isdir(os.path.join(self.file_info['save_directory'], 'max_adhesion_force')):

                    os.makedirs(os.path.join(self.file_info['save_directory'], 'max_adhesion_force'))




                for f in fig_export:

                    filename = os.path.join(self.file_info['save_directory'], 'max_adhesion_force', 'max_adhesion_force_' + self.file_info['file_org'] + '.' + f)

                    try:

                         plt.savefig(filename)

                    except:

                          sys.stderr.write('ERROR! Cannot open/write file ' + filename)


                plt.close(fig_exp)

                plt.ion()


                if 'pkl' in fileformat:

                     try:

                        file_pickle = os.path.join(self.file_info['save_directory'], 'max_adhesion_force', 'max_adhesion_force_' + self.file_info['file_org'] + '.pkl')
                        out_pkl = open(file_pickle, 'wb')

                        pickle.dump(self.max_adhesion_force, out_pkl)

                     except:

                          sys.stderr.write('ERROR! Cannot open/write file ' + file_pickle)

                     finally:

                          out_pkl.close()



        else:

            raise ValueError('ERROR! Data are not prepared for analysis. Perform corrections first.')




    def get_rupture_length(self, sensitivity = 1, text_out = False, **kwargs):

        if self.control_variables['allow_analysis']:

            fac = 5 - math.log10(sensitivity)

            if fac < 2:

                fac = 2

            #data = self.data['retract'][self.keys['y_key']]

            adh_event_found = False
            i = 1
            index = 0

            while not adh_event_found and i < self.settings['samples']['retract']:

                if self.data['retract'][self.keys['y_key']][-i] < - fac * self.noise_level['value']: # check whether point a bit before ref level is significantly smaller
                    # if that is the case, confirm that it is not a single outlier

                    adh_event_found = True
                    index = self.settings['samples']['retract'] - i

                    for j in range(0,5): #short check whether the point found was just an outlier

                       if self.data['retract'][self.keys['y_key']][-i-j] > - self.noise_level['value']:

                            adh_event_found = False
                            index = 0


                i += 1

            index_trigger = index

            if adh_event_found: #finds the last point that is smaller than the reference level

                i = 1
                add = 0

                while i < 20 and self.data['retract'][self.keys['y_key']][index+i] < - self.noise_level['value']:

                    add = i
                    i += 1


                index = index + add + 1

            # find the start of the final rupture event:
            index_start = index_trigger
            i = 0

            if adh_event_found:

                while self.data['retract'][self.keys['y_key']][index_start-i-1] < self.data['retract'][self.keys['y_key']][index_start-i] and i < index - 1:

                    i += 1


                index_start = index_start - i


            zero_force = self.get_zero_force_intersect_retract(smooth_applied = False)
            zero_force_index = zero_force['index']

            self.rupture_length['index'] = index
            self.rupture_length['value'] = self.data['retract'][self.keys['ts_key']][index] - self.data['retract'][self.keys['ts_key']][zero_force_index]
            self.rupture_length['units'] = copy.deepcopy(self.units)
            self.rupture_length['sensitivity'] = sensitivity
            self.rupture_length['sensitivity_factor'] = fac
            self.rupture_length['additional_information'] = dict()
            self.rupture_length['additional_information']['zero_force_index'] = zero_force_index
            self.rupture_length['additional_information']['zero_force_value'] = zero_force['value_ts']
            self.rupture_length['additional_information']['last_rupture_end'] = self.data['retract'][self.keys['ts_key']][index]
            self.rupture_length['additional_information']['last_rupture_start'] = self.data['retract'][self.keys['ts_key']][index_start]
            self.rupture_length['additional_information']['rupture_start_index'] = index_start


            if 'plot_result' in kwargs and kwargs['plot_result']:

                fig = plt.figure()
                ax = fig.add_axes([0.15, 0.15, 0.75, 0.75])

                text1 = '%.2f' % self.rupture_length['value'] + ' ' + self.rupture_length['units']['distance']['unit']
                text2 = '(' + str(zero_force_index) + ', ' + str(index) + ')'
                textstr = 'Rupture length: ' + text1 + '\nIndex: ' + text2
                ax.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend')
                ax.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['y_key']], label = 'retract')

                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                ax.legend()
                ax.tick_params(direction = 'in', top = True, right = True)

                y_lim = ax.get_ylim()
                #x_lim = ax.get_xlim()
                y_diff = abs(y_lim[1]-y_lim[0])

                ax.plot([self.rupture_length['additional_information']['zero_force_value'],self.rupture_length['additional_information']['zero_force_value']],[0, y_diff * 0.05],color = (0,0,0), linewidth = 0.5)
                ax.plot([self.rupture_length['additional_information']['last_rupture_end'],self.rupture_length['additional_information']['last_rupture_end']],[0, y_diff * 0.05],color = (0,0,0), linewidth = 0.5)
                ax.plot([self.rupture_length['additional_information']['zero_force_value'],self.rupture_length['additional_information']['last_rupture_end']],[y_diff * 0.025, y_diff * 0.025],color = (0,0,0), linewidth = 0.5)

                bbox_args = dict(boxstyle="round", fc= (1,1,1))
                an1 = ax.annotate(textstr, xy=(.7, .05), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox=bbox_args)
                an1.draggable()

            if 'export_result' in kwargs:

                if type(kwargs['export_result']) is bool:

                    export = kwargs['export_result']
                    fileformat = ['svg', 'pdf', 'png', 'pkl']

                elif type(kwargs['export_result']) is str:

                    fileformat = [kwargs['export_result']]
                    export = True

                elif type(kwargs['export_result']) is list:

                    fileformat = kwargs['export_result']
                    export = True


            if export:

                plt.ioff()
                #fig_formats = ['svg', 'pdf', 'png', 'jpg']
                fig_export = [f for f in fileformat if f in ['svg', 'pdf', 'png', 'jpg']]

                fig_exp = plt.figure()
                ax_exp = fig_exp.add_axes([0.15, 0.15, 0.75, 0.75])


                text1 = '%.2f' % self.rupture_length['value'] + ' ' + self.rupture_length['units']['distance']['unit']
                text2 = '(' + str(zero_force_index) + ', ' + str(index) + ')'
                textstr = 'Rupture length: ' + text1 + '\nIndex: ' + text2
                ax_exp.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend')
                ax_exp.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['y_key']], label = 'retract')

                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                ax_exp.legend()
                ax_exp.tick_params(direction = 'in', top = True, right = True)

                y_lim = ax_exp.get_ylim()
                #x_lim = ax.get_xlim()
                y_diff = abs(y_lim[1]-y_lim[0])

                ax_exp.plot([self.rupture_length['additional_information']['zero_force_value'],self.rupture_length['additional_information']['zero_force_value']],[0, y_diff * 0.05],color = (0,0,0), linewidth = 0.5)
                ax_exp.plot([self.rupture_length['additional_information']['last_rupture_end'],self.rupture_length['additional_information']['last_rupture_end']],[0, y_diff * 0.05],color = (0,0,0), linewidth = 0.5)
                ax_exp.plot([self.rupture_length['additional_information']['zero_force_value'],self.rupture_length['additional_information']['last_rupture_end']],[y_diff * 0.025, y_diff * 0.025],color = (0,0,0), linewidth = 0.5)

                bbox_args = dict(boxstyle="round", fc= (1,1,1))
                ax_exp.annotate(textstr, xy=(.7, .05), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox=bbox_args)


                if not os.path.isdir(os.path.join(self.file_info['save_directory'], 'rupture_length')):

                    os.makedirs(os.path.join(self.file_info['save_directory'], 'rupture_length'))




                for f in fig_export:

                    filename = os.path.join(self.file_info['save_directory'], 'rupture_length', 'rupture_length_' + self.file_info['file_org'] + '.' + f)

                    try:

                         plt.savefig(filename)

                    except:

                          sys.stderr.write('ERROR! Cannot open/write file ' + filename)


                plt.close(fig_exp)

                plt.ion()


                if 'pkl' in fileformat:

                     try:

                        file_pickle = os.path.join(self.file_info['save_directory'], 'rupture_length', 'rupture_length_' + self.file_info['file_org'] + '.pkl')
                        out_pkl = open(file_pickle, 'wb')

                        pickle.dump(self.rupture_length, out_pkl)

                     except:

                          sys.stderr.write('ERROR! Cannot open/write file ' + file_pickle)

                     finally:

                          out_pkl.close()


        else:

            raise ValueError('ERROR! Data are not prepared for analysis. Perform corrections first.')



    def get_adhesion_energy(self, sensitivity = 1, range_selection = {'method': 'automatic'}, **kwargs):


        if self.control_variables['allow_analysis']:

            self.adhesion_energy['range_selection'] = dict()

            if range_selection['method'] == 'automatic':

                self.adhesion_energy['range_selection']['method'] = 'automatic'
                start_index = self.get_zero_force_intersect_retract(smooth_applied = False)['index']
                end_index = self.get_last_adhesion_signature(sensitivity)['end_adh_event_index']

            elif range_selection['method'] == 'index':

                self.adhesion_energy['range_selection']['method'] = 'index'

                start_index = range_selection['range'][0]
                end_index = range_selection['range'][1]

            elif range_selection['method'] == 'interval':

                self.adhesion_energy['range_selection']['method'] = 'interval'

                end_index = np.argmax(self.data['extend'][self.keys['ts_key']]>range_selection['range'][1])
                start_index = np.argmin(self.data['extend'][self.keys['ts_key']]<range_selection['range'][0])

                if end_index and start_index:

                    self.adhesion_energy['range_selection']['method'] = 'automatic'
                    start_index = self.get_zero_force_intersect_retract(smooth_applied = False)['index']
                    end_index = self.get_last_adhesion_signature(sensitivity)['end_adh_event_index']



            self.adhesion_energy['range_selection']['index_range'] = (start_index, end_index)
            self.adhesion_energy['range_selection']['interval'] = (self.data['retract'][self.keys['ts_key']][start_index], self.data['retract'][self.keys['ts_key']][end_index])


            bar_height = 0.5 * (self.data['retract'][self.keys['y_key']][start_index:end_index] + self.data['retract'][self.keys['y_key']][start_index+1:end_index+1])
            bar_width_ts = self.data['retract'][self.keys['ts_key']][start_index:end_index] - self.data['retract'][self.keys['ts_key']][start_index+1:end_index+1]
            bar_width_x = self.data['retract'][self.keys['x_key']][start_index:end_index] - self.data['retract'][self.keys['x_key']][start_index+1:end_index+1]
            bar_height[bar_height>0] = 0

            #print(bar_height*bar_width_ts)

            sum_eng_ts = np.sum(bar_height*bar_width_ts)
            sum_eng_x = np.sum(bar_height*bar_width_x)


            self.adhesion_energy['value'] = abs(sum_eng_x)
            self.adhesion_energy['value_ts'] = abs(sum_eng_ts)


            self.adhesion_energy['units'] = dict()
            self.adhesion_energy['units']['distance'] = dict()
            self.adhesion_energy['units']['distance']['unit'] = copy.deepcopy(self.units['distance']['unit'])
            self.adhesion_energy['units']['distance']['factor'] = copy.deepcopy(self.units['distance']['factor'])

            self.adhesion_energy['units']['energy'] = dict()
            self.adhesion_energy['units']['energy']['unit'] = str(10**round(np.log10(self.units['distance']['factor']*self.units['force']['factor']))) + ' J'
            self.adhesion_energy['units']['energy']['factor'] = 10**round(np.log10(self.units['distance']['factor']*self.units['force']['factor']))



            extend_plot = False

            if 'extend_plot' in kwargs and kwargs['extend_plot']:

                extend_plot = True



            if 'plot_result' in kwargs and kwargs['plot_result']:



                x_data = self.data['retract'][self.keys['ts_key']][start_index:end_index+1]
                y_data = self.data['retract'][self.keys['y_key']][start_index:end_index+1]

                verts = [(self.data['retract'][self.keys['ts_key']][start_index],0), *zip(x_data,y_data), (self.data['retract'][self.keys['ts_key']][end_index], 0)]


                fig = plt.figure()
                ax = fig.add_axes([0.15, 0.15, 0.75, 0.75])

                #if '10e' in self.adhesion_energy['unit']:

                #    dot = u'\u22c5'#u'\u2022'#u'\u00b7'

                #else:

                #    dot = ' '

                text1 = '%.2f' % self.adhesion_energy['value'] + u'\u22c5'+ self.adhesion_energy['units']['energy']['unit']
                text2 = '(%.2f' % self.adhesion_energy['range_selection']['interval'][0] + ' ' + self.units['distance']['unit'] + ', %.2f ' % self.adhesion_energy['range_selection']['interval'][1] + ' ' + self.units['distance']['unit'] + ')'
                textstr = 'Interval: ' + text2 +'\nAdhesion energy: ' + text1

                if extend_plot:

                    ax.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend', color = '#1f77b4ff')

                ax.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['y_key']], label = 'retract', color = '#ff7e0eff')


                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                ax.legend()
                ax.tick_params(direction = 'in', top = True, right = True)

                poly = matplotlib.patches.Polygon(verts, facecolor='#ff7e0e32')
                ax.add_patch(poly)


                bbox_args = dict(boxstyle="round", fc= (1,1,1))
                an1 = ax.annotate(textstr, xy=(.65, .05), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox=bbox_args)
                an1.draggable()


            export = False

            if 'export_result' in kwargs:

                if type(kwargs['export_result']) is bool:

                    export = kwargs['export_result']
                    fileformat = ['svg', 'pdf', 'png', 'txt', 'pkl']

                elif type(kwargs['export_result']) is str:

                    fileformat = [kwargs['export_result']]
                    export = True

                elif type(kwargs['export_result']) is list:

                    fileformat = kwargs['export_result']
                    export = True



            if export:

                plt.ioff()
                #fig_formats = ['svg', 'pdf', 'png', 'jpg']
                fig_export = [f for f in fileformat if f in ['svg', 'pdf', 'png', 'jpg']]

                x_data = self.data['retract'][self.keys['ts_key']][start_index:end_index+1]
                y_data = self.data['retract'][self.keys['y_key']][start_index:end_index+1]

                verts_exp = [(self.data['retract'][self.keys['ts_key']][start_index],0), *zip(x_data,y_data), (self.data['retract'][self.keys['ts_key']][end_index], 0)]

                fig_exp = plt.figure()
                ax_exp = fig_exp.add_axes([0.15, 0.15, 0.75, 0.75])

                #if '10e' in self.adhesion_energy['unit']:

                #    dot = u'\u22c5'#u'\u2022'#u'\u00b7'

                #else:

                #    dot = ' '

                text1 = '%.2f' % self.adhesion_energy['value'] + u'\u22c5' + self.adhesion_energy['units']['energy']['unit']
                text2 = '(%.2f' % self.adhesion_energy['range_selection']['interval'][0] + ' ' + self.units['distance']['unit'] + ', %.2f ' % self.adhesion_energy['range_selection']['interval'][1] + ' ' + self.units['distance']['unit'] + ')'
                textstr = 'Interval: ' + text2 +'\nAdhesion energy: ' + text1

                if extend_plot:

                    ax_exp.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend', color = '#1f77b4ff')

                ax_exp.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['y_key']], label = 'retract', color = '#ff7e0eff')


                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                ax_exp.legend()
                ax_exp.tick_params(direction = 'in', top = True, right = True)

                poly = matplotlib.patches.Polygon(verts_exp, facecolor='#ff7e0e32')
                ax_exp.add_patch(poly)


                bbox_args = dict(boxstyle="round", fc= (1,1,1))
                ax_exp.annotate(textstr, xy=(.65, .05), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox=bbox_args)


                if not os.path.isdir(os.path.join(self.file_info['save_directory'], 'adhesion_energy')):

                    os.makedirs(os.path.join(self.file_info['save_directory'], 'adhesion_energy'))




                for f in fig_export:

                    filename = os.path.join(self.file_info['save_directory'], 'adhesion_energy', 'adhesion_energy_' + self.file_info['file_org'] + '.' + f)

                    try:

                         plt.savefig(filename)

                    except:

                          sys.stderr.write('ERROR! Cannot open/write file ' + filename)


                plt.close(fig_exp)

                plt.ion()


                if 'pkl' in fileformat:

                     try:

                        file_pickle = os.path.join(self.file_info['save_directory'], 'adhesion_energy', 'adhesion_energy_' + self.file_info['file_org'] + '.pkl')
                        out_pkl = open(file_pickle, 'wb')

                        pickle.dump(self.rupture_length, out_pkl)

                     except:

                          sys.stderr.write('ERROR! Cannot open/write file ' + file_pickle)

                     finally:

                          out_pkl.close()

        else:

            raise ValueError('ERROR! Data are not prepared for analysis. Perform corrections first.')




    def get_snap_in(self, sensitivity = 1, event_sep = 0, mean_length = 5, **kwargs):

        if self.control_variables['allow_analysis']:

            fac = 5 - math.log10(sensitivity)

            if fac < 2:

                fac = 2


            data_y_reverse = copy.deepcopy(self.data['extend'][self.keys['y_key']])
            data_y_reverse = data_y_reverse[::-1]

            potential_events = list()
            i = mean_length

            while i < self.settings['samples']['extend'] - 100:

                j = 0

                while data_y_reverse[i+j] < data_y_reverse[i+j+1] and i + j < self.settings['samples']['extend'] - 50:

                    j += 1


                if j > 0:

                    potential_events.append((i,i+j))

                j += 1
                i += j

            diff_list = list()


            for events in potential_events:

                 if mean_length > 0:

                      diff = np.mean(data_y_reverse[events[0]-mean_length:events[0]]) - np.mean(data_y_reverse[events[1]:events[1]+mean_length])

                      if diff > 0:

                           diff = 0

                      diff_list.append(abs(diff))

                 else:

                      diff_list.append(abs(data_y_reverse[events[0]]-data_y_reverse[events[1]]))


            events_reverse = [(potential_events[i]) for i in range(0,len(diff_list)) if diff_list[i] > self.noise_level['value'] * fac]


            if event_sep > 0:

               events_comb_reverse = combine_tuple(events_reverse, event_sep)

            else:

               events_comb_reverse = events_reverse


            if len(events_comb_reverse) > 0: #there is an event

                event = events_comb_reverse[0]

                #find the end of the snap in
                end_found = False
                i = self.settings['samples']['extend']-event[1]
                start_snap_in = self.data['extend'][self.keys['y_key']][self.settings['samples']['extend']-event[1]-1]

                while not end_found and i < self.settings['samples']['extend'] - 1:

                    if self.data['extend'][self.keys['y_key']][i] < start_snap_in:

                        i += 1

                    else:

                         end_found = True

                #find the minimum of the snap in
                min_snap_in = self.data['extend'][self.keys['y_key']][self.settings['samples']['extend']-event[1]-1]
                min_index = self.settings['samples']['extend']-event[1]-1
                j = self.settings['samples']['extend']-event[0]-1

                while j < self.settings['samples']['extend'] - 1:

                    if self.data['extend'][self.keys['y_key']][j] < min_snap_in:

                        min_snap_in = self.data['extend'][self.keys['y_key']][j]
                        min_index = j

                    j += 1


                magn = self.data['extend'][self.keys['y_key']][self.settings['samples']['extend']-event[0]-1] - self.data['extend'][self.keys['y_key']][self.settings['samples']['extend']-event[1]-1]
                magn = min_snap_in - self.data['extend'][self.keys['y_key']][self.settings['samples']['extend']-event[1]-1]

                self.snap_in['exists'] = True
                self.snap_in['magn'] = abs(magn)
                self.snap_in['index'] = self.settings['samples']['extend']-event[1]-1
                self.snap_in['start_x_value'] = self.data['extend'][self.keys['ts_key']][self.snap_in['index']]
                self.snap_in['end_index'] = i
                self.snap_in['end_x_value'] = self.data['extend'][self.keys['ts_key']][i]
                self.snap_in['units'] = copy.deepcopy(self.units)


            else:

                self.snap_in['exists'] = False
                self.snap_in['magn'] = 0
                self.snap_in['index'] = 0
                self.snap_in['start_x_value'] = 0
                self.snap_in['end_index'] = 0
                self.snap_in['end_x_value'] = 0
                self.snap_in['units'] = copy.deepcopy(self.units)


            retract_plot = False

            if 'retract_plot' in kwargs and kwargs['retract_plot']:

                retract_plot = True


            if 'plot_result' in kwargs and kwargs['plot_result']:

                fig = plt.figure()
                ax = fig.add_axes([0.15, 0.15, 0.75, 0.75])

                if self.snap_in['exists']:

                    text1 = '%.2f' % self.snap_in['magn'] + ' ' + self.snap_in['units']['force']['unit'] + ' @ ' +'%.2f' % self.snap_in['start_x_value'] + ' ' + self.snap_in['units']['distance']['unit']
                    text2 = str(self.snap_in['index'])

                else:

                    text1 = 'N/A'
                    text2 = 'N/A'

                textstr = 'Snap in: ' + text1 + '\nIndex: ' + text2


                ax.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend', color = '#1f77b4ff')

                if retract_plot:

                    ax.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['y_key']], label = 'retract', color = '#ff7e0eff')


                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                ax.legend()
                ax.tick_params(direction = 'in', top = True, right = True)

                x_lim = ax.get_xlim()
                x_diff = abs(x_lim[1]-x_lim[0])

                if self.snap_in['exists']:

                    ax.plot([self.snap_in['start_x_value']-0.025*x_diff, self.snap_in['start_x_value']+0.025*x_diff],[self.data['extend'][self.keys['y_key']][self.snap_in['index']], self.data['extend'][self.keys['y_key']][self.snap_in['index']]],color = (0,0,0), linewidth = 1)
                    ax.plot([self.snap_in['start_x_value']-0.025*x_diff, self.snap_in['start_x_value']+0.025*x_diff],[self.data['extend'][self.keys['y_key']][min_index], self.data['extend'][self.keys['y_key']][min_index]],color = (0,0,0), linewidth = 1)
                    ax.plot([self.snap_in['start_x_value'], self.snap_in['start_x_value']],[self.data['extend'][self.keys['y_key']][min_index], self.data['extend'][self.keys['y_key']][self.snap_in['index']]],color = (0,0,0), linewidth = 1)


                bbox_args = dict(boxstyle="round", fc= (1,1,1))
                an1 = ax.annotate(textstr, xy=(.45, .9), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox=bbox_args)
                an1.draggable() #allows to drag the box arround


            export = False

            if 'export_result' in kwargs:

                if type(kwargs['export_result']) is bool:

                    export = kwargs['export_result']
                    fileformat = ['svg', 'pdf', 'png', 'pkl']

                elif type(kwargs['export_result']) is str:

                    fileformat = [kwargs['export_result']]
                    export = True

                elif type(kwargs['export_result']) is list:

                    fileformat = kwargs['export_result']
                    export = True


            if export:

                plt.ioff()
                #fig_formats = ['svg', 'pdf', 'png', 'jpg']
                fig_export = [f for f in fileformat if f in ['svg', 'pdf', 'png', 'jpg']]

                fig_exp = plt.figure()
                ax_exp = fig_exp.add_axes([0.15, 0.15, 0.75, 0.75])

                if self.snap_in['exists']:

                    text1 = '%.2f' % self.snap_in['magn'] + ' ' + self.snap_in['units']['force']['unit'] + ' @ ' +'%.2f' % self.snap_in['start_x_value'] + ' ' + self.snap_in['units']['distance']['unit']
                    text2 = str(self.snap_in['index'])

                else:

                    text1 = 'N/A'
                    text2 = 'N/A'

                textstr = 'Snap in: ' + text1 + '\nIndex: ' + text2


                ax_exp.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend', color = '#1f77b4ff')

                if retract_plot:

                    ax_exp.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['y_key']], label = 'retract', color = '#ff7e0eff')


                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                ax_exp.legend()
                ax_exp.tick_params(direction = 'in', top = True, right = True)

                x_lim = ax_exp.get_xlim()
                x_diff = abs(x_lim[1]-x_lim[0])

                if self.snap_in['exists']:

                    ax_exp.plot([self.snap_in['start_x_value']-0.025*x_diff, self.snap_in['start_x_value']+0.025*x_diff],[self.data['extend'][self.keys['y_key']][self.snap_in['index']], self.data['extend'][self.keys['y_key']][self.snap_in['index']]],color = (0,0,0), linewidth = 1)
                    ax_exp.plot([self.snap_in['start_x_value']-0.025*x_diff, self.snap_in['start_x_value']+0.025*x_diff],[self.data['extend'][self.keys['y_key']][min_index], self.data['extend'][self.keys['y_key']][min_index]],color = (0,0,0), linewidth = 1)
                    ax_exp.plot([self.snap_in['start_x_value'], self.snap_in['start_x_value']],[self.data['extend'][self.keys['y_key']][min_index], self.data['extend'][self.keys['y_key']][self.snap_in['index']]],color = (0,0,0), linewidth = 1)


                bbox_args = dict(boxstyle="round", fc= (1,1,1))
                ax_exp.annotate(textstr, xy=(.45, .9), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox=bbox_args)


                if not os.path.isdir(os.path.join(self.file_info['save_directory'], 'snap_in')):

                    os.makedirs(os.path.join(self.file_info['save_directory'], 'snap_in'))




                for f in fig_export:

                    filename = os.path.join(self.file_info['save_directory'], 'snap_in', 'snap_in_' + self.file_info['file_org'] + '.' + f)

                    try:

                         plt.savefig(filename)

                    except:

                          sys.stderr.write('ERROR! Cannot open/write file ' + filename)


                plt.close(fig_exp)

                plt.ion()


                if 'pkl' in fileformat:

                     try:

                        file_pickle = os.path.join(self.file_info['save_directory'], 'snap_in', 'snap_in_' + self.file_info['file_org'] + '.pkl')
                        out_pkl = open(file_pickle, 'wb')

                        pickle.dump(self.snap_in, out_pkl)

                     except:

                          sys.stderr.write('ERROR! Cannot open/write file ' + file_pickle)

                     finally:

                          out_pkl.close()

        else:

            raise ValueError('ERROR! Data are not prepared for analysis. Perform corrections first.')




    def get_adhesion_signatures(self, method = 'derivation', sensitivity = 1, event_sep = 0, mean_length = 5,
                                range_selection = {'method': 'automatic'}, only_after_max_adh = False,  **kwargs):

        if self.control_variables['allow_analysis']:

            fac = 5 - math.log10(sensitivity)

            if fac < 2:

                fac = 2


            self.adhesion_signatures['range_selection'] = dict()

            if range_selection['method'] == 'automatic':

                self.adhesion_signatures['range_selection']['method'] = 'automatic'
                start_index = self.get_zero_force_intersect_retract(smooth_applied = False)['index']
                end_index = self.get_last_adhesion_signature(sensitivity)['end_adh_event_index']

            elif range_selection['method'] == 'index':

                self.adhesion_signatures['range_selection']['method'] = 'index'

                start_index = range_selection['range'][0]
                end_index = range_selection['range'][1]

            elif range_selection['method'] == 'interval':

                self.adhesion_signatures['range_selection']['method'] = 'interval'

                end_index = np.argmax(self.data['extend'][self.keys['ts_key']]>range_selection['range'][1])
                start_index = np.argmin(self.data['extend'][self.keys['ts_key']]<range_selection['range'][0])

                if end_index and start_index:

                    self.adhesion_signatures['range_selection']['method'] = 'automatic'
                    start_index = self.get_zero_force_intersect_retract(smooth_applied = False)['index']
                    end_index = self.get_last_adhesion_signature(sensitivity)['end_adh_event_index']



            self.adhesion_signatures['range_selection']['index_range'] = (start_index, end_index)
            self.adhesion_signatures['range_selection']['interval'] = (self.data['retract'][self.keys['ts_key']][start_index], self.data['retract'][self.keys['ts_key']][end_index])
            self.adhesion_signatures['range_selection']['only_after_max_adh'] = only_after_max_adh

            if only_after_max_adh:

                #start_index = max(start_index, np.argmin(self.data['retract'][self.keys['y_key']]))
                start_index = np.argmin(self.data['retract'][self.keys['y_key']])


            self.adhesion_signatures['method'] = method

            #end_adh = self.get_last_adhesion_signature(sensitivity = sensitivity) unnecessary


            if method == 'derivation':

                #data_x = self.data['retract'][self.keys['x_key']][start_index:end_index]
                #data_y = self.data['retract'][self.keys['y_key']][start_index:end_index]


                # 1. get potential rupture events
                potential_rupt_index = list()
                avg_slope = np.mean(np.absolute(self.data['retract'][self.keys['y_key']][-50:-2] - self.data['retract'][self.keys['y_key']][-49:-1]))

                i = start_index

                #for i in range(start_index, end_index-1):
                while i < end_index - 1:

                    x_diff = max(0,self.data['retract'][self.keys['x_key']][i+1] - self.data['retract'][self.keys['x_key']][i])
                    y_diff = self.data['retract'][self.keys['y_key']][i+1] - self.data['retract'][self.keys['y_key']][i]

                    #if x_diff <= 0:

                    #    diff = y_diff

                    #else:

                    #    diff = y_diff/x_diff


                    if y_diff/(x_diff or not 0) > avg_slope * fac:

                        potential_rupt_index.append(i)

                        while (self.data['retract'][self.keys['x_key']][i+1] - self.data['retract'][self.keys['x_key']][i])/((self.data['retract'][self.keys['y_key']][i+1] - self.data['retract'][self.keys['y_key']][i]) or not 0) > avg_slope * fac:

                            i += 1

                    i += 1


                # 3. get start and end index of all of these potential rupture events
                #rupt_events = dict()
                events = list()
                for i in range(0, len(potential_rupt_index)):

                    i_minus = 0
                    i_plus = 0

                    while self.data['retract'][self.keys['y_key']][potential_rupt_index[i]+i_plus+1] > self.data['retract'][self.keys['y_key']][potential_rupt_index[i]+i_plus]:

                        i_plus += 1

                    while self.data['retract'][self.keys['y_key']][potential_rupt_index[i]-i_minus] > self.data['retract'][self.keys['y_key']][potential_rupt_index[i]-i_minus-1]:

                        i_minus += 1


                    #rupt_events[i] = [potential_rupt_index[i] - i_minus, potential_rupt_index[i] + i_plus + 1]
                    events.append((potential_rupt_index[i] - i_minus, potential_rupt_index[i] + i_plus))


                if event_sep > 0:

                    events_comb = combine_tuple(events, event_sep)

                else:

                    events_comb = combine_tuple(events, 0) #combine any overlapping events

                # sort out any events that are too small

                events_final = list()

                for i in range(0, len(events_comb)):

                    if mean_length > 0:

                         diff = abs(np.mean(self.data['retract'][self.keys['y_key']][events_comb[i][0]-mean_length:events_comb[i][0]])) - abs(np.mean(self.data['retract'][self.keys['y_key']][events_comb[i][1]:events_comb[i][1]+mean_length]))

                    else:

                         diff = abs(self.data['retract'][self.keys['y_key']][events_comb[i][0]]) - abs(self.data['retract'][self.keys['y_key']][events_comb[i][1]])

                    #diff = abs(data_y[events_comb[i][0]]) - abs(data_y[events_comb[i][1]])

                    if diff > self.noise_level['value'] * fac:

                        events_final.append(events_comb[i])

                # 4. confirm that the suggested events are rupture events

                self.adhesion_signatures['events'] = list()

                confirmed_counter = 0
                unclear_counter = 0

                for i in range(0, len(events_final)):

                    self.adhesion_signatures['events'].append(dict())
                    self.adhesion_signatures['events'][i]['event_num'] = i

                    magn = abs(self.data['retract'][self.keys['y_key']][events_final[i][0]]) - abs(self.data['retract'][self.keys['y_key']][events_final[i][1]])
                    #diff = abs(data_y[events_final[i][0]]) - abs(data_y[events_final[i][1]])

                    if mean_length > 0:

                         diff = abs(np.mean(self.data['retract'][self.keys['y_key']][events_final[i][0]-mean_length:events_final[i][0]])) - abs(np.mean(self.data['retract'][self.keys['y_key']][events_final[i][1]:events_final[i][1]+mean_length]))

                    else:

                         diff = abs(self.data['retract'][self.keys['y_key']][events_final[i][0]]) - abs(self.data['retract'][self.keys['y_key']][events_final[i][1]])


                    if diff > self.noise_level['value'] * fac * 2:

                        self.adhesion_signatures['events'][i]['status'] = 'confirmed'
                        confirmed_counter += 1

                    else:

                        self.adhesion_signatures['events'][i]['status'] = 'unclear'
                        unclear_counter += 1


                    self.adhesion_signatures['events'][i]['force_start'] = abs(self.data['retract'][self.keys['y_key']][events_final[i][0]])
                    self.adhesion_signatures['events'][i]['magnitude'] = magn
                    self.adhesion_signatures['events'][i]['index'] = (events_final[i][0],events_final[i][1])
                    #rupt_events_final['events'][i]['type'] = 'non-characterized'


                    self.adhesion_signatures['events'][i]['x_loc_start_ts'] = self.data['retract'][self.keys['ts_key']][events_final[i][0]]
                    self.adhesion_signatures['events'][i]['x_loc_end_ts'] = self.data['retract'][self.keys['ts_key']][events_final[i][1]]
                    self.adhesion_signatures['events'][i]['x_loc_start_h'] = self.data['retract'][self.keys['x_key']][events_final[i][0]]
                    self.adhesion_signatures['events'][i]['x_loc_end_h'] = self.data['retract'][self.keys['x_key']][events_final[i][1]]



            elif method == 'jump':

                self.adhesion_signatures['events'] = list()

                # 1. get potential events
                potential_events = list()

                i = start_index

                while i < end_index - mean_length + 1:

                    j = 0

                    while self.data['retract'][self.keys['y_key']][i+j] < self.data['retract'][self.keys['y_key']][i+j+1] and i + j < self.settings['samples']['retract'] - 50:

                        j += 1


                    if j > 0:

                        potential_events.append((i,i+j))


                    j += 1
                    i += j


                # 2. calculate difference between start and end for potential events
                diff_list = list()

                for events in potential_events:

                    if mean_length > 0:

                         #diff = abs(statistics.mean(data_y[events_final[i][0]-mean_length:events_final[i][0]])) - abs(statistics.mean(data_y[events_final[i][1]:events_final[i][1]+mean_length]))
                         diff = np.mean(self.data['retract'][self.keys['y_key']][events[1]:events[1]+mean_length]) - np.mean(self.data['retract'][self.keys['y_key']][events[0]-mean_length:events[0]])

                    else:

                         diff = self.data['retract'][self.keys['y_key']][events[0]]-self.data['retract'][self.keys['y_key']][events[1]]

                    diff_list.append(diff)



                events = [(potential_events[i]) for i in range(0,len(diff_list)) if diff_list[i] > self.noise_level['value'] * fac]

                if event_sep > 0:

                    events_comb = combine_tuple(events, event_sep)

                else:

                    events_comb = events

                confirmed_counter = 0
                unclear_counter = 0

                for i in range(0, len(events_comb)):

                    self.adhesion_signatures['events'].append(dict())
                    self.adhesion_signatures['events'][i]['event_num'] = i

                    magn = abs(self.data['retract'][self.keys['y_key']][events_comb[i][0]]) - abs(self.data['retract'][self.keys['y_key']][events_comb[i][1]])
                    diff = abs(self.data['retract'][self.keys['y_key']][events_comb[i][0]]) - abs(self.data['retract'][self.keys['y_key']][events_comb[i][1]])

                    if mean_length > 0:

                         diff = abs(np.mean(self.data['retract'][self.keys['y_key']][events_comb[i][0]-mean_length:events_comb[i][0]])-np.mean(self.data['retract'][self.keys['y_key']][events_comb[i][1]:events_comb[i][1]+mean_length]))
                         #diff = abs(data_y[events_comb[i][0]]) - abs(data_y[events_comb[i][1]])

                    else:

                         diff = abs(self.data['retract'][self.keys['y_key']][events_comb[i][0]]) - abs(self.data['retract'][self.keys['y_key']][events_comb[i][1]])


                    if diff > self.noise_level['value'] * fac * 2:

                        self.adhesion_signatures['events'][i]['status'] = 'confirmed'
                        confirmed_counter += 1

                    else:

                        self.adhesion_signatures['events'][i]['status'] = 'unclear'
                        unclear_counter += 1



                    self.adhesion_signatures['events'][i]['force_start'] = abs(self.data['retract'][self.keys['y_key']][events_comb[i][0]])
                    self.adhesion_signatures['events'][i]['magnitude'] = magn
                    self.adhesion_signatures['events'][i]['index'] = (events_comb[i][0],events_comb[i][1])
                    #rupt_events_final['events'][i]['type'] = 'non-characterized'

                    self.adhesion_signatures['events'][i]['x_loc_start_ts_separation'] = self.data['retract'][self.keys['ts_key']][events_comb[i][0]]
                    self.adhesion_signatures['events'][i]['x_loc_end_ts_separation'] = self.data['retract'][self.keys['ts_key']][events_comb[i][1]]
                    self.adhesion_signatures['events'][i]['x_loc_start_h'] = self.data['retract'][self.keys['x_key']][events_comb[i][0]]
                    self.adhesion_signatures['events'][i]['x_loc_end_h'] = self.data['retract'][self.keys['x_key']][events_comb[i][1]]

            self.adhesion_signatures['confirmed_events'] = confirmed_counter
            self.adhesion_signatures['unclear_events'] = unclear_counter
            self.adhesion_signatures['sensitivity'] = sensitivity
            self.adhesion_signatures['sensitivity_factor'] = fac
            self.adhesion_signatures['event_sep'] = event_sep
            self.adhesion_signatures['event_sep'] = mean_length

            self.adhesion_signatures['units'] = copy.deepcopy(self.units)


#            extend_plot = False

#            if 'extend_plot' in kwargs and kwargs['extend_plot']:

#                extend_plot = True



            if 'plot_result' in kwargs and kwargs['plot_result']:

                # 1. plot fd curve
                fig = plt.figure()
                ax = fig.add_axes([0.15, 0.15, 0.75, 0.75])

                if 'extend_plot' in kwargs and kwargs['extend_plot']:

                    ax.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend', color = '#1f77b4ff')

                ax.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['y_key']], label = 'retract', color = '#ff7e0eff')


                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                ax.legend()
                ax.tick_params(direction = 'in', top = True, right = True)

                y_lim = ax.get_ylim()
                x_lim = ax.get_xlim()
                y_diff = abs(y_lim[1]-y_lim[0])
                x_diff = abs(x_lim[1]-x_lim[0])

                # 2. add individual adhesion events
                text_end_max = 0


                for i in range(0, len(self.adhesion_signatures['events'])):

                    text_end = self.data['retract'][self.keys['y_key']][self.adhesion_signatures['events'][i]['index'][0]]

                    if abs(text_end) > text_end_max:

                        text_end_max = abs(text_end)

                pos_text_y_list = list()

                for i in range(0, len(self.adhesion_signatures['events'])):

                    pos_text_y = i * 0.05 + 0.05
                    pos_text_y_list.append(pos_text_y)


                pos_text_y_list.reverse()
                text_final = str()

                for i in range(0, len(self.adhesion_signatures['events'])):

                    event_type = self.adhesion_signatures['events'][i]['status']

                    if event_type == 'confirmed':

                        color_line = (0,0.6,0)

                    elif event_type == 'unclear':

                        color_line = (0.6,0,0)

                    start_ind = self.adhesion_signatures['events'][i]['index'][0]
                    end_ind = self.adhesion_signatures['events'][i]['index'][1]

                    plot_x_start = self.data['retract'][self.keys['ts_key']][start_ind]
                    plot_x_end = self.data['retract'][self.keys['ts_key']][end_ind]
                    plot_y_start = self.data['retract'][self.keys['y_key']][start_ind]
                    plot_y_end = self.data['retract'][self.keys['y_key']][end_ind]


                    ax.plot([plot_x_start-0.005*x_diff, plot_x_end+0.005*x_diff],[plot_y_start,plot_y_start], color = (0,0,0), linewidth = 0.5)
                    ax.plot([plot_x_start-0.005*x_diff, plot_x_end+0.005*x_diff],[plot_y_end,plot_y_end], color = (0,0,0), linewidth = 0.5)
                    ax.plot([plot_x_start, plot_x_start],[plot_y_start - 0.1*y_diff,plot_y_end], color = color_line, linewidth = 0.5)

                    text1 = '%.2e' % self.adhesion_signatures['events'][i]['magnitude'] + ' ' + self.adhesion_signatures['units']['force']['unit'] + ' '
                    text2 = ' %.2f' % self.adhesion_signatures['events'][i]['x_loc_start_ts_separation'] + ' ' + self.adhesion_signatures['units']['distance']['unit']
                    textstr = '('+str(i)+'): ' + text1 + u'\u0040' + text2

                    plt.text(plot_x_start - 0.015 *x_diff, plot_y_start - 0.135*y_diff, '('+str(i)+')', fontsize = 'x-small')


                    if i == len(self.adhesion_signatures['events'])-1:
                        text_final += textstr
                    else:
                        text_final += textstr + '\n'


                if len(self.adhesion_signatures['events']) <= 10:

                    bbox_args = dict(boxstyle="round", fc= (1,1,1))

                    an1 = ax.annotate(text_final, xy=(.65, .05), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox=bbox_args)
                    an1.draggable() #allows to drag the box arround


            export = False

            if 'export_result' in kwargs:

                if type(kwargs['export_result']) is bool:

                    export = kwargs['export_result']
                    fileformat = ['svg', 'pdf', 'png', 'pkl']

                elif type(kwargs['export_result']) is str:

                    fileformat = [kwargs['export_result']]
                    export = True

                elif type(kwargs['export_result']) is list:

                    fileformat = kwargs['export_result']
                    export = True


            if export:

                plt.ioff()
                #fig_formats = ['svg', 'pdf', 'png', 'jpg']
                fig_export = [f for f in fileformat if f in ['svg', 'pdf', 'png', 'jpg']]

                fig_exp = plt.figure()
                ax_exp = fig_exp.add_axes([0.15, 0.15, 0.75, 0.75])
                ax_exp.tick_params(direction = 'in', top = True, right = True)

                if 'extend_plot' in kwargs and kwargs['extend_plot']:

                    ax_exp.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend', color = '#1f77b4ff')

                ax_exp.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['y_key']], label = 'retract', color = '#ff7e0eff')


                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                ax_exp.legend()

                y_lim = ax_exp.get_ylim()
                x_lim = ax_exp.get_xlim()
                y_diff = abs(y_lim[1]-y_lim[0])
                x_diff = abs(x_lim[1]-x_lim[0])

                # 2. add individual adhesion events
                text_end_max = 0


                for i in range(0, len(self.adhesion_signatures['events'])):

                    text_end = self.data['retract'][self.keys['y_key']][self.adhesion_signatures['events'][i]['index'][0]]

                    if abs(text_end) > text_end_max:

                        text_end_max = abs(text_end)

                pos_text_y_list = list()

                for i in range(0, len(self.adhesion_signatures['events'])):

                    pos_text_y = i * 0.05 + 0.05
                    pos_text_y_list.append(pos_text_y)


                pos_text_y_list.reverse()
                text_final = str()

                for i in range(0, len(self.adhesion_signatures['events'])):

                    event_type = self.adhesion_signatures['events'][i]['status']

                    if event_type == 'confirmed':

                        color_line = (0,0.6,0)

                    elif event_type == 'unclear':

                        color_line = (0.6,0,0)

                    start_ind = self.adhesion_signatures['events'][i]['index'][0]
                    end_ind = self.adhesion_signatures['events'][i]['index'][1]

                    plot_x_start = self.data['retract'][self.keys['ts_key']][start_ind]
                    plot_x_end = self.data['retract'][self.keys['ts_key']][end_ind]
                    plot_y_start = self.data['retract'][self.keys['y_key']][start_ind]
                    plot_y_end = self.data['retract'][self.keys['y_key']][end_ind]


                    ax_exp.plot([plot_x_start-0.005*x_diff, plot_x_end+0.005*x_diff],[plot_y_start,plot_y_start], color = (0,0,0), linewidth = 0.5)
                    ax_exp.plot([plot_x_start-0.005*x_diff, plot_x_end+0.005*x_diff],[plot_y_end,plot_y_end], color = (0,0,0), linewidth = 0.5)
                    ax_exp.plot([plot_x_start, plot_x_start],[plot_y_start - 0.1*y_diff,plot_y_end], color = color_line, linewidth = 0.5)

                    text1 = '%.2e' % self.adhesion_signatures['events'][i]['magnitude'] + ' ' + self.adhesion_signatures['units']['force']['unit'] + ' '
                    text2 = ' %.2f' % self.adhesion_signatures['events'][i]['x_loc_start_ts_separation'] + ' ' + self.adhesion_signatures['units']['distance']['unit']
                    textstr = '('+str(i)+'): ' + text1 + u'\u0040' + text2

                    plt.text(plot_x_start - 0.015 *x_diff, plot_y_start - 0.135*y_diff, '('+str(i)+')', fontsize = 'x-small')


                    if i == len(self.adhesion_signatures['events'])-1:
                        text_final += textstr
                    else:
                        text_final += textstr + '\n'


                if len(self.adhesion_signatures['events']) <= 10:

                    bbox_args = dict(boxstyle="round", fc= (1,1,1))

                    ax_exp.annotate(text_final, xy=(.65, .05), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox=bbox_args)


                if not os.path.isdir(os.path.join(self.file_info['save_directory'], 'adhesion_signatures')):

                    os.makedirs(os.path.join(self.file_info['save_directory'], 'adhesion_signatures'))


                for f in fig_export:

                    filename = os.path.join(self.file_info['save_directory'], 'adhesion_signatures', 'adhesion_signatures_' + self.file_info['file_org'] + '.' + f)

                    try:

                         plt.savefig(filename)

                    except:

                          sys.stderr.write('ERROR! Cannot open/write file ' + filename)


                plt.close(fig_exp)

                plt.ion()


                if 'pkl' in fileformat:

                     try:

                        file_pickle = os.path.join(self.file_info['save_directory'], 'adhesion_signatures', 'adhesion_signatures_' + self.file_info['file_org'] + '.pkl')
                        out_pkl = open(file_pickle, 'wb')

                        pickle.dump(self.adhesion_signatures, out_pkl)

                     except:

                          sys.stderr.write('ERROR! Cannot open/write file ' + file_pickle)

                     finally:

                          out_pkl.close()



        else:

            raise ValueError('ERROR! Data are not prepared for analysis. Perform corrections first.')



    def get_slope_contact(self, frac_data = (0.95,1)):

        if self.control_variables['allow_analysis']:

            slope_ext, baseline_ext = np.polyfit(self.data['extend'][self.keys['ts_key']][int(self.settings['samples']['extend'] * frac_data[0]):int(self.settings['samples']['extend'] * frac_data[1])],
                                                 self.data['extend'][self.keys['y_key']][int(self.settings['samples']['extend'] * frac_data[0]):int(self.settings['samples']['extend'] * frac_data[1])],1)
            slope_ret, baseline_ret = np.polyfit(self.data['retract'][self.keys['ts_key']][-int(self.settings['samples']['retract'] * frac_data[1])-1:-int(self.settings['samples']['extend'] * frac_data[0])-1],
                                                 self.data['retract'][self.keys['y_key']][-int(self.settings['samples']['retract'] * frac_data[1])-1:-int(self.settings['samples']['extend'] * frac_data[0])-1],1)

#            ret_dict = dict()
#            ret_dict['results'] = dict()
#            ret_dict['results']['extend'] = {'slope': slope_ext, 'baseline': baseline_ext}
#            ret_dict['results']['retract'] = {'slope': slope_ret, 'baseline': baseline_ret}
#            ret_dict['parameter'] = dict()
#            ret_dict['parameter']['frac_data'] = frac_data
#            ret_dict = {'results': {'extend': {'slope': slope_ext, 'baseline': baseline_ext}, 'retract': {'slope': slope_ret, 'baseline': baseline_ret}}, 'parameters': {'frac_data': frac_data}}

            ret_dict = {'results': {'extend': {'slope': abs(slope_ext)}, 'retract': {'slope': abs(slope_ret)}}, 'parameter': {'frac_data': frac_data}}

            return ret_dict


        else:

            raise ValueError('ERROR! Data are not prepared for analysis. Perform corrections first.')




    def get_breakthrough_events(self, sensitivity = 1, start_fraction = 0.5, event_sep = 1, **kwargs):

        if self.control_variables['allow_analysis']:

            fac = 5 - math.log10(sensitivity)

            end_index = len(self.data['extend'][self.keys['ts_key']]) - 1
            i =  int((end_index + 1) * start_fraction)

            # 1. get list of potential events, every event where the deflection is smaller than before is a potential event
            events_potential = list()
            while i < end_index:

                j = 0
                # finds all the events were the deflection is reduced for consecutive points
                while i + j + 1 < end_index and self.data['extend'][self.keys['y_key']][i+j] > self.data['extend'][self.keys['y_key']][i+j+1]:

                    j += 1

                if j > 0:

                    events_potential.append((i,i+j))

                i = i + j + 1

            # 2. calculate magnitude for each potential event and remove all events that are too small
            events_new = list()

            for event in events_potential:

                diff = self.data['extend'][self.keys['y_key']][event[0]] - self.data['extend'][self.keys['y_key']][event[1]]

                if diff > self.noise_level['value'] * fac:

                    events_new.append(event)

            # 3. combine events

            if event_sep > 0:

                events_final = _Helper_Functions_General.combine_tuple(events_new, event_sep)

            else:

                events_final = events_new

            self.breakthrough_events['exists'] = bool(len(events_final))
            self.breakthrough_events['parameter'] = {'sensitivity': sensitivity, 'sensitivity_factor':fac, 'event_separation':event_sep}
            self.breakthrough_events['noise_level'] = self.noise_level['value']
            self.breakthrough_events['units'] = copy.deepcopy(self.units)
            self.breakthrough_events['events'] = dict()

            for i in range(len(events_final)):

                self.breakthrough_events['events'][i] = dict()
                self.breakthrough_events['events'][i]['index'] = events_final[i]
                self.breakthrough_events['events'][i]['indentation'] = (self.data['extend'][self.keys['ts_key']][events_final[i][0]],self.data['extend'][self.keys['ts_key']][events_final[i][1]])
                self.breakthrough_events['events'][i]['force'] = (self.data['extend'][self.keys['y_key']][events_final[i][0]],self.data['extend'][self.keys['y_key']][events_final[i][1]])
                self.breakthrough_events['events'][i]['magnitude'] = self.data['extend'][self.keys['y_key']][events_final[i][0]] - self.data['extend'][self.keys['y_key']][events_final[i][1]]
                self.breakthrough_events['events'][i]


            if 'plot_result' in kwargs and kwargs['plot_result']:

                if 'ax' in kwargs:

                    ax = kwargs['ax']

                else:

                    fig = plt.figure()
                    ax = fig.add_axes([0.15, 0.15, 0.75, 0.75])


                ax.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend')

                if 'retract_plot' in kwargs and kwargs['retract_plot']:

                    ax.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['y_key']], label = 'retract')


                if self.breakthrough_events['exists']:

                    if len(self.breakthrough_events['events']) == 1:
                        text0 = 'There is %d' % len(self.breakthrough_events['events']) + ' breakthrough event'
                    else:
                        text0 = 'There are %d' % len(self.breakthrough_events['events']) + ' breakthrough events'

                    text1 = 'Index: '
                    text2 = 'Location (' + self.breakthrough_events['units']['distance']['unit'] + ') : '
                    text3 = 'Magnitude (' + self.breakthrough_events['units']['force']['unit'] + ') : '

                    for i in self.breakthrough_events['events'].keys():

                        text1 = text1 + '%d' % self.breakthrough_events['events'][i]['index'][0] + ', '
                        text2 = text2 + '%.2f' % self.breakthrough_events['events'][i]['indentation'][0] + ', '
                        text3 = text3 + '%.3f' % self.breakthrough_events['events'][i]['magnitude'] + ', '

                        ax.plot(self.data['extend'][self.keys['ts_key']][self.breakthrough_events['events'][i]['index'][0]], self.data['extend'][self.keys['y_key']][self.breakthrough_events['events'][i]['index'][0]], marker = '_', color = 'red', markersize = 10, markerfacecolor = 'None')
                        ax.plot(self.data['extend'][self.keys['ts_key']][self.breakthrough_events['events'][i]['index'][1]], self.data['extend'][self.keys['y_key']][self.breakthrough_events['events'][i]['index'][1]], marker = '_', color = 'green', markersize = 10, markerfacecolor = 'None')

                    textstr = text0 + '\n'+ text1 + '\n'+ text2 + '\n' + text3

                else:

                    textstr = 'No breakthrough events found!'

                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                ax.legend()
                ax.tick_params(direction = 'in', top = True, right = True)

                bbox_args = dict(boxstyle="round", fc= (1,1,1))
                an1 = ax.annotate(textstr, xy=(.25, .965), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox=bbox_args, verticalalignment = 'top')
                an1.draggable()

            export = False

            if 'export_result' in kwargs:

                if type(kwargs['export_result']) is bool:

                    export = kwargs['export_result']
                    fileformat = ['svg', 'pdf', 'png', 'pkl']

                elif type(kwargs['export_result']) is str:

                    fileformat = [kwargs['export_result']]
                    export = True

                elif type(kwargs['export_result']) is list:

                    fileformat = kwargs['export_result']
                    export = True


            if export:

                plt.ioff()

                fig_export = [f for f in fileformat if f in ['svg', 'pdf', 'png']]

                fig_exp = plt.figure()
                ax_exp = fig_exp.add_axes([0.15, 0.15, 0.75, 0.75])

                ax_exp.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend')

                if 'retract_plot' in kwargs and kwargs['retract_plot']:

                    ax_exp.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['y_key']], label = 'retract')


                if self.breakthrough_events['exists']:

                    text0 = 'There are %d' % len(self.breakthrough_events['events']) + ' breakthrough events'
                    text1 = 'Index: '
                    text2 = 'Location (' + self.breakthrough_events['units']['distance']['unit'] + ') : '
                    text3 = 'Magnitude (' + self.breakthrough_events['units']['force']['unit'] + ') : '

                    for i in self.breakthrough_events['events'].keys():

                        text1 = text1 + '%d' % self.breakthrough_events['events'][i]['index'][0] + ', '
                        text2 = text2 + '%.2f' % self.breakthrough_events['events'][i]['indentation'][0] + ', '
                        text3 = text3 + '%.3f' % self.breakthrough_events['events'][i]['magnitude'] + ', '

                        ax_exp.plot(self.data['extend'][self.keys['ts_key']][self.breakthrough_events['events'][i]['index'][0]], self.data['extend'][self.keys['y_key']][self.breakthrough_events['events'][i]['index'][0]], marker = '_', color = 'red', markersize = 10, markerfacecolor = 'None')
                        ax_exp.plot(self.data['extend'][self.keys['ts_key']][self.breakthrough_events['events'][i]['index'][1]], self.data['extend'][self.keys['y_key']][self.breakthrough_events['events'][i]['index'][1]], marker = '_', color = 'green', markersize = 10, markerfacecolor = 'None')

                    textstr = text0 + '\n'+ text1 + '\n'+ text2 + '\n' + text3

                else:

                    textstr = 'No breakthrough events found!'

                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                ax_exp.legend()
                ax_exp.tick_params(direction = 'in', top = True, right = True)

                bbox_args = dict(boxstyle="round", fc= (1,1,1))
                ax_exp.annotate(textstr, xy=(.25, .965), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox=bbox_args, verticalalignment = 'top')


                if not os.path.isdir(os.path.join(self.file_info['save_directory'], 'breakthrough')):

                    os.makedirs(os.path.join(self.file_info['save_directory'], 'breakthrough'))


                for f in fig_export:

                    filename = os.path.join(self.file_info['save_directory'], 'breakthrough', 'breakthrough_' + self.file_info['file_org'] + '.' + f)

                    try:

                         plt.savefig(filename)

                    except:

                          sys.stderr.write('ERROR! Cannot open/write file ' + filename)


                plt.close(fig_exp)
                plt.ion()

                if 'pkl' in fileformat:

                    try:

                        file_pickle = os.path.join(self.file_info['save_directory'], 'breakthrough', 'breakthrough_' + self.file_info['file_org'] + '.pkl')
                        out_pkl = open(file_pickle, 'wb')
                        pickle.dump(self.breakthrough_events, out_pkl)

                    except:

                        sys.stderr.write('ERROR! Cannot open/write file ' + file_pickle)

                    finally:

                        out_pkl.close()

        else:

            raise ValueError('ERROR! Data are not prepared for analysis. Perform corrections first.')



                        # file_pickle = os.path.join(self.file_info['save_directory'], 'multi_layer_detection', 'multi_layer_detection_linear_' + self.file_info['file_org'] + '.pkl')
                        # out_pkl = open(file_pickle, 'wb')
                        #
                        # pickle.dump(self.multi_layer_hertz, out_pkl)
#%% fit models


    def fit_hertz_model(self, #fit_type = 'constrained',
                        mode = 'free_contact_point', #maybe use the method type parameter
                        residuals_baseline_weight = 0,
                        y_offset = 'zero',
                        distance_to_contact = 50, poisson_ratio = 0.5,
                        indenter_characteristics = {'geometry': 'parabolic', 'radius [nm]': 10},
                        max_indentation = np.inf, force_limit = np.inf, #threshold_sensitivity = 0,
                        min_fit_length = 20,
                        **kwargs):


        if self.control_variables['allow_analysis']:

            self.hertz_fit = dict()
            self.hertz_fit['indenter'] = indenter_characteristics

            self.hertz_fit['method'] = dict()
            #self.hertz_fit['method']['type'] = mode
            self.hertz_fit['method']['parameter'] = dict()
            self.hertz_fit['method']['parameter']['force_limit'] = force_limit
            self.hertz_fit['method']['parameter']['max_indentation'] = max_indentation
            self.hertz_fit['method']['parameter']['distance_to_contact'] = distance_to_contact
            self.hertz_fit['method']['parameter']['min_fit_length'] = min_fit_length
            #self.hertz_fit['method']['parameter']['threshold_sensitivity'] = threshold_sensitivity
            self.hertz_fit['method']['parameter']['residuals_baseline_weight'] = residuals_baseline_weight

            self.hertz_fit['filter'] = dict()
            self.hertz_fit['filter']['type'] = 'none'

            # make data sets with unit in nm and nN so that the fit is always in this units
            x_data = self.data['extend'][self.keys['ts_key']] / (1e-09 / self.units['distance']['factor'])
            y_data = self.data['extend'][self.keys['y_key']] / (1e-09 / self.units['force']['factor'])

            #min_force_threshold = threshold_sensitivity * np.std(self.data['extend'][self.keys['y_key']][0:int(self.settings['samples']['extend']*0.2)])

            if indenter_characteristics['geometry'] == 'parabolic':

                hertz_func_fit = parabolic_hertz_fit_new
                hertz_func = parabolic_hertz_new
                indenter_param = indenter_characteristics['radius [nm]']
                conv_list_paran = False
                e_modul_func = e_modul_parabolic

            elif indenter_characteristics['geometry'] == 'conical':

                hertz_func_fit = conical_hertz_fit_new
                hertz_func = conical_hertz_new
                indenter_param = indenter_characteristics['angle [grad]']
                conv_list_paran = False
                e_modul_func = e_modul_conical

            elif indenter_characteristics['geometry'] == 'cylindrical':

                hertz_func_fit = cylindrical_hertz_fit_new
                hertz_func = cylindrical_hertz_new
                indenter_param = indenter_characteristics['radius [nm]']
                conv_list_paran = False
                e_modul_func = e_modul_cylindrical

            elif indenter_characteristics['geometry'] == 'four-sided pyramid':

                hertz_func_fit = four_side_pyramid_hertz_fit_new
                hertz_func = four_side_pyramid_hertz_new
                indenter_param = indenter_characteristics['angle [grad]']
                conv_list_paran = False
                e_modul_func = e_modul_four_sided_pyramid

            elif indenter_characteristics['geometry'] == 'spherical':

                hertz_func_fit = spherical_hertz_fit_new
                hertz_func = spherical_hertz_new
                indenter_param = indenter_characteristics['radius [nm]']
                conv_list_paran = Conversion_List_Spherical_Indenter_Hertz(indenter_characteristics['radius [nm]'],1, int(max(x_data)-min(x_data))+10)
                e_modul_func = e_modul_spherical




            if mode not in ['free_contact_point','fixed_contact_point','constrained_contact_point']:

                mode = 'free_contact_point'


            if mode == 'free_contact_point':
                self.hertz_fit['method']['parameter']['mode'] = mode
                self.hertz_fit['method']['parameter']['y_offset'] = y_offset

                start_index = np.argmax(self.data['extend'][self.keys['ts_key']]<0) - distance_to_contact - 3

                res_i = np.ones(self.settings['samples']['extend'] - start_index - min_fit_length)
                fits = {'popt': list(), 'pcov': list(), 'residuals':list()}

                for i in range(self.settings['samples']['extend'] - start_index - min_fit_length):

                    i_shifted = i + start_index

                    contact_point_x = -x_data[i_shifted]

                    if y_offset == 'zero':

                        contact_point_y_offset = 0

                    elif y_offset == 'mean_contact_point':

                        contact_point_y_offset = np.mean(y_data[i_shifted-2:i_shifted+3])

                    else:

                        contact_point_y_offset = y_data[i_shifted]



                    end_fit_ind_max_ind = np.argmax(-x_data>contact_point_x + max_indentation)
                    end_fit_ind_max_force = np.argmax(y_data>force_limit + contact_point_y_offset)


                    if end_fit_ind_max_ind and end_fit_ind_max_force:

                        end_index = min(end_fit_ind_max_ind,end_fit_ind_max_force)

                    elif end_fit_ind_max_ind or end_fit_ind_max_force:

                        end_index = max(end_fit_ind_max_ind,end_fit_ind_max_force)

                    else:

                        end_index = self.settings['samples']['extend'] - 1

                    start_index_fit = i_shifted - distance_to_contact

                    #if np.mean(y_data[end_index-3:end_index+2]) - contact_point_y_offset > min_force_threshold:

                    popt, pcov = curve_fit(hertz_func_fit(contact_point_x, contact_point_y_offset, indenter_param, conv_list_paran), -x_data[start_index_fit:end_index], y_data[start_index_fit:end_index])
                    residuals = hertz_func(-x_data[start_index_fit:end_index], *popt, contact_point_x, contact_point_y_offset, indenter_param, conv_list_paran) - y_data[start_index_fit:end_index]

                    res_baseline = np.sum(np.absolute(residuals[0:distance_to_contact])) / len(residuals[0:distance_to_contact])
                    res_hertz = np.sum(np.absolute(residuals[distance_to_contact:])) / len(residuals[distance_to_contact:])
                    res_i[i] = res_hertz + res_baseline * residuals_baseline_weight

                    fits['popt'].append(popt)
                    fits['pcov'].append(pcov)
                    fits['residuals'].append(residuals)

                    #else:

                    #    res_i[i] = np.inf
                    #    fits['popt'].append(0)
                    #    fits['pcov'].append(0)
                    #    fits['residuals'].append(np.inf)

                res_i[np.isnan(res_i)] = np.inf

                min_index = np.argmin(res_i)
                contact_point = x_data[min_index + start_index]
                residuals = fits['residuals'][min_index]

                e_modul = e_modul_func(fits['popt'][min_index][0],poisson_ratio,indenter_param)

                best_fit_result = fits['popt'][min_index]

                #print(best_fit_result)

            elif mode == 'constrained_contact_point':

                print('not implemented yet')


            elif mode == 'fixed_contact_point':

                self.hertz_fit['method']['parameter']['mode'] = 'fixed_contact_point'
                self.hertz_fit['method']['parameter']['y_offset'] = 'zero'

                start_index = np.argmax(self.data['extend'][self.keys['ts_key']]<0) - 1

                res_i = np.ones(1)
                fits = {'popt': list(), 'pcov': list(), 'residuals':list()}


                contact_point_x = -x_data[start_index]
                contact_point_y_offset = 0




                end_fit_ind_max_ind = np.argmax(-x_data>contact_point_x + max_indentation)
                end_fit_ind_max_force = np.argmax(y_data>force_limit + contact_point_y_offset)


                if end_fit_ind_max_ind and end_fit_ind_max_force:

                    end_index = min(end_fit_ind_max_ind,end_fit_ind_max_force)

                elif end_fit_ind_max_ind or end_fit_ind_max_force:

                    end_index = max(end_fit_ind_max_ind,end_fit_ind_max_force)

                else:

                    end_index = self.settings['samples']['extend'] - 1

                start_index_fit = start_index

                #if np.mean(y_data[end_index-3:end_index+2]) - contact_point_y_offset > min_force_threshold:

                popt, pcov = curve_fit(hertz_func_fit(contact_point_x, contact_point_y_offset, indenter_param, conv_list_paran), -x_data[start_index_fit:end_index], y_data[start_index_fit:end_index])
                residuals = hertz_func(-x_data[start_index_fit:end_index], *popt, contact_point_x, contact_point_y_offset, indenter_param, conv_list_paran) - y_data[start_index_fit:end_index]

                res_baseline = np.sum(np.absolute(residuals[0:distance_to_contact])) / len(residuals[0:distance_to_contact])
                res_hertz = np.sum(np.absolute(residuals[distance_to_contact:])) / len(residuals[distance_to_contact:])
                res_i[0] = res_hertz + res_baseline * residuals_baseline_weight

                fits['popt'].append(popt)
                fits['pcov'].append(pcov)
                fits['residuals'].append(residuals)

                    #else:

                    #    res_i[i] = np.inf
                    #    fits['popt'].append(0)
                    #    fits['pcov'].append(0)
                    #    fits['residuals'].append(np.inf)


                min_index = np.argmin(res_i)
                contact_point = x_data[start_index]
                residuals = fits['residuals'][min_index]

                e_modul = e_modul_func(fits['popt'][min_index][0],poisson_ratio,indenter_param)

                best_fit_result = fits['popt'][min_index]



            self.hertz_fit['best_fit'] = dict()
            self.hertz_fit['best_fit']['index'] = (start_index + min_index,end_index)
            self.hertz_fit['best_fit']['interval'] = (self.data['extend'][self.keys['ts_key']][start_index + min_index],self.data['extend'][self.keys['ts_key']][end_index])
            self.hertz_fit['best_fit']['fit_parameter'] = fits['popt'][min_index][0]
            self.hertz_fit['best_fit']['contact_point'] = dict()
            self.hertz_fit['best_fit']['contact_point']['index'] = start_index + min_index
            self.hertz_fit['best_fit']['contact_point']['value'] = contact_point

            self.hertz_fit['residuals'] = dict()
            self.hertz_fit['residuals']['unit'] = 'nN'
            self.hertz_fit['residuals']['mean_fit'] = res_i[min_index]
            self.hertz_fit['residuals']['mean'] = np.mean(np.absolute(residuals[distance_to_contact:]))
            self.hertz_fit['residuals']['data'] = residuals

            self.hertz_fit['poisson_ratio'] = poisson_ratio
            #self.hertz_fit['fit_parameter'] = fits['popt'][min_index][0]
            #self.hertz_fit['residuals'] = residuals
            #self.hertz_fit['residuals_mean'] = res_i[min_index]
            #self.hertz_fit['residuals_unit'] = 'nN'
            self.hertz_fit['units'] = copy.deepcopy(self.units)

            e_modul = e_modul * 10**9
            e_modul_unit = 'Pa'
            e_modul_factor = 1

            self.hertz_fit['young_modulus'] = {'value': e_modul, 'unit': e_modul_unit, 'factor': e_modul_factor}

            retract_plot = False


            if 'retract_plot' in kwargs and kwargs['retract_plot']:

                retract_plot = True


            if 'plot_result' in kwargs and kwargs['plot_result']:

                text1 = 'Young\'s modulus: %.2f' % self.hertz_fit['young_modulus']['value'] + ' ' + self.hertz_fit['young_modulus']['unit'] + '\nContact point: ' +'%.2f' % self.hertz_fit['best_fit']['contact_point']['value'] + ' ' + self.hertz_fit['units']['distance']['unit']
                text2 = '\nFit index: (' + str(self.hertz_fit['best_fit']['index'][0]) +', ' + str(self.hertz_fit['best_fit']['index'][1])  + ')'
                text3 = '\nFit parameter: a = %.2e' % self.hertz_fit['best_fit']['fit_parameter']

                if indenter_characteristics['geometry'] in ['parabolic','cylindrical','spherical']:

                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'

                else:

                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Angle: ' +'%.2f' % indenter_characteristics['angle [grad]']+ ' grad'


                contact_point_x = -x_data[min_index+start_index]

                if y_offset == 'zero':

                    contact_point_y_offset = 0

                elif y_offset == 'mean_contact_point':

                    contact_point_y_offset = np.mean(y_data[min_index+start_index-2:min_index+start_index+3])

                else:

                    contact_point_y_offset = y_data[min_index+start_index]


                end_fit_ind_max_ind = np.argmax(-x_data>contact_point_x + max_indentation)
                end_fit_ind_max_force = np.argmax(y_data>force_limit + contact_point_y_offset)


                if end_fit_ind_max_ind and end_fit_ind_max_force:

                    end_index = min(end_fit_ind_max_ind,end_fit_ind_max_force)

                elif end_fit_ind_max_ind or end_fit_ind_max_force:

                    end_index = max(end_fit_ind_max_ind,end_fit_ind_max_force)

                else:

                    end_index = self.settings['samples']['extend'] - 1

                start_index_fit = start_index + min_index - distance_to_contact

                #y_fit = hertz_func(-x_data[start_index_fit:end_index], *fits['popt'][min_index], contact_point_x, contact_point_y_offset) * (1e-09 / self.units['force']['factor'], indenter_param, conv_list_paran)
                y_fit = hertz_func(-x_data[start_index_fit:end_index], *best_fit_result, contact_point_x, contact_point_y_offset, indenter_param, conv_list_paran) * (1e-09 / self.units['force']['factor'])


                x_plot = x_data[start_index_fit:end_index] * (1e-09 / self.units['distance']['factor'])
                textstr = text1 + text2 + text3 + text4

                if 'ax' in kwargs:

                    ax = kwargs['ax']

                else:

                    fig = plt.figure()
                    ax = fig.add_axes([0.15, 0.15, 0.75, 0.75])


                ax.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend', color = '#1f77b4ff')

                if retract_plot:

                    ax.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['y_key']], label = 'retract', color = '#ff7e0eff')

                ax.plot(x_plot, y_fit, label = 'hertz fit', color = '#ff053bff')

                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                ax.legend()
                ax.tick_params(direction = 'in', top = True, right = True)

                bbox_args = dict(boxstyle="round", fc= (1,1,1))
                an1 = ax.annotate(textstr, xy=(.4, .965), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox=bbox_args, verticalalignment = 'top')
                an1.draggable() #allows to drag the box arround



            export = False

            if 'export_result' in kwargs:

                if type(kwargs['export_result']) is bool:

                    export = kwargs['export_result']
                    fileformat = ['svg', 'pdf', 'png', 'txt', 'pkl']

                elif type(kwargs['export_result']) is str:

                    fileformat = [kwargs['export_result']]
                    export = True

                elif type(kwargs['export_result']) is list:

                    fileformat = kwargs['export_result']
                    export = True


            if export:

                text1 = 'Young\'s modulus: %.2f' % self.hertz_fit['young_modulus']['value'] + ' ' + self.hertz_fit['young_modulus']['unit'] + '\nContact point: ' +'%.2f' % self.hertz_fit['best_fit']['contact_point']['value'] + ' ' + self.hertz_fit['units']['distance']['unit']
                text2 = '\nFit index: (' + str(self.hertz_fit['best_fit']['index'][0]) +', ' + str(self.hertz_fit['best_fit']['index'][1])  + ')'
                text3 = '\nFit parameter: a = %.2e' % self.hertz_fit['best_fit']['fit_parameter']

                if indenter_characteristics['geometry'] in ['parabolic','cylindrical','spherical']:

                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'

                else:

                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Angle: ' +'%.2f' % indenter_characteristics['angle [grad]']+ ' grad'


                contact_point_x = -x_data[min_index+start_index]

                if y_offset == 'zero':

                    contact_point_y_offset = 0

                elif y_offset == 'mean_contact_point':

                    contact_point_y_offset = np.mean(y_data[min_index+start_index-2:min_index+start_index+3])

                else:

                    contact_point_y_offset = y_data[min_index+start_index]


                end_fit_ind_max_ind = np.argmax(-x_data>contact_point_x + max_indentation)
                end_fit_ind_max_force = np.argmax(y_data>force_limit + contact_point_y_offset)
                    #print(i, ':', force_limit + contact_point_y_offset, end_fit_ind_max_force, y_data_trunc[end_fit_ind_max_force])

                if end_fit_ind_max_ind and end_fit_ind_max_force:

                    end_index = min(end_fit_ind_max_ind,end_fit_ind_max_force)

                elif end_fit_ind_max_ind or end_fit_ind_max_force:

                    end_index = max(end_fit_ind_max_ind,end_fit_ind_max_force)

                else:

                    end_index = self.settings['samples']['extend'] - 1

                start_index_fit = start_index + min_index - distance_to_contact


                y_fit = hertz_func(-x_data[start_index_fit:end_index], best_fit_result, contact_point_x, contact_point_y_offset, indenter_param, conv_list_paran) * (1e-09 / self.units['force']['factor'])

                x_plot = x_data[start_index_fit:end_index] * (1e-09 / self.units['distance']['factor'])
                textstr = text1 + text2 + text3 + text4


                plt.ioff()
                #fig_formats = ['svg', 'pdf', 'png', 'jpg']
                fig_export = [f for f in fileformat if f in ['svg', 'pdf', 'png', 'jpg']]

                fig_exp = plt.figure()
                ax_exp = fig_exp.add_axes([0.15, 0.15, 0.75, 0.75])

                ax_exp.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend', color = '#1f77b4ff')

                if retract_plot:

                    ax_exp.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['ts_key']], label = 'retract', color = '#ff7e0eff')

                ax_exp.plot(x_plot, y_fit, label = 'hertz fit', color = '#ff053bff')

                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                ax_exp.legend()
                ax_exp.tick_params(direction = 'in', top = True, right = True)

                bbox_args = dict(boxstyle="round", fc= (1,1,1))
                ax_exp.annotate(textstr, xy=(.4, .965), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox=bbox_args, verticalalignment = 'top')



                if not os.path.isdir(os.path.join(self.file_info['save_directory'], 'hertz_fit')):

                    os.makedirs(os.path.join(self.file_info['save_directory'], 'hertz_fit'))


                for f in fig_export:

                    filename = os.path.join(self.file_info['save_directory'], 'hertz_fit', 'hertz_fit_' + self.file_info['file_org'] + '.' + f)

                    try:

                         plt.savefig(filename)

                    except:

                          sys.stderr.write('ERROR! Cannot open/write file ' + filename)


                plt.close(fig_exp)

                plt.ion()


                if 'pkl' in fileformat:

                     try:

                        file_pickle = os.path.join(self.file_info['save_directory'], 'hertz_fit', 'hertz_fit_' + self.file_info['file_org'] + '.pkl')
                        out_pkl = open(file_pickle, 'wb')

                        pickle.dump(self.hertz_fit, out_pkl)

                     except:

                          sys.stderr.write('ERROR! Cannot open/write file ' + file_pickle)

                     finally:

                          out_pkl.close()


        else:

            raise ValueError('ERROR! Data are not prepared for analysis. Perform corrections first.')





    def fit_hertz_model_old(self, #fit_type = 'constrained',
                        residuals_baseline_weight = 0,
                        y_offset = 'zero',
                        distance_to_contact = 50, poisson_ratio = 0.5,
                        indenter_characteristics = {'geometry': 'parabolic', 'radius [nm]': 10},
                        max_indentation = np.inf, force_limit = np.inf, threshold_sensitivity = 0,
                        **kwargs):


        if self.control_variables['allow_analysis']:

            self.hertz_fit = dict()
            self.hertz_fit['indenter'] = indenter_characteristics

            self.hertz_fit['method'] = dict()
            self.hertz_fit['method']['type'] = 'standard'
            self.hertz_fit['method']['parameter'] = dict()
            self.hertz_fit['method']['parameter']['force_limit'] = force_limit
            self.hertz_fit['method']['parameter']['max_indentation'] = max_indentation
            self.hertz_fit['method']['parameter']['distance_to_contact'] = distance_to_contact
            self.hertz_fit['method']['parameter']['threshold_sensitivity'] = threshold_sensitivity
            self.hertz_fit['method']['parameter']['residuals_baseline_weight'] = residuals_baseline_weight

            self.hertz_fit['filter'] = dict()
            self.hertz_fit['filter']['type'] = 'none'

            #self.hertz_fit['range_selection'] = dict()
            #self.hertz_fit['range_selection']['method'] = 'automatic'
            #self.hertz_fit['range_selection']['force_limit'] = force_limit
            #self.hertz_fit['range_selection']['max_indentation'] = max_indentation

            start_index = np.argmax(self.data['extend'][self.keys['ts_key']]<0) - distance_to_contact - 3
            # make data sets with unit in nm and nN so that the fit is always in this units
            x_data = self.data['extend'][self.keys['ts_key']] / (1e-09 / self.units['distance']['factor'])
            y_data = self.data['extend'][self.keys['y_key']] / (1e-09 / self.units['force']['factor'])

            min_force_threshold = threshold_sensitivity * np.std(self.data['extend'][self.keys['y_key']][0:int(self.settings['samples']['extend']*0.2)])

            if indenter_characteristics['geometry'] == 'parabolic':

                res_i = np.ones(self.settings['samples']['extend'] - start_index - 10)
                fits = {'popt': list(), 'pcov': list(), 'residuals':list()}

                for i in range(self.settings['samples']['extend'] - start_index - 10):

                    i_shifted = i + start_index

                    contact_point_x = -x_data[i_shifted]

                    if y_offset == 'zero':

                        contact_point_y_offset = 0

                    elif y_offset == 'mean_contact_point':

                        contact_point_y_offset = np.mean(y_data[i_shifted-2:i_shifted+3])

                    else:

                        contact_point_y_offset = y_data[i_shifted]



                    end_fit_ind_max_ind = np.argmax(-x_data>contact_point_x + max_indentation)
                    end_fit_ind_max_force = np.argmax(y_data>force_limit + contact_point_y_offset)


                    if end_fit_ind_max_ind and end_fit_ind_max_force:

                        end_index = min(end_fit_ind_max_ind,end_fit_ind_max_force)

                    elif end_fit_ind_max_ind or end_fit_ind_max_force:

                        end_index = max(end_fit_ind_max_ind,end_fit_ind_max_force)

                    else:

                        end_index = self.settings['samples']['extend'] - 1

                    start_index_fit = i_shifted - distance_to_contact

                    if np.mean(y_data[end_index-3:end_index+2]) - contact_point_y_offset > min_force_threshold:

                        popt, pcov = curve_fit(parabolic_hertz_fit(contact_point_x, contact_point_y_offset), -x_data[start_index_fit:end_index], y_data[start_index_fit:end_index])
                        residuals = parabolic_hertz(-x_data[start_index_fit:end_index], *popt, contact_point_x, contact_point_y_offset) - y_data[start_index_fit:end_index]

                        res_baseline = np.sum(np.absolute(residuals[0:distance_to_contact])) / len(residuals[0:distance_to_contact])
                        res_hertz = np.sum(np.absolute(residuals[distance_to_contact:])) / len(residuals[distance_to_contact:])
                        res_i[i] = res_hertz + res_baseline * residuals_baseline_weight

                        fits['popt'].append(popt)
                        fits['pcov'].append(pcov)
                        fits['residuals'].append(residuals)

                    else:

                        res_i[i] = np.inf
                        fits['popt'].append(0)
                        fits['pcov'].append(0)
                        fits['residuals'].append(np.inf)

                res_i[np.isnan(res_i)] = np.inf

                min_index = np.argmin(res_i)
                contact_point = x_data[min_index + start_index]
                residuals = fits['residuals'][min_index]

                e_modul = fits['popt'][min_index][0] * (1 - poisson_ratio**2) * 3 / (4 * math.sqrt(indenter_characteristics['radius [nm]']))


            elif indenter_characteristics['geometry'] == 'conical':


                res_i = np.ones(self.settings['samples']['extend'] - start_index - 10)
                fits = {'popt': list(), 'pcov': list(), 'residuals':list()}

                for i in range(self.settings['samples']['extend'] - start_index - 10):

                    i_shifted = i + start_index

                    contact_point_x = -x_data[i_shifted]

                    if y_offset == 'zero':

                        contact_point_y_offset = 0

                    elif y_offset == 'mean_contact_point':

                        contact_point_y_offset = np.mean(y_data[i_shifted-2:i_shifted+3])

                    else:

                        contact_point_y_offset = y_data[i_shifted]


                    end_fit_ind_max_ind = np.argmax(-x_data>contact_point_x + max_indentation)
                    end_fit_ind_max_force = np.argmax(y_data>force_limit + contact_point_y_offset)


                    if end_fit_ind_max_ind and end_fit_ind_max_force:

                        end_index = min(end_fit_ind_max_ind,end_fit_ind_max_force)

                    elif end_fit_ind_max_ind or end_fit_ind_max_force:

                        end_index = max(end_fit_ind_max_ind,end_fit_ind_max_force)

                    else:

                        end_index = self.settings['samples']['extend'] - 1

                    start_index_fit = i_shifted - distance_to_contact

                    if np.mean(y_data[end_index-3:end_index+2]) - contact_point_y_offset > min_force_threshold:

                        popt, pcov = curve_fit(conical_hertz_fit(contact_point_x, contact_point_y_offset), -x_data[start_index_fit:end_index], y_data[start_index_fit:end_index])
                        residuals = conical_hertz(-x_data[start_index_fit:end_index], *popt, contact_point_x, contact_point_y_offset) - y_data[start_index_fit:end_index]

                        res_baseline = np.sum(np.absolute(residuals[0:distance_to_contact])) / len(residuals[0:distance_to_contact])
                        res_hertz = np.sum(np.absolute(residuals[distance_to_contact:])) / len(residuals[distance_to_contact:])
                        res_i[i] = res_hertz + res_baseline * residuals_baseline_weight

                        fits['popt'].append(popt)
                        fits['pcov'].append(pcov)
                        fits['residuals'].append(residuals)

                    else:

                        res_i[i] = np.inf
                        fits['popt'].append(0)
                        fits['pcov'].append(0)
                        fits['residuals'].append(np.inf)

                res_i[np.isnan(res_i)] = np.inf

                min_index = np.argmin(res_i)
                contact_point = x_data[min_index + start_index]
                residuals = fits['residuals'][min_index]

                e_modul = fits['popt'][min_index][0] * (1 - poisson_ratio**2) * np.pi / (2 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))


            elif indenter_characteristics['geometry'] == 'four-sided pyramid':

                res_i = np.ones(self.settings['samples']['extend'] - start_index - 10)
                fits = {'popt': list(), 'pcov': list(), 'residuals':list()}

                for i in range(self.settings['samples']['extend'] - start_index - 10):

                    i_shifted = i + start_index

                    contact_point_x = -x_data[i_shifted]

                    if y_offset == 'zero':

                        contact_point_y_offset = 0

                    elif y_offset == 'mean_contact_point':

                        contact_point_y_offset = np.mean(y_data[i_shifted-2:i_shifted+3])

                    else:

                        contact_point_y_offset = y_data[i_shifted]

                    end_fit_ind_max_ind = np.argmax(-x_data>contact_point_x + max_indentation)
                    end_fit_ind_max_force = np.argmax(y_data>force_limit + contact_point_y_offset)


                    if end_fit_ind_max_ind and end_fit_ind_max_force:

                        end_index = min(end_fit_ind_max_ind,end_fit_ind_max_force)

                    elif end_fit_ind_max_ind or end_fit_ind_max_force:

                        end_index = max(end_fit_ind_max_ind,end_fit_ind_max_force)

                    else:

                        end_index = self.settings['samples']['extend'] - 1

                    start_index_fit = i_shifted - distance_to_contact

                    if np.mean(y_data[end_index-5:end_index]) - contact_point_y_offset > min_force_threshold:


                        popt, pcov = curve_fit(four_side_pyramid_hertz_fit(contact_point_x, contact_point_y_offset), -x_data[start_index_fit:end_index], y_data[start_index_fit:end_index])
                        residuals = four_side_pyramid_hertz(-x_data[start_index_fit:end_index], *popt, contact_point_x, contact_point_y_offset) - y_data[start_index_fit:end_index]

                        res_baseline = np.sum(np.absolute(residuals[0:distance_to_contact])) / len(residuals[0:distance_to_contact])
                        res_hertz = np.sum(np.absolute(residuals[distance_to_contact:])) / len(residuals[distance_to_contact:])
                        res_i[i] = res_hertz + res_baseline * residuals_baseline_weight

                        fits['popt'].append(popt)
                        fits['pcov'].append(pcov)
                        fits['residuals'].append(residuals)



                    else:

                        res_i[i] = np.inf
                        fits['popt'].append(0)
                        fits['pcov'].append(0)
                        fits['residuals'].append(np.inf)


                res_i[np.isnan(res_i)] = np.inf

                min_index = np.argmin(res_i)
                contact_point = x_data[min_index + start_index]
                residuals = fits['residuals'][min_index]

                e_modul = fits['popt'][min_index][0] * (1 - poisson_ratio**2) / (0.7453 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))


            elif indenter_characteristics['geometry'] == 'cylindrical':

                res_i = np.ones(self.settings['samples']['extend'] - start_index - 10)
                fits = {'popt': list(), 'pcov': list(), 'residuals':list()}

                for i in range(self.settings['samples']['extend'] - start_index - 10):

                    i_shifted = i + start_index

                    contact_point_x = -x_data[i_shifted]

                    if y_offset == 'zero':

                        contact_point_y_offset = 0

                    elif y_offset == 'mean_contact_point':

                        contact_point_y_offset = np.mean(y_data[i_shifted-2:i_shifted+3])

                    else:

                        contact_point_y_offset = y_data[i_shifted]

                    end_fit_ind_max_ind = np.argmax(-x_data>contact_point_x + max_indentation)
                    end_fit_ind_max_force = np.argmax(y_data>force_limit + contact_point_y_offset)


                    if end_fit_ind_max_ind and end_fit_ind_max_force:

                        end_index = min(end_fit_ind_max_ind,end_fit_ind_max_force)

                    elif end_fit_ind_max_ind or end_fit_ind_max_force:

                        end_index = max(end_fit_ind_max_ind,end_fit_ind_max_force)

                    else:

                        end_index = self.settings['samples']['extend'] - 1

                    start_index_fit = i_shifted - distance_to_contact

                    if np.mean(y_data[end_index-3:end_index+2]) - contact_point_y_offset > min_force_threshold:

                        popt, pcov = curve_fit(cylindrical_hertz_fit(contact_point_x, contact_point_y_offset), -x_data[start_index_fit:end_index], y_data[start_index_fit:end_index])
                        residuals = cylindrical_hertz(-x_data[start_index_fit:end_index], *popt, contact_point_x, contact_point_y_offset) - y_data[start_index_fit:end_index]

                        res_baseline = np.sum(np.absolute(residuals[0:distance_to_contact])) / len(residuals[0:distance_to_contact])
                        res_hertz = np.sum(np.absolute(residuals[distance_to_contact:])) / len(residuals[distance_to_contact:])
                        res_i[i] = res_hertz + res_baseline * residuals_baseline_weight

                        fits['popt'].append(popt)
                        fits['pcov'].append(pcov)
                        fits['residuals'].append(residuals)

                    else:

                        res_i[i] = np.inf
                        fits['popt'].append(0)
                        fits['pcov'].append(0)
                        fits['residuals'].append(np.inf)

                res_i[np.isnan(res_i)] = np.inf

                min_index = np.argmin(res_i)
                contact_point = x_data[min_index + start_index]
                residuals = fits['residuals'][min_index]

                e_modul = fits['popt'][min_index][0] * (1 - poisson_ratio**2) / (2 * indenter_characteristics['radius [nm]'])


            elif indenter_characteristics['geometry'] == 'spherical':

                res_i = np.ones(self.settings['samples']['extend'] - start_index - 10)
                fits = {'popt': list(), 'pcov': list(), 'residuals':list()}

                conv_list = Conversion_List_Spherical_Indenter_Hertz(indenter_characteristics['radius [nm]'],1, int(max(x_data)-min(x_data))+10)

                for i in range(self.settings['samples']['extend'] - start_index - 10):

                    i_shifted = i + start_index

                    contact_point_x = -x_data[i_shifted]

                    if y_offset == 'zero':

                        contact_point_y_offset = 0

                    elif y_offset == 'mean_contact_point':

                        contact_point_y_offset = np.mean(y_data[i_shifted-2:i_shifted+3])

                    else:

                        contact_point_y_offset = y_data[i_shifted]


                    end_fit_ind_max_ind = np.argmax(-x_data>contact_point_x + max_indentation)
                    end_fit_ind_max_force = np.argmax(y_data>force_limit + contact_point_y_offset)


                    if end_fit_ind_max_ind and end_fit_ind_max_force:

                        end_index = min(end_fit_ind_max_ind,end_fit_ind_max_force)

                    elif end_fit_ind_max_ind or end_fit_ind_max_force:

                        end_index = max(end_fit_ind_max_ind,end_fit_ind_max_force)

                    else:

                        end_index = self.settings['samples']['extend'] - 1

                    start_index_fit = i_shifted - distance_to_contact

                    if np.mean(y_data[end_index-3:end_index+2]) - contact_point_y_offset > min_force_threshold:

                        popt, pcov = curve_fit(spherical_hertz_fit(contact_point_x, contact_point_y_offset, indenter_characteristics['radius [nm]'], conv_list), -x_data[start_index_fit:end_index], y_data[start_index_fit:end_index])
                        residuals = spherical_hertz(-x_data[start_index_fit:end_index], *popt, contact_point_x, contact_point_y_offset, indenter_characteristics['radius [nm]'], conv_list) - y_data[start_index_fit:end_index]

                        res_baseline = np.sum(np.absolute(residuals[0:distance_to_contact])) / len(residuals[0:distance_to_contact])
                        res_hertz = np.sum(np.absolute(residuals[distance_to_contact:])) / len(residuals[distance_to_contact:])
                        res_i[i] = res_hertz + res_baseline * residuals_baseline_weight

                        fits['popt'].append(popt)
                        fits['pcov'].append(pcov)
                        fits['residuals'].append(residuals)

                    else:

                        res_i[i] = np.inf
                        fits['popt'].append(0)
                        fits['pcov'].append(0)
                        fits['residuals'].append(np.inf)

                res_i[np.isnan(res_i)] = np.inf

                min_index = np.argmin(res_i)
                contact_point = x_data[min_index + start_index]
                residuals = fits['residuals'][min_index]

                e_modul = fits['popt'][min_index][0] * (1 - poisson_ratio**2)


            self.hertz_fit['best_fit'] = dict()
            self.hertz_fit['best_fit']['index'] = (start_index + min_index,end_index)
            self.hertz_fit['best_fit']['interval'] = (self.data['extend'][self.keys['ts_key']][start_index + min_index],self.data['extend'][self.keys['ts_key']][end_index])
            self.hertz_fit['best_fit']['fit_parameter'] = fits['popt'][min_index][0]
            self.hertz_fit['best_fit']['contact_point'] = dict()
            self.hertz_fit['best_fit']['contact_point']['index'] = start_index + min_index
            self.hertz_fit['best_fit']['contact_point']['value'] = contact_point

            #self.hertz_fit['best_fit_index'] = (start_index + min_index,end_index)
            #self.hertz_fit['best_fit_interval'] = (self.data['extend'][self.keys['ts_key']][start_index + min_index],self.data['extend'][self.keys['ts_key']][end_index])
            #self.hertz_fit['contact_point'] = contact_point
            #self.hertz_fit['contact_point_index'] = start_index + min_index

            self.hertz_fit['residuals'] = dict()
            self.hertz_fit['residuals']['unit'] = 'nN'
            self.hertz_fit['residuals']['mean_fit'] = res_i[min_index]
            self.hertz_fit['residuals']['mean'] = np.mean(np.absolute(residuals[distance_to_contact:]))
            self.hertz_fit['residuals']['data'] = residuals

            self.hertz_fit['poisson_ratio'] = poisson_ratio
            #self.hertz_fit['fit_parameter'] = fits['popt'][min_index][0]
            #self.hertz_fit['residuals'] = residuals
            #self.hertz_fit['residuals_mean'] = res_i[min_index]
            #self.hertz_fit['residuals_unit'] = 'nN'
            self.hertz_fit['units'] = copy.deepcopy(self.units)

            e_modul = e_modul * 10**9
            e_modul_unit = 'Pa'
            e_modul_factor = 1

            self.hertz_fit['young_modulus'] = {'value': e_modul, 'unit': e_modul_unit, 'factor': e_modul_factor}

            retract_plot = False


            if 'retract_plot' in kwargs and kwargs['retract_plot']:

                retract_plot = True


            if 'plot_result' in kwargs and kwargs['plot_result']:

                text1 = 'Young\'s modulus: %.2f' % self.hertz_fit['young_modulus']['value'] + ' ' + self.hertz_fit['young_modulus']['unit'] + '\nContact point: ' +'%.2f' % self.hertz_fit['best_fit']['contact_point']['value'] + ' ' + self.hertz_fit['units']['distance']['unit']
                text2 = '\nFit index: (' + str(self.hertz_fit['best_fit']['index'][0]) +', ' + str(self.hertz_fit['best_fit']['index'][1])  + ')'
                text3 = '\nFit parameter: a = %.2e' % self.hertz_fit['best_fit']['fit_parameter']

                contact_point_x = -x_data[min_index+start_index]

                if y_offset == 'zero':

                    contact_point_y_offset = 0

                elif y_offset == 'mean_contact_point':

                    contact_point_y_offset = np.mean(y_data[min_index+start_index-2:min_index+start_index+3])

                else:

                    contact_point_y_offset = y_data[min_index+start_index]


                end_fit_ind_max_ind = np.argmax(-x_data>contact_point_x + max_indentation)
                end_fit_ind_max_force = np.argmax(y_data>force_limit + contact_point_y_offset)
                    #print(i, ':', force_limit + contact_point_y_offset, end_fit_ind_max_force, y_data_trunc[end_fit_ind_max_force])

                if end_fit_ind_max_ind and end_fit_ind_max_force:

                    end_index = min(end_fit_ind_max_ind,end_fit_ind_max_force)

                elif end_fit_ind_max_ind or end_fit_ind_max_force:

                    end_index = max(end_fit_ind_max_ind,end_fit_ind_max_force)

                else:

                    end_index = self.settings['samples']['extend'] - 1

                start_index_fit = start_index + min_index - distance_to_contact



                if indenter_characteristics['geometry'] == 'parabolic':

                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'
                    y_fit = parabolic_hertz(-x_data[start_index_fit:end_index], *fits['popt'][min_index], contact_point_x, contact_point_y_offset) * (1e-09 / self.units['force']['factor'])

                elif indenter_characteristics['geometry'] == 'conical':

                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Angle: ' +'%.2f' % indenter_characteristics['angle [grad]']+ ' grad'
                    y_fit = conical_hertz(-x_data[start_index_fit:end_index], *fits['popt'][min_index], contact_point_x, contact_point_y_offset) * (1e-09 / self.units['force']['factor'])

                elif indenter_characteristics['geometry'] == 'four-sided pyramid':

                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Angle: ' +'%.2f' % indenter_characteristics['angle [grad]']+ ' grad'
                    y_fit = four_side_pyramid_hertz(-x_data[start_index_fit:end_index], *fits['popt'][min_index], contact_point_x, contact_point_y_offset) * (1e-09 / self.units['force']['factor'])

                elif indenter_characteristics['geometry'] == 'cylindrical':

                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'
                    y_fit = cylindrical_hertz(-x_data[start_index_fit:end_index], *fits['popt'][min_index], contact_point_x, contact_point_y_offset) * (1e-09 / self.units['force']['factor'])

                elif indenter_characteristics['geometry'] == 'spherical':

                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'
                    y_fit = spherical_hertz(-x_data[start_index_fit:end_index], *fits['popt'][min_index], contact_point_x, contact_point_y_offset, indenter_characteristics['radius [nm]'], conv_list) * (1e-09 / self.units['force']['factor'])


                x_plot = x_data[start_index_fit:end_index] * (1e-09 / self.units['distance']['factor'])
                textstr = text1 + text2 + text3 + text4


                fig = plt.figure()
                ax = fig.add_axes([0.15, 0.15, 0.75, 0.75])

                ax.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend', color = '#1f77b4ff')

                if retract_plot:

                    ax.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['y_key']], label = 'retract', color = '#ff7e0eff')

                ax.plot(x_plot, y_fit, label = 'hertz fit', color = '#ff053bff')

                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                ax.legend()
                ax.tick_params(direction = 'in', top = True, right = True)

                bbox_args = dict(boxstyle="round", fc= (1,1,1))
                an1 = ax.annotate(textstr, xy=(.4, .7), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox=bbox_args)
                an1.draggable() #allows to drag the box arround



            export = False

            if 'export_result' in kwargs:

                if type(kwargs['export_result']) is bool:

                    export = kwargs['export_result']
                    fileformat = ['svg', 'pdf', 'png', 'txt', 'pkl']

                elif type(kwargs['export_result']) is str:

                    fileformat = [kwargs['export_result']]
                    export = True

                elif type(kwargs['export_result']) is list:

                    fileformat = kwargs['export_result']
                    export = True


            if export:

                text1 = 'Young\'s modulus: %.2f' % self.hertz_fit['young_modulus']['value'] + ' ' + self.hertz_fit['young_modulus']['unit'] + '\nContact point: ' +'%.2f' % self.hertz_fit['best_fit']['contact_point']['value'] + ' ' + self.hertz_fit['units']['distance']['unit']
                text2 = '\nFit index: (' + str(self.hertz_fit['best_fit']['index'][0]) +', ' + str(self.hertz_fit['best_fit']['index'][1])  + ')'
                text3 = '\nFit parameter: a = %.2e' % self.hertz_fit['best_fit']['fit_parameter']

                contact_point_x = -x_data[min_index+start_index]

                if y_offset == 'zero':

                    contact_point_y_offset = 0

                elif y_offset == 'mean_contact_point':

                    contact_point_y_offset = np.mean(y_data[min_index+start_index-2:min_index+start_index+3])

                else:

                    contact_point_y_offset = y_data[min_index+start_index]


                end_fit_ind_max_ind = np.argmax(-x_data>contact_point_x + max_indentation)
                end_fit_ind_max_force = np.argmax(y_data>force_limit + contact_point_y_offset)
                    #print(i, ':', force_limit + contact_point_y_offset, end_fit_ind_max_force, y_data_trunc[end_fit_ind_max_force])

                if end_fit_ind_max_ind and end_fit_ind_max_force:

                    end_index = min(end_fit_ind_max_ind,end_fit_ind_max_force)

                elif end_fit_ind_max_ind or end_fit_ind_max_force:

                    end_index = max(end_fit_ind_max_ind,end_fit_ind_max_force)

                else:

                    end_index = self.settings['samples']['extend'] - 1

                start_index_fit = start_index + min_index - distance_to_contact


                if indenter_characteristics['geometry'] == 'parabolic':

                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'
                    y_fit = parabolic_hertz(-x_data[start_index_fit:end_index], *fits['popt'][min_index], contact_point_x, contact_point_y_offset) * (1e-09 / self.units['force']['factor'])

                elif indenter_characteristics['geometry'] == 'conical':

                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Angle: ' +'%.2f' % indenter_characteristics['angle [grad]']+ ' grad'
                    y_fit = conical_hertz(-x_data[start_index_fit:end_index], *fits['popt'][min_index], contact_point_x, contact_point_y_offset) * (1e-09 / self.units['force']['factor'])

                elif indenter_characteristics['geometry'] == 'four-sided pyramid':

                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Angle: ' +'%.2f' % indenter_characteristics['angle [grad]']+ ' grad'
                    y_fit = four_side_pyramid_hertz(-x_data[start_index_fit:end_index], *fits['popt'][min_index], contact_point_x, contact_point_y_offset) * (1e-09 / self.units['force']['factor'])

                elif indenter_characteristics['geometry'] == 'cylindrical':

                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'
                    y_fit = cylindrical_hertz(-x_data[start_index_fit:end_index], *fits['popt'][min_index], contact_point_x, contact_point_y_offset) * (1e-09 / self.units['force']['factor'])

                elif indenter_characteristics['geometry'] == 'spherical':

                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'
                    y_fit = spherical_hertz(-x_data[start_index_fit:end_index], *fits['popt'][min_index], contact_point_x, contact_point_y_offset, indenter_characteristics['radius [nm]'], conv_list) * (1e-09 / self.units['force']['factor'])


                x_plot = x_data[start_index_fit:end_index] * (1e-09 / self.units['distance']['factor'])
                textstr = text1 + text2 + text3 + text4


                plt.ioff()
                #fig_formats = ['svg', 'pdf', 'png', 'jpg']
                fig_export = [f for f in fileformat if f in ['svg', 'pdf', 'png', 'jpg']]

                fig_exp = plt.figure()
                ax_exp = fig_exp.add_axes([0.15, 0.15, 0.75, 0.75])

                ax_exp.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend', color = '#1f77b4ff')

                if retract_plot:

                    ax_exp.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['ts_key']], label = 'retract', color = '#ff7e0eff')

                ax_exp.plot(x_plot, y_fit, label = 'hertz fit', color = '#ff053bff')

                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                ax_exp.legend()
                ax_exp.tick_params(direction = 'in', top = True, right = True)

                bbox_args = dict(boxstyle="round", fc= (1,1,1))
                ax_exp.annotate(textstr, xy=(.4, .7), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox=bbox_args)


                if not os.path.isdir(os.path.join(self.file_info['save_directory'], 'hertz_fit')):

                    os.makedirs(os.path.join(self.file_info['save_directory'], 'hertz_fit'))


                for f in fig_export:

                    filename = os.path.join(self.file_info['save_directory'], 'hertz_fit', 'hertz_fit_' + self.file_info['file_org'] + '.' + f)

                    try:

                         plt.savefig(filename)

                    except:

                          sys.stderr.write('ERROR! Cannot open/write file ' + filename)


                plt.close(fig_exp)

                plt.ion()


                if 'pkl' in fileformat:

                     try:

                        file_pickle = os.path.join(self.file_info['save_directory'], 'hertz_fit', 'hertz_fit_' + self.file_info['file_org'] + '.pkl')
                        out_pkl = open(file_pickle, 'wb')

                        pickle.dump(self.hertz_fit, out_pkl)

                     except:

                          sys.stderr.write('ERROR! Cannot open/write file ' + file_pickle)

                     finally:

                          out_pkl.close()


        else:

            raise ValueError('ERROR! Data are not prepared for analysis. Perform corrections first.')







    def fit_linearized_hertz_model(self,
                        poisson_ratio = 0.5,
                        indenter_characteristics = {'geometry': 'parabolic', 'radius [nm]': 10},
                        transition_sensitivity = 1,
                        stop_at_transition = True,
                        filter_correction_fraction = 0.5,
                        **kwargs):

        layer1_parameters = {'start_fit_length': 'automatic',
                             'savgol_filter_characteristics': {'length': 51, 'order': 1, 'deriv': 0, 'delta': 1.0, 'axis': -1, 'mode': 'interp', 'cval': 0.0},
                             'r_squared_limit':  0.98,
                             'residual_sensitivity': 1,
                             'final_fit_fraction': 0.8,
                             'with_residuals': True}


        if 'layer1_parameters' in kwargs:

            for key in kwargs['layer1_parameters'].keys():

                layer1_parameters[key] = kwargs['layer1_parameters'][key]




        residual_fac_layer1 = 5 - math.log10(layer1_parameters['residual_sensitivity'])
        transition_fac = 5 - math.log10(transition_sensitivity)



        if self.control_variables['allow_analysis']:

            self.linearized_hertz_fit = dict()
            self.linearized_hertz_fit['indenter'] = indenter_characteristics

            self.linearized_hertz_fit['method'] = dict()
            self.linearized_hertz_fit['method']['type'] = 'linear'
            self.linearized_hertz_fit['method']['parameter'] = dict()
            self.linearized_hertz_fit['method']['parameter']['transition_sensitivity'] = transition_sensitivity
            self.linearized_hertz_fit['method']['parameter']['transition_factor'] = transition_fac
            self.linearized_hertz_fit['method']['parameter']['stop_at_transition'] = stop_at_transition

            self.linearized_hertz_fit['method']['parameter']['layer1'] = dict()
            self.linearized_hertz_fit['method']['parameter']['layer1']['r_squared_limit'] = layer1_parameters['r_squared_limit']
            self.linearized_hertz_fit['method']['parameter']['layer1']['with_residuals'] = layer1_parameters['with_residuals']
            self.linearized_hertz_fit['method']['parameter']['layer1']['residual_sensitivity'] = layer1_parameters['residual_sensitivity']
            self.linearized_hertz_fit['method']['parameter']['layer1']['residual_factor'] = residual_fac_layer1
            self.linearized_hertz_fit['method']['parameter']['layer1']['final_fit_fraction'] = layer1_parameters['final_fit_fraction']


            self.linearized_hertz_fit['filter'] = dict()
            self.linearized_hertz_fit['filter']['type'] = 'savitzky-golay'
            self.linearized_hertz_fit['filter']['parameter'] = dict()
            self.linearized_hertz_fit['filter']['parameter']['length'] = layer1_parameters['savgol_filter_characteristics']['length']
            self.linearized_hertz_fit['filter']['parameter']['order'] = layer1_parameters['savgol_filter_characteristics']['order']

            self.linearized_hertz_fit['best_fit'] = dict()
            self.linearized_hertz_fit['residuals'] = dict()
            self.linearized_hertz_fit['young_modulus'] = dict()

            x_data = self.data['extend'][self.keys['ts_key']] / (1e-09 / self.units['distance']['factor'])
            y_data = self.data['extend'][self.keys['y_key']] / (1e-09 / self.units['force']['factor'])
            noise_lvl_adapted = self.noise_level['value'] / (1e-09 / self.units['force']['factor'])
            # 1. smooth data
            y_data_savgol_layer1 = savgol_filter(y_data,layer1_parameters['savgol_filter_characteristics']['length'],
                                                 layer1_parameters['savgol_filter_characteristics']['order'],
                                                 deriv = layer1_parameters['savgol_filter_characteristics']['deriv'],
                                                 delta = layer1_parameters['savgol_filter_characteristics']['delta'],
                                                 axis = layer1_parameters['savgol_filter_characteristics']['axis'],
                                                 mode = layer1_parameters['savgol_filter_characteristics']['mode'],
                                                 cval = layer1_parameters['savgol_filter_characteristics']['cval'])


            # 2. find "transition" point where smoothing does not work anymore
            diff_data = y_data - y_data_savgol_layer1
            diff_data_std = np.std(diff_data[0:int(self.settings['samples']['extend']*0.2)])



            transition_found = False
            i = 0

            while not transition_found and i < self.settings['samples']['extend'] - 1:

                if abs(diff_data[i]) > diff_data_std * transition_fac:

                    transition_found = True

                else:

                    i += 1


            index_transition = i - int(filter_correction_fraction*layer1_parameters['savgol_filter_characteristics']['length'])

            self.linearized_hertz_fit['method']['parameter']['layer_transition'] = dict()
            self.linearized_hertz_fit['method']['parameter']['layer_transition']['detected'] = transition_found

            if transition_found:

                self.linearized_hertz_fit['method']['parameter']['layer_transition']['index'] = index_transition

            # 3. find transition between two regimes
            # if transition is found than only look up to that point for first regime
            if stop_at_transition:

                if transition_found:

                    index_end_layer1 = index_transition

                else:

                    index_end_layer1 = self.settings['samples']['extend']

            else:

                index_end_layer1 = self.settings['samples']['extend']


            if layer1_parameters['start_fit_length'] == 'automatic':

                fit_length_initial_layer1 = max(int(self.settings['samples']['extend'] * 0.1),2 * (layer1_parameters['savgol_filter_characteristics']['length'] - 1))


            elif type(layer1_parameters['start_fit_length']) is int and layer1_parameters['start_fit_length'] > 0:

                fit_length_initial_layer1 = layer1_parameters['start_fit_length']

            else:

                fit_length_initial_layer1 = max(int(self.settings['samples']['extend'] * 0.1),2 * (layer1_parameters['savgol_filter_characteristics']['length'] - 1))


            self.linearized_hertz_fit['method']['parameter']['layer1']['start_fit_length'] = fit_length_initial_layer1

            # 4. scale data and find soft layer - layer 1
            line_found_layer1 = False
            loop_run = True

            if indenter_characteristics['geometry'] == 'parabolic':

                y_data_scaled_layer1 = np.power(y_data_savgol_layer1,2/3)
                start_index_layer1 = np.amax(np.where(np.isnan(y_data_scaled_layer1))) + 1

            elif indenter_characteristics['geometry'] == 'conical' or indenter_characteristics['geometry'] == 'four-sided pyramid':

                # scale data
                y_data_scaled_layer1 = np.sqrt(y_data_savgol_layer1)
                # find the correct starting index
                start_index_layer1 = np.amax(np.where(np.isnan(y_data_scaled_layer1))) + 1

            fit_start_layer1 = start_index_layer1 + 1
            fit_end_layer1 = fit_start_layer1 + fit_length_initial_layer1

            if fit_end_layer1 > index_end_layer1 or start_index_layer1 > index_end_layer1:

                loop_run = False

            else:

                # fit and determine quality of fit
                fit_layer1 = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                residuals = x_data[fit_start_layer1:fit_end_layer1] *fit_layer1[0] + fit_layer1[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                squared_sum_residuals = np.sum(residuals**2)
                r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                if not layer1_parameters['with_residuals']:

                    if r_squared > layer1_parameters['r_squared_limit']:

                        straight_line = True
                        line_found_layer1 = True

                    else:

                        straight_line = False


                    while fit_end_layer1 < index_end_layer1 and loop_run:

                        if straight_line:

                            fit_end_layer1 += 1

                            fit_layer1 = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                            residuals = x_data[fit_start_layer1:fit_end_layer1] *fit_layer1[0] + fit_layer1[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                            if r_squared > layer1_parameters['r_squared_limit']:

                                straight_line = True

                            else:

                                straight_line = False
                                loop_run = False


                        else:

                            fit_start_layer1 = fit_start_layer1 + 1
                            fit_end_layer1 = fit_start_layer1 + fit_length_initial_layer1

                            fit_layer1 = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                            residuals = x_data[fit_start_layer1:fit_end_layer1] *fit_layer1[0] + fit_layer1[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)

                            if r_squared > layer1_parameters['r_squared_limit']:

                                straight_line = True
                                line_found_layer1 = True


                else:

                    if r_squared > layer1_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer1 * noise_lvl_adapted:

                        straight_line = True
                        line_found_layer1 = True

                    else:

                        straight_line = False


                    while fit_end_layer1 < index_end_layer1 and loop_run:

                        if straight_line:

                            fit_end_layer1 += 1

                            fit_layer1 = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                            residuals = x_data[fit_start_layer1:fit_end_layer1] *fit_layer1[0] + fit_layer1[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                            if r_squared > layer1_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer1 * noise_lvl_adapted:

                                straight_line = True

                            else:

                                straight_line = False
                                loop_run = False


                        else:

                            fit_start_layer1 = fit_start_layer1 + 1
                            fit_end_layer1 = fit_start_layer1 + fit_length_initial_layer1

                            fit_layer1 = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                            residuals = x_data[fit_start_layer1:fit_end_layer1] *fit_layer1[0] + fit_layer1[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                            if r_squared > layer1_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer1 * noise_lvl_adapted:

                                straight_line = True
                                line_found_layer1 = True


            if line_found_layer1:

                fit_length_final_layer1 = fit_end_layer1 - fit_start_layer1
                fit_start_mod_layer1 = fit_start_layer1 + int(0.5*(1 - layer1_parameters['final_fit_fraction'])  * fit_length_final_layer1)
                fit_end_mod_layer1 = fit_start_layer1 + int(0.5 *(1 + layer1_parameters['final_fit_fraction']) * fit_length_final_layer1)

                fit_trim_layer1 = np.polyfit(x_data[fit_start_mod_layer1:fit_end_mod_layer1], y_data_scaled_layer1[fit_start_mod_layer1:fit_end_mod_layer1],1)

                # calculate the residuals
                residuals_linear_layer1 = x_data[fit_start_mod_layer1:fit_end_mod_layer1] *fit_trim_layer1[0] + fit_trim_layer1[1] - y_data_scaled_layer1[fit_start_mod_layer1:fit_end_mod_layer1]

                self.linearized_hertz_fit['best_fit']['line_found'] = True
                self.linearized_hertz_fit['best_fit']['index'] = (fit_start_mod_layer1,fit_end_mod_layer1-1)
                self.linearized_hertz_fit['best_fit']['interval'] = (self.data['extend'][self.keys['ts_key']][fit_start_mod_layer1],self.data['extend'][self.keys['ts_key']][fit_end_mod_layer1-1])
                self.linearized_hertz_fit['best_fit']['fit_parameter'] = - fit_trim_layer1[0]
                self.linearized_hertz_fit['best_fit']['contact_point'] = dict()
                #contact point index as first point with value smaller than the calculated contact point
                self.linearized_hertz_fit['best_fit']['contact_point']['index'] = np.argmax(self.data['extend'][self.keys['ts_key']] < -fit_trim_layer1[1]/fit_trim_layer1[0])
                self.linearized_hertz_fit['best_fit']['contact_point']['value'] = -fit_trim_layer1[1]/fit_trim_layer1[0]

                self.linearized_hertz_fit['best_fit']['specifics'] = dict()
                self.linearized_hertz_fit['best_fit']['specifics']['start_index'] = start_index_layer1
                self.linearized_hertz_fit['best_fit']['specifics']['full_index'] = (fit_start_layer1,fit_end_layer1-1)

                self.linearized_hertz_fit['residuals']['unit'] = 'nN'

                self.linearized_hertz_fit['residuals']['mean_linear_fit'] = np.mean(np.absolute(residuals_linear_layer1))
                self.linearized_hertz_fit['residuals']['data_linear_fit'] = residuals_linear_layer1


                if indenter_characteristics['geometry'] == 'parabolic':

                    e_modul_layer1 = np.power(abs(fit_trim_layer1[0]),3/2) * (1 - poisson_ratio**2) * 3 / (4 * math.sqrt(indenter_characteristics['radius [nm]']))

                    x_fit = copy.deepcopy(x_data)
                    ind = -(x_fit - self.linearized_hertz_fit['best_fit']['contact_point']['value'])
                    ind[ind<0] = 0
                    y_fit_layer1 = np.power(abs(fit_trim_layer1[0]),3/2) * np.power(ind,3/2)

                    residuals_layer1 = y_fit_layer1[fit_start_mod_layer1:fit_end_mod_layer1] - y_data[fit_start_mod_layer1:fit_end_mod_layer1]

                    self.linearized_hertz_fit['residuals']['mean'] = np.mean(np.absolute(residuals_layer1))
                    self.linearized_hertz_fit['residuals']['data'] = residuals_layer1


                elif indenter_characteristics['geometry'] == 'conical':

                    e_modul_layer1 = fit_trim_layer1[0]**2 * (1 - poisson_ratio**2) * np.pi / (2 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                    x_fit = copy.deepcopy(x_data)
                    ind = -(x_fit - self.linearized_hertz_fit['best_fit']['contact_point']['value'])
                    ind[ind<0] = 0
                    y_fit_layer1 = fit_trim_layer1[0]**2 * ind**2

                    residuals_layer1 = y_fit_layer1[fit_start_mod_layer1:fit_end_mod_layer1] - y_data[fit_start_mod_layer1:fit_end_mod_layer1]

                    self.linearized_hertz_fit['residuals']['mean'] = np.mean(np.absolute(residuals_layer1))
                    self.linearized_hertz_fit['residuals']['data'] = residuals_layer1


                elif indenter_characteristics['geometry'] == 'four-sided pyramid':

                    e_modul_layer1 = fit_trim_layer1[0]**2 * (1 - poisson_ratio**2) / (0.7453 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                    x_fit = copy.deepcopy(x_data)
                    ind = -(x_fit - self.linearized_hertz_fit['best_fit']['contact_point']['value'])
                    ind[ind<0] = 0
                    y_fit_layer1 = fit_trim_layer1[0]**2 * ind**2

                    residuals_layer1 = y_fit_layer1[fit_start_mod_layer1:fit_end_mod_layer1] - y_data[fit_start_mod_layer1:fit_end_mod_layer1]

                    self.linearized_hertz_fit['residuals']['mean'] = np.mean(np.absolute(residuals_layer1))
                    self.linearized_hertz_fit['residuals']['data'] = residuals_layer1

            else:

                self.linearized_hertz_fit['best_fit']['line_found'] = False
                self.linearized_hertz_fit['residuals'] = dict()

                e_modul_layer1 = np.nan


            self.linearized_hertz_fit['poisson_ratio'] = poisson_ratio
            self.linearized_hertz_fit['units'] = copy.deepcopy(self.units)

            e_modul_layer1 = e_modul_layer1 * 10**9
            e_modul_unit = 'Pa'
            e_modul_factor = 1

            self.linearized_hertz_fit['young_modulus'] = {'value': e_modul_layer1, 'unit': e_modul_unit, 'factor': e_modul_factor}



            retract_plot = False
            plot_linear = False

            if 'retract_plot' in kwargs and kwargs['retract_plot']:

                retract_plot = True

            if 'plot_linear' in kwargs and kwargs['plot_linear']:

                plot_linear = True


            if 'plot_result' in kwargs and kwargs['plot_result']:

                if indenter_characteristics['geometry'] == 'parabolic':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'
                elif indenter_characteristics['geometry'] == 'conical':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Angle: ' +'%.2f' % indenter_characteristics['angle [grad]']+ ' grad'
                elif indenter_characteristics['geometry'] == 'four-sided pyramid':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Angle: ' +'%.2f' % indenter_characteristics['angle [grad]']+ ' grad'
                elif indenter_characteristics['geometry'] == 'cylindrical':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'


                x_plot = x_data * (1e-09 / self.units['distance']['factor'])

                fig = plt.figure()
                ax = fig.add_axes([0.15, 0.15, 0.75, 0.75])

                ax.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend', color = '#1f77b4ff')

                if retract_plot:

                    ax.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['y_key']], label = 'retract', color = '#ff7e0eff')



                if line_found_layer1:

                    y_plot_layer1 = y_fit_layer1 * (1e-09 / self.units['force']['factor'])

                    text1 = 'Young\'s modulus layer1: %.2f' % self.linearized_hertz_fit['young_modulus']['value'] + ' ' + self.linearized_hertz_fit['young_modulus']['unit'] + '\nContact point: ' +'%.2f' % self.linearized_hertz_fit['best_fit']['contact_point']['value'] + ' ' + self.linearized_hertz_fit['units']['distance']['unit']
                    text2 = '\nFit index: (' + str(self.linearized_hertz_fit['best_fit']['index'][0]) +', ' + str(self.linearized_hertz_fit['best_fit']['index'][1])  + ')'
                    text3 = '\nFit parameter: a = %.2e' % self.linearized_hertz_fit['best_fit']['fit_parameter']

                    ax.plot(x_plot, y_plot_layer1, label = 'lin. hertz model - layer 1 - complete', color = '#c8ab37ff', linestyle = '--')
                    ax.plot(x_plot[fit_start_mod_layer1:fit_end_mod_layer1], y_plot_layer1[fit_start_mod_layer1:fit_end_mod_layer1], label = 'lin. hertz model - layer 1 - fit range', color = '#ff053bff')

                else:

                    text1 = 'No soft layer detected\n'
                    text2 = ''
                    text3 = ''



                if transition_found:

                    ax.plot(x_data[index_transition],y_data[index_transition], linestyle = '', marker = 'x', color = 'r', label = 'corrected transition point')

                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                ax.legend()
                ax.tick_params(direction = 'in', top = True, right = True)

                textstr = text1 + text2 + text3 + text4

                bbox_args = dict(boxstyle="round", fc= (1,1,1))
                an1 = ax.annotate(textstr, xy=(.23, .7), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox=bbox_args)
                an1.draggable() #allows to drag the box arround


                if plot_linear:


                    fig_lin = plt.figure()
                    ax_lin = fig_lin.add_axes([0.15, 0.15, 0.75, 0.75])
                    ax_lin.plot(x_data,y_data_scaled_layer1, label = 'smoothened scaled data')
                    #ax_lin.plot(x_data,y_data_scaled_layer2_plot, label = 'scaled data')
                    #ax_lin.plot(x_data,y_data_scaled_layer1_plot, label = 'smoothened scaled data')

                    if line_found_layer1:

                        ax_lin.plot(x_data[fit_start_mod_layer1:fit_end_mod_layer1], x_data[fit_start_mod_layer1:fit_end_mod_layer1] *fit_trim_layer1[0] + fit_trim_layer1[1], label = 'linear fit - layer 1', color = '#ff053bff')


                    ax_lin.set_title('Smoothened and Scaled Extend Data')
                    ax_lin.tick_params(direction = 'in', top = True, right = True)
                    ax_lin.legend()


            export = False

            if 'export_result' in kwargs:

                if type(kwargs['export_result']) is bool:

                    export = kwargs['export_result']
                    fileformat = ['svg', 'pdf', 'png', 'pkl']

                elif type(kwargs['export_result']) is str:

                    fileformat = [kwargs['export_result']]
                    export = True

                elif type(kwargs['export_result']) is list:

                    fileformat = kwargs['export_result']
                    export = True


            if export:

                if indenter_characteristics['geometry'] == 'parabolic':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'
                elif indenter_characteristics['geometry'] == 'conical':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Angle: ' +'%.2f' % indenter_characteristics['angle [grad]']+ ' grad'
                elif indenter_characteristics['geometry'] == 'four-sided pyramid':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Angle: ' +'%.2f' % indenter_characteristics['angle [grad]']+ ' grad'
                elif indenter_characteristics['geometry'] == 'cylindrical':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'


                x_plot = x_data * (1e-09 / self.units['distance']['factor'])

                plt.ioff()
                #fig_formats = ['svg', 'pdf', 'png', 'jpg']
                fig_export = [f for f in fileformat if f in ['svg', 'pdf', 'png', 'jpg']]


                fig_exp = plt.figure()
                ax_exp = fig_exp.add_axes([0.15, 0.15, 0.75, 0.75])

                ax_exp.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend', color = '#1f77b4ff')

                if retract_plot:

                    ax_exp.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['ts_key']], label = 'retract', color = '#ff7e0eff')


                if line_found_layer1:

                    y_plot_layer1 = y_fit_layer1 * (1e-09 / self.units['force']['factor'])

                    text1 = 'Young\'s modulus layer1: %.2f' % self.linearized_hertz_fit['young_modulus']['value'] + ' ' + self.linearized_hertz_fit['young_modulus']['unit'] + '\nContact point: ' +'%.2f' % self.linearized_hertz_fit['best_fit']['contact_point']['value'] + ' ' + self.linearized_hertz_fit['units']['distance']['unit']
                    text2 = '\nFit index: (' + str(self.linearized_hertz_fit['best_fit']['index'][0]) +', ' + str(self.linearized_hertz_fit['best_fit']['index'][1])  + ')'
                    text3 = '\nFit parameter: a = %.2e' % self.linearized_hertz_fit['best_fit']['fit_parameter']

                    ax_exp.plot(x_plot, y_plot_layer1, label = 'lin. hertz model - layer 1 - complete', color = '#c8ab37ff', linestyle = '--')
                    ax_exp.plot(x_plot[fit_start_mod_layer1:fit_end_mod_layer1], y_plot_layer1[fit_start_mod_layer1:fit_end_mod_layer1], label = 'lin. hertz model - layer 1 - fit range', color = '#ff053bff')

                else:

                    text1 = 'No soft layer detected\n'
                    text2 = ''
                    text3 = ''



                if transition_found:

                    ax.plot(x_data[index_transition],y_data[index_transition], linestyle = '', marker = 'x', color = 'r', label = 'corrected transition point')

                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                ax_exp.legend()
                ax_exp.tick_params(direction = 'in', top = True, right = True)

                textstr = text1 + text2 + text3 + text4

                bbox_args = dict(boxstyle="round", fc= (1,1,1))
                ax_exp.annotate(textstr, xy=(.23, .7), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox=bbox_args)

                if not os.path.isdir(os.path.join(self.file_info['save_directory'], 'linearized_hertz_fit')):

                    os.makedirs(os.path.join(self.file_info['save_directory'], 'linearized_hertz_fit'))


                for f in fig_export:

                    filename = os.path.join(self.file_info['save_directory'], 'linearized_hertz_fit', 'linearized_hertz_fit_' + self.file_info['file_org'] + '.' + f)

                    try:

                         plt.savefig(filename)

                    except:

                          sys.stderr.write('ERROR! Cannot open/write file ' + filename)


                plt.close(fig_exp)

                plt.ion()

                if 'pkl' in fileformat:

                     try:

                        file_pickle = os.path.join(self.file_info['save_directory'], 'linearized_hertz_fit', 'linearized_hertz_fit_' + self.file_info['file_org'] + '.pkl')
                        out_pkl = open(file_pickle, 'wb')

                        pickle.dump(self.linearized_hertz_fit, out_pkl)

                     except:

                          sys.stderr.write('ERROR! Cannot open/write file ' + file_pickle)

                     finally:

                          out_pkl.close()


        else:

            raise ValueError('ERROR! Data are not prepared for analysis. Perform corrections first.')






    def fit_linearized_hertz_model_debug(self,
                        poisson_ratio = 0.5,
                        indenter_characteristics = {'geometry': 'parabolic', 'radius [nm]': 10},
                        transition_sensitivity = 1,
                        stop_at_transition = True,
                        filter_correction_fraction = 0.5,
                        **kwargs):

        layer1_parameters = {'start_fit_length': 'automatic',
                             'savgol_filter_characteristics': {'length': 51, 'order': 1, 'deriv': 0, 'delta': 1.0, 'axis': -1, 'mode': 'interp', 'cval': 0.0},
                             'r_squared_limit':  0.98,
                             'residual_sensitivity': 1,
                             'final_fit_fraction': 0.8,
                             'with_residuals': True}


        if 'layer1_parameters' in kwargs:

            for key in kwargs['layer1_parameters'].keys():

                layer1_parameters[key] = kwargs['layer1_parameters'][key]




        residual_fac_layer1 = 5 - math.log10(layer1_parameters['residual_sensitivity'])
        transition_fac = 5 - math.log10(transition_sensitivity)



        if self.control_variables['allow_analysis']:

            self.linearized_hertz_fit = dict()
            self.linearized_hertz_fit['indenter'] = indenter_characteristics

            self.linearized_hertz_fit['method'] = dict()
            self.linearized_hertz_fit['method']['type'] = 'linear'
            self.linearized_hertz_fit['method']['parameter'] = dict()
            self.linearized_hertz_fit['method']['parameter']['transition_sensitivity'] = transition_sensitivity
            self.linearized_hertz_fit['method']['parameter']['transition_factor'] = transition_fac
            self.linearized_hertz_fit['method']['parameter']['stop_at_transition'] = stop_at_transition

            self.linearized_hertz_fit['method']['parameter']['layer1'] = dict()
            self.linearized_hertz_fit['method']['parameter']['layer1']['r_squared_limit'] = layer1_parameters['r_squared_limit']
            self.linearized_hertz_fit['method']['parameter']['layer1']['with_residuals'] = layer1_parameters['with_residuals']
            self.linearized_hertz_fit['method']['parameter']['layer1']['residual_sensitivity'] = layer1_parameters['residual_sensitivity']
            self.linearized_hertz_fit['method']['parameter']['layer1']['residual_factor'] = residual_fac_layer1
            self.linearized_hertz_fit['method']['parameter']['layer1']['final_fit_fraction'] = layer1_parameters['final_fit_fraction']


            self.linearized_hertz_fit['filter'] = dict()
            self.linearized_hertz_fit['filter']['type'] = 'savitzky-golay'
            self.linearized_hertz_fit['filter']['parameter'] = dict()
            self.linearized_hertz_fit['filter']['parameter']['length'] = layer1_parameters['savgol_filter_characteristics']['length']
            self.linearized_hertz_fit['filter']['parameter']['order'] = layer1_parameters['savgol_filter_characteristics']['order']

            self.linearized_hertz_fit['best_fit'] = dict()
            self.linearized_hertz_fit['residuals'] = dict()
            self.linearized_hertz_fit['young_modulus'] = dict()

            x_data = self.data['extend'][self.keys['ts_key']] / (1e-09 / self.units['distance']['factor'])
            y_data = self.data['extend'][self.keys['y_key']] / (1e-09 / self.units['force']['factor'])
            noise_lvl_adapted = self.noise_level['value'] / (1e-09 / self.units['force']['factor'])

            # 1. smooth data
            y_data_savgol_layer1 = savgol_filter(y_data,layer1_parameters['savgol_filter_characteristics']['length'],
                                                 layer1_parameters['savgol_filter_characteristics']['order'],
                                                 deriv = layer1_parameters['savgol_filter_characteristics']['deriv'],
                                                 delta = layer1_parameters['savgol_filter_characteristics']['delta'],
                                                 axis = layer1_parameters['savgol_filter_characteristics']['axis'],
                                                 mode = layer1_parameters['savgol_filter_characteristics']['mode'],
                                                 cval = layer1_parameters['savgol_filter_characteristics']['cval'])


            # 2. find "transition" point where smoothing does not work anymore
            diff_data = y_data - y_data_savgol_layer1
            diff_data_std = np.std(diff_data[0:int(self.settings['samples']['extend']*0.2)])



            transition_found = False
            i = 0

            while not transition_found and i < self.settings['samples']['extend'] - 1:

                if abs(diff_data[i]) > diff_data_std * transition_fac:

                    transition_found = True

                else:

                    i += 1


            index_transition = i - int(filter_correction_fraction*layer1_parameters['savgol_filter_characteristics']['length'])

            self.linearized_hertz_fit['method']['parameter']['layer_transition'] = dict()
            self.linearized_hertz_fit['method']['parameter']['layer_transition']['detected'] = transition_found

            if transition_found:

                self.linearized_hertz_fit['method']['parameter']['layer_transition']['index'] = index_transition


            # 3. find transition between two regimes
            # if transition is found than only look up to that point for first regime



            if stop_at_transition:

                if transition_found:

                    index_end_layer1 = index_transition

                else:

                    index_end_layer1 = self.settings['samples']['extend']


            else:

                index_end_layer1 = self.settings['samples']['extend']


            if layer1_parameters['start_fit_length'] == 'automatic':

                fit_length_initial_layer1 = max(int(self.settings['samples']['extend'] * 0.1),2 * (layer1_parameters['savgol_filter_characteristics']['length'] - 1))


            elif type(layer1_parameters['start_fit_length']) is int and layer1_parameters['start_fit_length'] > 0:

                fit_length_initial_layer1 = layer1_parameters['start_fit_length']

            else:

                fit_length_initial_layer1 = max(int(self.settings['samples']['extend'] * 0.1),2 * (layer1_parameters['savgol_filter_characteristics']['length'] - 1))





            self.linearized_hertz_fit['method']['parameter']['layer1']['start_fit_length'] = fit_length_initial_layer1


            # 4. scale data and find soft layer - layer 1
            line_found_layer1 = False
            loop_run = True

            if indenter_characteristics['geometry'] == 'parabolic':

                y_data_scaled_layer1 = np.power(y_data_savgol_layer1,2/3)
                start_index_layer1 = np.amax(np.where(np.isnan(y_data_scaled_layer1))) + 1


            elif indenter_characteristics['geometry'] == 'conical' or indenter_characteristics['geometry'] == 'four-sided pyramid':

                # scale data
                y_data_scaled_layer1 = np.sqrt(y_data_savgol_layer1)
                # find the correct starting index
                start_index_layer1 = np.amax(np.where(np.isnan(y_data_scaled_layer1))) + 1





            fit_start_layer1 = start_index_layer1 + 1
            fit_end_layer1 = fit_start_layer1 + fit_length_initial_layer1

            if fit_end_layer1 > index_end_layer1 or start_index_layer1 > index_end_layer1:

                loop_run = False

            else:

                # fit and determine quality of fit
                fit_layer1 = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                residuals = x_data[fit_start_layer1:fit_end_layer1] *fit_layer1[0] + fit_layer1[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                squared_sum_residuals = np.sum(residuals**2)
                r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)

                print('layer1:', fit_start_layer1, fit_end_layer1, r_squared, np.sqrt(squared_sum_residuals))

                if not layer1_parameters['with_residuals']:

                    if r_squared > layer1_parameters['r_squared_limit']:

                        straight_line = True
                        line_found_layer1 = True

                    else:

                        straight_line = False


                    while fit_end_layer1 < index_end_layer1 and loop_run:

                        if straight_line:

                            fit_end_layer1 += 1

                            fit_layer1 = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                            residuals = x_data[fit_start_layer1:fit_end_layer1] *fit_layer1[0] + fit_layer1[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)
                            print('layer1:', fit_start_layer1, fit_end_layer1, r_squared, np.sqrt(squared_sum_residuals), line_found_layer1)

                            if r_squared > layer1_parameters['r_squared_limit']:

                                straight_line = True

                            else:

                                straight_line = False
                                loop_run = False


                        else:

                            fit_start_layer1 = fit_start_layer1 + 1
                            fit_end_layer1 = fit_start_layer1 + fit_length_initial_layer1

                            fit_layer1 = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                            residuals = x_data[fit_start_layer1:fit_end_layer1] *fit_layer1[0] + fit_layer1[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)
                            print('layer1:', fit_start_layer1, fit_end_layer1, r_squared, np.sqrt(squared_sum_residuals), line_found_layer1)

                            if r_squared > layer1_parameters['r_squared_limit']:

                                straight_line = True
                                line_found_layer1 = True


                else:

                    if r_squared > layer1_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer1 * noise_lvl_adapted:

                        straight_line = True
                        line_found_layer1 = True

                    else:

                        straight_line = False


                    while fit_end_layer1 < index_end_layer1 and loop_run:

                        if straight_line:

                            fit_end_layer1 += 1

                            fit_layer1 = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                            residuals = x_data[fit_start_layer1:fit_end_layer1] *fit_layer1[0] + fit_layer1[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)
                            print('layer1:', fit_start_layer1, fit_end_layer1, r_squared, np.sqrt(squared_sum_residuals), line_found_layer1)

                            if r_squared > layer1_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer1 * noise_lvl_adapted:

                                straight_line = True

                            else:

                                straight_line = False
                                loop_run = False


                        else:

                            fit_start_layer1 = fit_start_layer1 + 1
                            fit_end_layer1 = fit_start_layer1 + fit_length_initial_layer1

                            fit_layer1 = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                            residuals = x_data[fit_start_layer1:fit_end_layer1] *fit_layer1[0] + fit_layer1[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)
                            print('layer1:', fit_start_layer1, fit_end_layer1, r_squared, np.sqrt(squared_sum_residuals), line_found_layer1)


                            if r_squared > layer1_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer1 * noise_lvl_adapted:

                                straight_line = True
                                line_found_layer1 = True


            if line_found_layer1:

                fit_length_final_layer1 = fit_end_layer1 - fit_start_layer1
                fit_start_mod_layer1 = fit_start_layer1 + int(0.5*(1 - layer1_parameters['final_fit_fraction'])  * fit_length_final_layer1)
                fit_end_mod_layer1 = fit_start_layer1 + int(0.5 *(1 + layer1_parameters['final_fit_fraction']) * fit_length_final_layer1)

                fit_trim_layer1 = np.polyfit(x_data[fit_start_mod_layer1:fit_end_mod_layer1], y_data_scaled_layer1[fit_start_mod_layer1:fit_end_mod_layer1],1)

                # calculate the residuals

                residuals_linear_layer1 = x_data[fit_start_mod_layer1:fit_end_mod_layer1] *fit_trim_layer1[0] + fit_trim_layer1[1] - y_data_scaled_layer1[fit_start_mod_layer1:fit_end_mod_layer1]

                self.linearized_hertz_fit['best_fit']['line_found'] = True
                self.linearized_hertz_fit['best_fit']['index'] = (fit_start_mod_layer1,fit_end_mod_layer1-1)
                self.linearized_hertz_fit['best_fit']['interval'] = (self.data['extend'][self.keys['ts_key']][fit_start_mod_layer1],self.data['extend'][self.keys['ts_key']][fit_end_mod_layer1-1])
                self.linearized_hertz_fit['best_fit']['fit_parameter'] = - fit_trim_layer1[0]
                self.linearized_hertz_fit['best_fit']['contact_point'] = dict()
                #contact point index as first point with value smaller than the calculated contact point
                self.linearized_hertz_fit['best_fit']['contact_point']['index'] = np.argmax(self.data['extend'][self.keys['ts_key']] < -fit_trim_layer1[1]/fit_trim_layer1[0])
                self.linearized_hertz_fit['best_fit']['contact_point']['value'] = -fit_trim_layer1[1]/fit_trim_layer1[0]

                self.linearized_hertz_fit['best_fit']['specifics'] = dict()
                self.linearized_hertz_fit['best_fit']['specifics']['start_index'] = start_index_layer1
                self.linearized_hertz_fit['best_fit']['specifics']['full_index'] = (fit_start_layer1,fit_end_layer1-1)

                self.linearized_hertz_fit['residuals']['unit'] = 'nN'

                self.linearized_hertz_fit['residuals']['mean_linear_fit'] = np.mean(np.absolute(residuals_linear_layer1))
                self.linearized_hertz_fit['residuals']['data_linear_fit'] = residuals_linear_layer1


                if indenter_characteristics['geometry'] == 'parabolic':

                    e_modul_layer1 = np.power(abs(fit_trim_layer1[0]),3/2) * (1 - poisson_ratio**2) * 3 / (4 * math.sqrt(indenter_characteristics['radius [nm]']))

                    x_fit = copy.deepcopy(x_data)
                    ind = -(x_fit - self.linearized_hertz_fit['best_fit']['contact_point']['value'])
                    ind[ind<0] = 0
                    y_fit_layer1 = np.power(abs(fit_trim_layer1[0]),3/2) * np.power(ind,3/2)

                    residuals_layer1 = y_fit_layer1[fit_start_mod_layer1:fit_end_mod_layer1] - y_data[fit_start_mod_layer1:fit_end_mod_layer1]

                    self.linearized_hertz_fit['residuals']['mean'] = np.mean(np.absolute(residuals_layer1))
                    self.linearized_hertz_fit['residuals']['data'] = residuals_layer1


                elif indenter_characteristics['geometry'] == 'conical':

                    e_modul_layer1 = fit_trim_layer1[0]**2 * (1 - poisson_ratio**2) * np.pi / (2 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                    x_fit = copy.deepcopy(x_data)
                    ind = -(x_fit - self.linearized_hertz_fit['best_fit']['contact_point']['value'])
                    ind[ind<0] = 0
                    y_fit_layer1 = fit_trim_layer1[0]**2 * ind**2

                    residuals_layer1 = y_fit_layer1[fit_start_mod_layer1:fit_end_mod_layer1] - y_data[fit_start_mod_layer1:fit_end_mod_layer1]

                    self.linearized_hertz_fit['residuals']['mean'] = np.mean(np.absolute(residuals_layer1))
                    self.linearized_hertz_fit['residuals']['data'] = residuals_layer1


                elif indenter_characteristics['geometry'] == 'four-sided pyramid':

                    e_modul_layer1 = fit_trim_layer1[0]**2 * (1 - poisson_ratio**2) / (0.7453 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                    x_fit = copy.deepcopy(x_data)
                    ind = -(x_fit - self.linearized_hertz_fit['best_fit']['contact_point']['value'])
                    ind[ind<0] = 0
                    y_fit_layer1 = fit_trim_layer1[0]**2 * ind**2

                    residuals_layer1 = y_fit_layer1[fit_start_mod_layer1:fit_end_mod_layer1] - y_data[fit_start_mod_layer1:fit_end_mod_layer1]

                    self.linearized_hertz_fit['residuals']['mean'] = np.mean(np.absolute(residuals_layer1))
                    self.linearized_hertz_fit['residuals']['data'] = residuals_layer1

            else:

                self.linearized_hertz_fit['best_fit']['line_found'] = False
                self.linearized_hertz_fit['residuals'] = dict()

                e_modul_layer1 = np.nan


            self.linearized_hertz_fit['poisson_ratio'] = poisson_ratio
            self.linearized_hertz_fit['units'] = copy.deepcopy(self.units)

            e_modul_layer1 = e_modul_layer1 * 10**9
            e_modul_unit = 'Pa'
            e_modul_factor = 1

            self.linearized_hertz_fit['young_modulus'] = {'value': e_modul_layer1, 'unit': e_modul_unit, 'factor': e_modul_factor}



            retract_plot = False
            plot_linear = False

            if 'retract_plot' in kwargs and kwargs['retract_plot']:

                retract_plot = True

            if 'plot_linear' in kwargs and kwargs['plot_linear']:

                plot_linear = True


            if 'plot_result' in kwargs and kwargs['plot_result']:

                if indenter_characteristics['geometry'] == 'parabolic':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'
                elif indenter_characteristics['geometry'] == 'conical':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Angle: ' +'%.2f' % indenter_characteristics['angle [grad]']+ ' grad'
                elif indenter_characteristics['geometry'] == 'four-sided pyramid':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Angle: ' +'%.2f' % indenter_characteristics['angle [grad]']+ ' grad'
                elif indenter_characteristics['geometry'] == 'cylindrical':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'


                x_plot = x_data * (1e-09 / self.units['distance']['factor'])




                fig = plt.figure()
                ax = fig.add_axes([0.15, 0.15, 0.75, 0.75])

                ax.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend', color = '#1f77b4ff')

                if retract_plot:

                    ax.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['y_key']], label = 'retract', color = '#ff7e0eff')



                if line_found_layer1:

                    y_plot_layer1 = y_fit_layer1 * (1e-09 / self.units['force']['factor'])

                    text1 = 'Young\'s modulus layer1: %.2f' % self.linearized_hertz_fit['young_modulus']['value'] + ' ' + self.linearized_hertz_fit['young_modulus']['unit'] + '\nContact point: ' +'%.2f' % self.linearized_hertz_fit['best_fit']['contact_point']['value'] + ' ' + self.linearized_hertz_fit['units']['distance']['unit']
                    text2 = '\nFit index: (' + str(self.linearized_hertz_fit['best_fit']['index'][0]) +', ' + str(self.linearized_hertz_fit['best_fit']['index'][1])  + ')'
                    text3 = '\nFit parameter: a = %.2e' % self.linearized_hertz_fit['best_fit']['fit_parameter']

                    ax.plot(x_plot, y_plot_layer1, label = 'lin. hertz model - layer 1 - complete', color = '#c8ab37ff', linestyle = '--')
                    ax.plot(x_plot[fit_start_mod_layer1:fit_end_mod_layer1], y_plot_layer1[fit_start_mod_layer1:fit_end_mod_layer1], label = 'lin. hertz model - layer 1 - fit range', color = '#ff053bff')

                else:

                    text1 = 'No soft layer detected\n'
                    text2 = ''
                    text3 = ''



                if transition_found:

                    ax.plot(x_data[index_transition],y_data[index_transition], linestyle = '', marker = 'x', color = 'r', label = 'corrected transition point')

                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                ax.legend()
                ax.tick_params(direction = 'in', top = True, right = True)

                textstr = text1 + text2 + text3 + text4

                bbox_args = dict(boxstyle="round", fc= (1,1,1))
                an1 = ax.annotate(textstr, xy=(.23, .7), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox=bbox_args)
                an1.draggable() #allows to drag the box arround


                if plot_linear:


                    fig_lin = plt.figure()
                    ax_lin = fig_lin.add_axes([0.15, 0.15, 0.75, 0.75])
                    ax_lin.plot(x_data,y_data_scaled_layer1, label = 'smoothened scaled data')
                    #ax_lin.plot(x_data,y_data_scaled_layer2_plot, label = 'scaled data')
                    #ax_lin.plot(x_data,y_data_scaled_layer1_plot, label = 'smoothened scaled data')


                    if line_found_layer1:

                        ax_lin.plot(x_data[fit_start_mod_layer1:fit_end_mod_layer1], x_data[fit_start_mod_layer1:fit_end_mod_layer1] *fit_trim_layer1[0] + fit_trim_layer1[1], label = 'linear fit - layer 1', color = '#ff053bff')
                        ax_lin.plot(x_data[fit_start_layer1:fit_end_layer1-1], x_data[fit_start_layer1:fit_end_layer1-1] *fit_layer1[0] + fit_layer1[1], label = 'linear fit - full range', color = '#888888ff')


                    ax_lin.set_title('Smoothened and Scaled Extend Data')
                    ax_lin.tick_params(direction = 'in', top = True, right = True)
                    ax_lin.legend()



        else:

            raise ValueError('ERROR! Data are not prepared for analysis. Perform corrections first.')






    def fit_two_layer_linearized_hertz_model_testing(self,
                        poisson_ratio = 0.5,
                        indenter_characteristics = {'geometry': 'parabolic', 'radius [nm]': 10},
                        fit_length = 'automatic',
                        savgol_filter_characteristics = {'length': 51, 'order': 1},
                        r_squared_limit = 0.98,
                        transition_sensitivity = 1,
                        residual_sensitivity = 1,
                        final_fit_fraction = 0.8,
                        filter_correction_fraction = 0.5,
                        with_residuals = True,
                        **kwargs):

        #residual_fac = 5 - math.log10(residual_sensitivity)
        transition_fac = 5 - math.log10(transition_sensitivity)


        if self.control_variables['allow_analysis']:

            x_data = self.data['extend'][self.keys['ts_key']] / (1e-09 / self.units['distance']['factor'])
            y_data = self.data['extend'][self.keys['y_key']] / (1e-09 / self.units['force']['factor'])
            noise_lvl_adapted = self.noise_level['value'] / (1e-09 / self.units['force']['factor'])

            # 1. smooth data
            #y_data_savgol= savgol_filter(y_data,savgol_filter_characteristics['length'],savgol_filter_characteristics['order'])

            y_data_plus = np.sqrt(y_data)
            y_data_minus = np.sqrt(-y_data)
            y_data_plus[np.isnan(y_data_plus)] = 0
            y_data_minus[np.isnan(y_data_minus)] = 0
            y_data_combined = y_data_plus - y_data_minus


            y_data_savgol_51_plus = np.sqrt(savgol_filter(y_data,51,1))
            y_data_savgol_51_minus = np.sqrt(-savgol_filter(y_data,51,1))
            y_data_savgol_51_plus[np.isnan(y_data_savgol_51_plus)] = 0
            y_data_savgol_51_minus[np.isnan(y_data_savgol_51_minus)] = 0
            y_data_savgol_51_combined = y_data_savgol_51_plus - y_data_savgol_51_minus

            y_data_savgol_11 = savgol_filter(y_data,11,1)
            y_data_savgol_21 = savgol_filter(y_data,21,1)
            y_data_savgol_31 = savgol_filter(y_data,31,1)
            y_data_savgol_51 = savgol_filter(y_data,51,1)
            y_data_savgol_71 = savgol_filter(y_data,71,1)
            #y_data_savgol_91 = savgol_filter(y_data,91,1)
            #diff_11 = y_data - y_data_savgol_11
            #diff_31 = y_data - y_data_savgol_31
            #diff_51 = y_data - y_data_savgol_51
            #diff_71 = y_data - y_data_savgol_71
            #diff_91 = y_data - y_data_savgol_91
            #print(np.isnan(y_data))

            #y_data_savgol_51_0 = savgol_filter(y_data,51,0)
            #y_data_savgol_51_1 = savgol_filter(y_data,51,1)
            #y_data_savgol_51_2 = savgol_filter(y_data,51,2)
            #y_data_savgol_51_3 = savgol_filter(y_data,51,3)

            #y_data_savgol_51_1_0 = savgol_filter(y_data,51,1)
            #y_data_savgol_51_1_1 = savgol_filter(y_data,51,1, deriv = 1)


            # 2. find "transition" point where smoothing does not work anymore
            diff_data = y_data - y_data_savgol_21
            diff_data_std = np.std(diff_data[0:int(self.settings['samples']['extend']*0.2)])


            transition_found = False
            i = 0

            while not transition_found and i < self.settings['samples']['extend'] - 1:

                if abs(diff_data[i]) > diff_data_std * transition_fac:

                    transition_found = True

                else:

                    i += 1

            index_transition = i - int(filter_correction_fraction*savgol_filter_characteristics['length'])
            #index_transition_2 = i - savgol_filter_characteristics['length']


            fig1 = plt.figure()
            ax1 = fig1.add_subplot(111)
            ax1.plot(x_data,y_data, label = 'raw extend data')
            ax1.plot(x_data,y_data_savgol_11, label = 'savgol length: 11')
            ax1.plot(x_data,y_data_savgol_31, label = 'savgol length: 31')
            ax1.plot(x_data,y_data_savgol_51, label = 'savgol length: 51')
            ax1.plot(x_data,y_data_savgol_71, label = 'savgol length: 71')
            ax1.plot(x_data[index_transition],y_data_savgol_51[index_transition], linestyle = '', marker = 'x', color = 'r', label = 'corrected transition point')
            #ax1.plot(x_data[index_transition_2],y_data_savgol_51[index_transition_2], marker = 'x', color = 'b')
            ax1.plot(x_data[i],y_data_savgol_51[i], linestyle = '', marker = 'x', color = 'g', label = 'trigger point')
            ax1.legend()
            ax1.set_title('Filter Length: Smoothened and Raw Data')
            ax1.set_xlabel('Separation / nm')
            ax1.set_ylabel('Force / nN')
            ax1.tick_params(direction = 'in', top = True, right = True)


            fig2 = plt.figure()
            ax2 = fig2.add_subplot(111)
            ax2.plot(x_data,np.sqrt(y_data), label = 'raw extend data')
            #ax2.plot(x_data,np.sqrt(y_data_savgol_11), label = 'savgol length: 11')
            #ax2.plot(x_data,np.sqrt(y_data_savgol_31), label = 'savgol length: 31')
            ax2.plot(x_data,np.sqrt(y_data_savgol_51), label = 'savgol length: 51')
            #ax2.plot(x_data,np.sqrt(y_data_savgol_71), label = 'savgol length: 71')
            #ax1.plot(x_data[index_transition],y_data_savgol_51[index_transition], linestyle = '', marker = 'x', color = 'r', label = 'corrected transition point')
            #ax1.plot(x_data[index_transition_2],y_data_savgol_51[index_transition_2], marker = 'x', color = 'b')
            #ax1.plot(x_data[i],y_data_savgol_51[i], linestyle = '', marker = 'x', color = 'g', label = 'trigger point')
            ax2.legend()
            ax2.set_title('Filter length: Scaled Data')
            ax2.set_xlabel('Separation / nm')
            ax2.set_ylabel('Scaled force')
            ax2.tick_params(direction = 'in', top = True, right = True)


            fig2 = plt.figure()
            ax2 = fig2.add_subplot(111)
            ax2.plot(x_data,y_data_combined, label = 'raw extend data')
            #ax2.plot(x_data,np.sqrt(y_data_savgol_11), label = 'savgol length: 11')
            #ax2.plot(x_data,np.sqrt(y_data_savgol_31), label = 'savgol length: 31')
            ax2.plot(x_data,y_data_savgol_51_combined, label = 'savgol length: 51')
            #ax2.plot(x_data,np.sqrt(y_data_savgol_71), label = 'savgol length: 71')
            #ax1.plot(x_data[index_transition],y_data_savgol_51[index_transition], linestyle = '', marker = 'x', color = 'r', label = 'corrected transition point')
            #ax1.plot(x_data[index_transition_2],y_data_savgol_51[index_transition_2], marker = 'x', color = 'b')
            #ax1.plot(x_data[i],y_data_savgol_51[i], linestyle = '', marker = 'x', color = 'g', label = 'trigger point')
            ax2.legend()
            ax2.set_title('Scaled Data - include negative')
            ax2.set_xlabel('Separation / nm')
            ax2.set_ylabel('Scaled force')
            ax2.tick_params(direction = 'in', top = True, right = True)


            fig2 = plt.figure()
            ax2 = fig2.add_subplot(111)
            ax2.plot(x_data[index_transition:],y_data_combined[index_transition:], label = 'raw extend data')
            #ax2.plot(x_data,np.sqrt(y_data_savgol_11), label = 'savgol length: 11')
            #ax2.plot(x_data,np.sqrt(y_data_savgol_31), label = 'savgol length: 31')
            ax2.plot(x_data[0:index_transition],y_data_savgol_51_combined[0:index_transition], label = 'savgol length: 51')
            #ax2.plot(x_data,np.sqrt(y_data_savgol_71), label = 'savgol length: 71')
            #ax1.plot(x_data[index_transition],y_data_savgol_51[index_transition], linestyle = '', marker = 'x', color = 'r', label = 'corrected transition point')
            #ax1.plot(x_data[index_transition_2],y_data_savgol_51[index_transition_2], marker = 'x', color = 'b')
            #ax1.plot(x_data[i],y_data_savgol_51[i], linestyle = '', marker = 'x', color = 'g', label = 'trigger point')
            ax2.legend()
            ax2.set_title('Scaled Data - Relevant part')
            ax2.set_xlabel('Separation / nm')
            ax2.set_ylabel('Scaled force')
            ax2.tick_params(direction = 'in', top = True, right = True)

#            fig2 = plt.figure()
#            ax2 = fig2.add_subplot(111)
#            ax2.plot(x_data,y_data, label = 'none')
#            ax2.plot(x_data,y_data_savgol_11, label = ['savgol length: 11', str(np.std(y_data_savgol_11[200:300]))])
#            ax2.plot(x_data,y_data_savgol_31, label = ['savgol length: 31', str(np.std(y_data_savgol_31[200:300]))])
#            ax2.plot(x_data,y_data_savgol_51, label = ['savgol length: 51', str(np.std(y_data_savgol_51[200:300]))])
#            ax2.plot(x_data,y_data_savgol_71, label = ['savgol length: 71', str(np.std(y_data_savgol_71[200:300]))])
#            ax2.plot(x_data,y_data_savgol_91, label = ['savgol length: 91', str(np.std(y_data_savgol_91[200:300]))])
#            ax2.legend()

            fig3 = plt.figure()
            ax3 = fig3.add_subplot(111)
            ax3.plot(x_data, np.zeros(x_data.size), label = 'none')
            ax3.plot(x_data, diff_data, label = 'difference raw and smoothened data')
            #ax3.plot(x_data, savgol_filter(diff_data,51,1), label = 'smoothened')
            ax3.plot(x_data[index_transition],diff_data[index_transition], marker = 'x', color = 'r', label = 'corrected transition point')
            ax3.plot([x_data[index_transition],x_data[index_transition]],[min(diff_data)*0.8,max(diff_data)*0.4], color = 'r')

            #ax3.plot(x_data[index_transition_2],diff_data[index_transition_2], marker = 'x', color = 'b')
            ax3.plot(x_data[i],diff_data[i], linestyle = '', marker = 'x', color = 'g', label = 'trigger point')
            ax3.legend()
            ax3.set_title('Detect Transition Point: Difference Smoothened and Raw Data')
            ax3.set_xlabel('Separation / nm')
            ax3.set_ylabel('Force / nN')
            ax3.tick_params(direction = 'in', top = True, right = True)

#            fig4 = plt.figure()
#            ax4 = fig4.add_subplot(111)
#            ax4.plot(x_data,y_data, label = 'raw extend data')
#            ax4.plot(x_data,y_data_savgol_51_1_0, label = 'savgol length: 51, order: 1, deriv 0')
#            ax4.plot(x_data,y_data_savgol_51_1_1, label = 'savgol length: 51, order: 1, deriv 1')
#            ax4.set_xlabel('Separation / nm')
#            ax4.set_ylabel('Force / nN')
#            ax4.legend()
#            ax4.set_title('Effect of Polynomial Order')
#            ax4.tick_params(direction = 'in', top = True, right = True)
#
#            fig4 = plt.figure()
#            ax4 = fig4.add_subplot(111)
#            ax4.plot(x_data,np.sqrt(y_data), label = 'raw extend data')
#            ax4.plot(x_data,np.sqrt(y_data_savgol_51_1_0), label = 'savgol length: 51, order: 1, deriv 0')
#            ax4.plot(x_data,np.sqrt(y_data_savgol_51_1_1), label = 'savgol length: 51, order: 1, deriv 1')
#            ax4.set_xlabel('Separation / nm')
#            ax4.set_ylabel('Scaled Force / nN')
#            ax4.legend()
#            ax4.set_title('Scaled Data - Effect of Polynomial Order')
#            ax4.tick_params(direction = 'in', top = True, right = True)


#            fft_ext = np.fft.fft(y_data)
#            fft_ext_11 = np.fft.fft(y_data_savgol_11)
#            #fft_ret = np.fft.fft(qi.sample_fd_curve['object'].data['retract']['vDeflection'])
#
#            fft_ext_mod = abs(fft_ext/fft_ext.size)
#            fft_ext_mod_11 = abs(fft_ext_11/fft_ext_11.size)
#
#            #fft_ext_final = copy.deepcopy(fft_ext_mod[0:int(0.5*fft_ext_mod.size+1)])
#            #fft_ext_final[1:] = fft_ext_final[1:]*2
#
#            fig4 = plt.figure()
#            ax4 = fig4.add_subplot(111)
#            ax4.plot(fft_ext_mod[0:int(0.5*fft_ext_mod.size+1)], label = 'dft raw data')
#            #ax4.plot(fft_ext_mod_11[0:int(0.5*fft_ext_mod_11.size+1)], label = 'dft filter length 11')
#
#            ax4.legend()
#            ax4.set_title('Discret Fourier Transformation of Extend Data')
#            ax4.set_xlabel('Datapoints')
#            ax4.set_ylabel('Amplitude')
#            ax4.tick_params(direction = 'in', top = True, right = True)
#
#
#





    def fit_two_layer_linearized_hertz_model(self,
                        poisson_ratio = 0.5,
                        indenter_characteristics = {'geometry': 'parabolic', 'radius [nm]': 10},
                        transition_sensitivity = 1,
                        filter_correction_fraction = 0.5,
                        **kwargs):

        layer1_parameters = {'start_fit_length': 'automatic',
                             'savgol_filter_characteristics': {'length': 51, 'order': 1, 'deriv': 0, 'delta': 1.0, 'axis': -1, 'mode': 'interp', 'cval': 0.0},
                             'r_squared_limit':  0.98,
                             'residual_sensitivity': 1,
                             'final_fit_fraction': 0.8,
                             'with_residuals': True}

        layer2_parameters = {'start_fit_length': 'automatic',
                             #'savgol_filter_characteristics': {'length': 51, 'order': 1},
                             'r_squared_limit':  0.98,
                             'residual_sensitivity': 1,
                             'final_fit_fraction': 0.9,
                             'with_residuals': True,}


        if 'layer1_parameters' in kwargs:

            for key in kwargs['layer1_parameters'].keys():

                layer1_parameters[key] = kwargs['layer1_parameters'][key]


        if 'layer2_parameters' in kwargs:

            for key in kwargs['layer2_parameters'].keys():

                layer2_parameters[key] = kwargs['layer2_parameters'][key]


        residual_fac_layer1 = 5 - math.log10(layer1_parameters['residual_sensitivity'])
        residual_fac_layer2 = 5 - math.log10(layer2_parameters['residual_sensitivity'])
        transition_fac = 5 - math.log10(transition_sensitivity)


        if self.control_variables['allow_analysis']:

            self.two_layer_hertz = dict()
            self.two_layer_hertz['indenter'] = indenter_characteristics

            self.two_layer_hertz['method'] = dict()
            self.two_layer_hertz['method']['type'] = 'linear'
            self.two_layer_hertz['method']['parameter'] = dict()
            self.two_layer_hertz['method']['parameter']['transition_sensitivity'] = transition_sensitivity
            self.two_layer_hertz['method']['parameter']['transition_factor'] = transition_fac

            self.two_layer_hertz['method']['parameter']['layer1'] = dict()
            self.two_layer_hertz['method']['parameter']['layer1']['r_squared_limit'] = layer1_parameters['r_squared_limit']
            self.two_layer_hertz['method']['parameter']['layer1']['with_residuals'] = layer1_parameters['with_residuals']
            self.two_layer_hertz['method']['parameter']['layer1']['residual_sensitivity'] = layer1_parameters['residual_sensitivity']
            self.two_layer_hertz['method']['parameter']['layer1']['residual_factor'] = residual_fac_layer1
            self.two_layer_hertz['method']['parameter']['layer1']['final_fit_fraction'] = layer1_parameters['final_fit_fraction']

            self.two_layer_hertz['method']['parameter']['layer2'] = dict()
            self.two_layer_hertz['method']['parameter']['layer2']['r_squared_limit'] = layer2_parameters['r_squared_limit']
            self.two_layer_hertz['method']['parameter']['layer2']['with_residuals'] = layer2_parameters['with_residuals']
            self.two_layer_hertz['method']['parameter']['layer2']['residual_sensitivity'] = layer2_parameters['residual_sensitivity']
            self.two_layer_hertz['method']['parameter']['layer2']['residual_factor'] = residual_fac_layer2
            self.two_layer_hertz['method']['parameter']['layer2']['final_fit_fraction'] = layer2_parameters['final_fit_fraction']


            self.two_layer_hertz['filter'] = dict()
            self.two_layer_hertz['filter']['layer1'] = dict()
            self.two_layer_hertz['filter']['layer1']['type'] = 'savitzky-golay'
            self.two_layer_hertz['filter']['layer1']['parameter'] = dict()
            self.two_layer_hertz['filter']['layer1']['parameter']['length'] = layer1_parameters['savgol_filter_characteristics']['length']
            self.two_layer_hertz['filter']['layer1']['parameter']['order'] = layer1_parameters['savgol_filter_characteristics']['order']

            self.two_layer_hertz['best_fit'] = dict()
            self.two_layer_hertz['best_fit']['layer1'] = dict()
            self.two_layer_hertz['best_fit']['layer2'] = dict()

            self.two_layer_hertz['residuals'] = dict()
            self.two_layer_hertz['residuals']['layer1'] = dict()
            self.two_layer_hertz['residuals']['layer2'] = dict()

            self.two_layer_hertz['young_modulus'] = dict()


            x_data = self.data['extend'][self.keys['ts_key']] / (1e-09 / self.units['distance']['factor'])
            y_data = self.data['extend'][self.keys['y_key']] / (1e-09 / self.units['force']['factor'])
            noise_lvl_adapted = self.noise_level['value'] / (1e-09 / self.units['force']['factor'])

            # 1. smooth data
            y_data_savgol_layer1 = savgol_filter(y_data,layer1_parameters['savgol_filter_characteristics']['length'],
                                                 layer1_parameters['savgol_filter_characteristics']['order'],
                                                 deriv = layer1_parameters['savgol_filter_characteristics']['deriv'],
                                                 delta = layer1_parameters['savgol_filter_characteristics']['delta'],
                                                 axis = layer1_parameters['savgol_filter_characteristics']['axis'],
                                                 mode = layer1_parameters['savgol_filter_characteristics']['mode'],
                                                 cval = layer1_parameters['savgol_filter_characteristics']['cval'])


            # 2. find "transition" point where smoothing does not work anymore
            diff_data = y_data - y_data_savgol_layer1
            diff_data_std = np.std(diff_data[0:int(self.settings['samples']['extend']*0.2)])


            transition_found = False
            i = 0

            while not transition_found and i < self.settings['samples']['extend'] - 1:

                if abs(diff_data[i]) > diff_data_std * transition_fac:

                    transition_found = True

                else:

                    i += 1


            index_transition = i - int(filter_correction_fraction*layer1_parameters['savgol_filter_characteristics']['length'])

            self.two_layer_hertz['method']['parameter']['layer_transition'] = dict()
            self.two_layer_hertz['method']['parameter']['layer_transition']['detected'] = transition_found

            if transition_found:

                self.two_layer_hertz['method']['parameter']['layer_transition']['index'] = index_transition


            # 3. find transition between two regimes
            # if transition is found than only look up to that point for first regime

            if transition_found:

                index_end_layer1 = index_transition

            else:

                index_end_layer1 = self.settings['samples']['extend']


            if layer1_parameters['start_fit_length'] == 'automatic':

                fit_length_initial_layer1 = max(int(self.settings['samples']['extend'] * 0.1),2 * (layer1_parameters['savgol_filter_characteristics']['length'] - 1))
                #fit_length_initial_layer1 = 2 * (layer1_parameters['savgol_filter_characteristics']['length'] - 1)

            elif type(layer1_parameters['start_fit_length']) is int and layer1_parameters['start_fit_length'] > 0:

                fit_length_initial_layer1 = layer1_parameters['start_fit_length']

            else:

                fit_length_initial_layer1 = max(int(self.settings['samples']['extend'] * 0.1),2 * (layer1_parameters['savgol_filter_characteristics']['length'] - 1))


            if layer2_parameters['start_fit_length'] == 'automatic':

                fit_length_initial_layer2 = max(10,int(self.settings['samples']['extend'] * 0.02))

            elif type(layer2_parameters['start_fit_length']) is int and layer2_parameters['start_fit_length'] > 0:

                fit_length_initial_layer2 = layer2_parameters['start_fit_length']

            else:

                fit_length_initial_layer2 = max(10,int(self.settings['samples']['extend'] * 0.02))


            self.two_layer_hertz['method']['parameter']['layer1']['start_fit_length'] = fit_length_initial_layer1
            self.two_layer_hertz['method']['parameter']['layer2']['start_fit_length'] = fit_length_initial_layer2


            # 4. scale data and find soft layer - layer 1
            line_found_layer1 = False
            loop_run = True

            if indenter_characteristics['geometry'] == 'parabolic':

                y_data_scaled_layer1 = np.power(y_data_savgol_layer1,2/3)
                start_index_layer1 = np.amax(np.where(np.isnan(y_data_scaled_layer1))) + 1

            elif indenter_characteristics['geometry'] == 'conical' or indenter_characteristics['geometry'] == 'four-sided pyramid':

                # scale data
                y_data_scaled_layer1 = np.sqrt(y_data_savgol_layer1)
                # find the correct starting index
                start_index_layer1 = np.amax(np.where(np.isnan(y_data_scaled_layer1))) + 1


            fit_start_layer1 = start_index_layer1 + 1
            fit_end_layer1 = fit_start_layer1 + fit_length_initial_layer1

            if fit_end_layer1 > index_end_layer1 or start_index_layer1 > index_end_layer1:

                loop_run = False

            else:

                # fit and determine quality of fit
                fit = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                residuals = x_data[fit_start_layer1:fit_end_layer1] *fit[0] + fit[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                squared_sum_residuals = np.sum(residuals**2)
                r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                if not layer1_parameters['with_residuals']:

                    if r_squared > layer1_parameters['r_squared_limit']:

                        straight_line = True
                        line_found_layer1 = True

                    else:

                        straight_line = False


                    while fit_end_layer1 < index_end_layer1 and loop_run:

                        if straight_line:

                            fit_end_layer1 += 1

                            fit = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                            residuals = x_data[fit_start_layer1:fit_end_layer1] *fit[0] + fit[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)

                            if r_squared > layer1_parameters['r_squared_limit']:

                                straight_line = True

                            else:

                                straight_line = False
                                loop_run = False


                        else:

                            fit_start_layer1 = fit_start_layer1 + 1
                            fit_end_layer1 = fit_start_layer1 + fit_length_initial_layer1

                            fit = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                            residuals = x_data[fit_start_layer1:fit_end_layer1] *fit[0] + fit[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                            if r_squared > layer1_parameters['r_squared_limit']:

                                straight_line = True
                                line_found_layer1 = True


                else:

                    if r_squared > layer1_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer1 * noise_lvl_adapted:

                        straight_line = True
                        line_found_layer1 = True

                    else:

                        straight_line = False


                    while fit_end_layer1 < index_end_layer1 and loop_run:

                        if straight_line:

                            fit_end_layer1 += 1

                            fit = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                            residuals = x_data[fit_start_layer1:fit_end_layer1] *fit[0] + fit[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)

                            if r_squared > layer1_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer1 * noise_lvl_adapted:

                                straight_line = True

                            else:

                                straight_line = False
                                loop_run = False


                        else:

                            fit_start_layer1 = fit_start_layer1 + 1
                            fit_end_layer1 = fit_start_layer1 + fit_length_initial_layer1

                            fit = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                            residuals = x_data[fit_start_layer1:fit_end_layer1] *fit[0] + fit[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                            if r_squared > layer1_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer1 * noise_lvl_adapted:

                                straight_line = True
                                line_found_layer1 = True


            # 5. scale data and find stiff layer - layer 2
            line_found_layer2 = False

            #only fit layer 2 if there is a transition. otherwise there is probably no part significantly stiffer than soft EPS
            if transition_found:

                index_end_layer2 = index_transition

#            elif line_found_layer1:
#
#                index_end_layer2 = fit_end_layer1
#
#            else:
#
#                index_end_layer2 = int(self.settings['samples']['extend'] * layer2_parameters['fit_limit'])



                loop_run = True

                if indenter_characteristics['geometry'] == 'parabolic':

                    y_data_scaled_layer2 = np.power(copy.deepcopy(y_data),2/3)
                    index_end_layer2 = max(index_end_layer2, np.amax(np.where(np.isnan(y_data_scaled_layer2))) + 1) # make sure that no nan numbers are hit

                elif indenter_characteristics['geometry'] == 'conical' or indenter_characteristics['geometry'] == 'four-sided pyramid':

                    # scale data
                    y_data_scaled_layer2 = np.sqrt(copy.deepcopy(y_data))
                    index_end_layer2 = max(index_end_layer2, np.amax(np.where(np.isnan(y_data_scaled_layer2))) + 1) # make sure that no nan numbers are hit


                start_index_layer2 = self.settings['samples']['extend'] - 1
                fit_end_layer2 = start_index_layer2+1 #reversed as search moves in opposite direction
                fit_start_layer2 = fit_end_layer2 - fit_length_initial_layer2

                fit = np.polyfit(x_data[fit_start_layer2:fit_end_layer2], y_data_scaled_layer2[fit_start_layer2:fit_end_layer2],1)

                total_sum_of_squares = np.sum((y_data_scaled_layer2[fit_start_layer2:fit_end_layer2] - np.mean(y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]))**2 )
                residuals = x_data[fit_start_layer2:fit_end_layer2] *fit[0] + fit[1] - y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]
                squared_sum_residuals = np.sum(residuals**2)
                r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                if not layer2_parameters['with_residuals']:

                    if r_squared > layer2_parameters['r_squared_limit']:

                        straight_line = True
                        line_found_layer2 = True

                    else:

                        straight_line = False


                    while fit_start_layer2 > index_end_layer2 and loop_run:

                        if straight_line:

                            fit_start_layer2 -= 1

                            fit = np.polyfit(x_data[fit_start_layer2:fit_end_layer2], y_data_scaled_layer2[fit_start_layer2:fit_end_layer2],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer2[fit_start_layer2:fit_end_layer2] - np.mean(y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]))**2 )
                            residuals = x_data[fit_start_layer2:fit_end_layer2] *fit[0] + fit[1] - y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)

                            if r_squared > layer2_parameters['r_squared_limit']:

                                straight_line = True

                            else:

                                straight_line = False
                                loop_run = False

                        else:

                            fit_end_layer2 = fit_end_layer2 - 1
                            fit_start_layer2 = fit_end_layer2 - fit_length_initial_layer2

                            fit = np.polyfit(x_data[fit_start_layer2:fit_end_layer2], y_data_scaled_layer2[fit_start_layer2:fit_end_layer2],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer2:fit_end_layer2] - np.mean(y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]))**2 )
                            residuals = x_data[fit_start_layer2:fit_end_layer2] *fit[0] + fit[1] - y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                            if r_squared > layer2_parameters['r_squared_limit']:

                                straight_line = True
                                line_found_layer2 = True


                else:

                    if r_squared > layer2_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer2 * noise_lvl_adapted:

                        straight_line = True
                        line_found_layer2 = True

                    else:

                        straight_line = False


                    while fit_start_layer2 > index_end_layer2 and loop_run:

                        if straight_line:

                            fit_start_layer2 -= 1

                            fit = np.polyfit(x_data[fit_start_layer2:fit_end_layer2], y_data_scaled_layer2[fit_start_layer2:fit_end_layer2],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer2[fit_start_layer2:fit_end_layer2] - np.mean(y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]))**2 )
                            residuals = x_data[fit_start_layer2:fit_end_layer2] *fit[0] + fit[1] - y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)

                            if r_squared > layer2_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer2 * noise_lvl_adapted:

                                straight_line = True

                            else:

                                straight_line = False
                                loop_run = False

                        else:

                            fit_end_layer2 = fit_end_layer2 - 1
                            fit_start_layer2 = fit_end_layer2 - fit_length_initial_layer2

                            fit = np.polyfit(x_data[fit_start_layer2:fit_end_layer2], y_data_scaled_layer2[fit_start_layer2:fit_end_layer2],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer2:fit_end_layer2] - np.mean(y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]))**2 )
                            residuals = x_data[fit_start_layer2:fit_end_layer2] *fit[0] + fit[1] - y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                            if r_squared > layer2_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer2 * noise_lvl_adapted:

                                straight_line = True
                                line_found_layer2 = True


            else:

                index_end_layer2 = self.settings['samples']['extend']



            if line_found_layer1:

                fit_length_final_layer1 = fit_end_layer1 - fit_start_layer1
                fit_start_mod_layer1 = fit_start_layer1 + int(0.5*(1 - layer1_parameters['final_fit_fraction'])  * fit_length_final_layer1)
                fit_end_mod_layer1 = fit_start_layer1 + int(0.5 *(1 + layer1_parameters['final_fit_fraction']) * fit_length_final_layer1)

                fit_trim_layer1 = np.polyfit(x_data[fit_start_mod_layer1:fit_end_mod_layer1], y_data_scaled_layer1[fit_start_mod_layer1:fit_end_mod_layer1],1)

                # calculate the residuals

                residuals_linear_layer1 = x_data[fit_start_mod_layer1:fit_end_mod_layer1] *fit_trim_layer1[0] + fit_trim_layer1[1] - y_data_scaled_layer1[fit_start_mod_layer1:fit_end_mod_layer1]

                self.two_layer_hertz['best_fit']['layer1']['line_found'] = True
                self.two_layer_hertz['best_fit']['layer1']['index'] = (fit_start_mod_layer1,fit_end_mod_layer1-1)
                self.two_layer_hertz['best_fit']['layer1']['interval'] = (self.data['extend'][self.keys['ts_key']][fit_start_mod_layer1],self.data['extend'][self.keys['ts_key']][fit_end_mod_layer1-1])
                self.two_layer_hertz['best_fit']['layer1']['fit_parameter'] = - fit_trim_layer1[0]
                self.two_layer_hertz['best_fit']['layer1']['contact_point'] = dict()
                #contact point index as first point with value smaller than the calculated contact point
                self.two_layer_hertz['best_fit']['layer1']['contact_point']['index'] = np.argmax(self.data['extend'][self.keys['ts_key']] < -fit_trim_layer1[1]/fit_trim_layer1[0])
                self.two_layer_hertz['best_fit']['layer1']['contact_point']['value'] = -fit_trim_layer1[1]/fit_trim_layer1[0]

                self.two_layer_hertz['best_fit']['layer1']['specifics'] = dict()
                self.two_layer_hertz['best_fit']['layer1']['specifics']['start_index'] = start_index_layer1
                self.two_layer_hertz['best_fit']['layer1']['specifics']['full_index'] = (fit_start_layer1,fit_end_layer1-1)

                self.two_layer_hertz['residuals']['layer1']['unit'] = 'nN'

                self.two_layer_hertz['residuals']['layer1']['mean_linear_fit'] = np.mean(np.absolute(residuals_linear_layer1))
                self.two_layer_hertz['residuals']['layer1']['data_linear_fit'] = residuals_linear_layer1


                if indenter_characteristics['geometry'] == 'parabolic':

                    e_modul_layer1 = np.power(abs(fit_trim_layer1[0]),3/2) * (1 - poisson_ratio**2) * 3 / (4 * math.sqrt(indenter_characteristics['radius [nm]']))

                    x_fit = copy.deepcopy(x_data)
                    ind = -(x_fit - self.two_layer_hertz['best_fit']['layer1']['contact_point']['value'])
                    ind[ind<0] = 0
                    y_fit_layer1 = np.power(abs(fit_trim_layer1[0]),3/2) * np.power(ind,3/2)

                    residuals_layer1 = y_fit_layer1[fit_start_mod_layer1:fit_end_mod_layer1] - y_data[fit_start_mod_layer1:fit_end_mod_layer1]

                    self.two_layer_hertz['residuals']['layer1']['mean'] = np.mean(np.absolute(residuals_layer1))
                    self.two_layer_hertz['residuals']['layer1']['data'] = residuals_layer1



                elif indenter_characteristics['geometry'] == 'conical':

                    e_modul_layer1 = fit_trim_layer1[0]**2 * (1 - poisson_ratio**2) * np.pi / (2 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                    x_fit = copy.deepcopy(x_data)
                    ind = -(x_fit - self.two_layer_hertz['best_fit']['layer1']['contact_point']['value'])
                    ind[ind<0] = 0
                    y_fit_layer1 = fit_trim_layer1[0]**2 * ind**2

                    residuals_layer1 = y_fit_layer1[fit_start_mod_layer1:fit_end_mod_layer1] - y_data[fit_start_mod_layer1:fit_end_mod_layer1]

                    self.two_layer_hertz['residuals']['layer1']['mean'] = np.mean(np.absolute(residuals_layer1))
                    self.two_layer_hertz['residuals']['layer1']['data'] = residuals_layer1


                elif indenter_characteristics['geometry'] == 'four-sided pyramid':

                    e_modul_layer1 = fit_trim_layer1[0]**2 * (1 - poisson_ratio**2) / (0.7453 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                    x_fit = copy.deepcopy(x_data)
                    ind = -(x_fit - self.two_layer_hertz['best_fit']['layer1']['contact_point']['value'])
                    ind[ind<0] = 0
                    y_fit_layer1 = fit_trim_layer1[0]**2 * ind**2

                    residuals_layer1 = y_fit_layer1[fit_start_mod_layer1:fit_end_mod_layer1] - y_data[fit_start_mod_layer1:fit_end_mod_layer1]

                    self.two_layer_hertz['residuals']['layer1']['mean'] = np.mean(np.absolute(residuals_layer1))
                    self.two_layer_hertz['residuals']['layer1']['data'] = residuals_layer1


            else:

                self.two_layer_hertz['best_fit']['layer1']['line_found'] = False
                self.two_layer_hertz['residuals']['layer1'] = dict()



                e_modul_layer1 = np.nan


            if line_found_layer2:

                fit_length_final_layer2 = fit_end_layer2 - fit_start_layer2
                fit_end_mod_layer2 = fit_end_layer2
                # the issued for layer 2 seems to be rather the end points
                fit_start_mod_layer2 = fit_end_layer2 - int(layer2_parameters['final_fit_fraction'] * fit_length_final_layer2)
                #fit_start_mod_layer2 = fit_start_layer2 + int(0.5*(1 - layer2_parameters['final_fit_fraction'])  * fit_length_final_layer2)
                #fit_end_mod_layer2 = fit_start_layer2 + int(0.5 *(1 + layer2_parameters['final_fit_fraction']) * fit_length_final_layer2)

                fit_trim_layer2 = np.polyfit(x_data[fit_start_mod_layer2:fit_end_mod_layer2], y_data_scaled_layer2[fit_start_mod_layer2:fit_end_mod_layer2],1)

                # calculate the residuals

                residuals_linear_layer2 = x_data[fit_start_mod_layer2:fit_end_mod_layer2] *fit_trim_layer2[0] + fit_trim_layer2[1] - y_data_scaled_layer2[fit_start_mod_layer2:fit_end_mod_layer2]

                self.two_layer_hertz['best_fit']['layer2']['line_found'] = True
                self.two_layer_hertz['best_fit']['layer2']['index'] = (fit_start_mod_layer2,fit_end_mod_layer2)
                self.two_layer_hertz['best_fit']['layer2']['interval'] = (self.data['extend'][self.keys['ts_key']][fit_start_mod_layer2],self.data['extend'][self.keys['ts_key']][fit_end_mod_layer2-1])
                self.two_layer_hertz['best_fit']['layer2']['fit_parameter'] = - fit_trim_layer2[0]
                self.two_layer_hertz['best_fit']['layer2']['contact_point'] = dict()
                #contact point index as first point with value smaller than the calculated contact point
                self.two_layer_hertz['best_fit']['layer2']['contact_point']['index'] = np.argmax(self.data['extend'][self.keys['ts_key']] < -fit_trim_layer2[1]/fit_trim_layer2[0])
                self.two_layer_hertz['best_fit']['layer2']['contact_point']['value'] = -fit_trim_layer2[1]/fit_trim_layer2[0]

                self.two_layer_hertz['best_fit']['layer2']['specifics'] = dict()
                self.two_layer_hertz['best_fit']['layer2']['specifics']['start_index'] = start_index_layer2
                self.two_layer_hertz['best_fit']['layer2']['specifics']['full_index'] = (fit_start_layer2,fit_end_layer2-1)

                self.two_layer_hertz['residuals']['layer2']['unit'] = 'nN'

                self.two_layer_hertz['residuals']['layer2']['mean_linear_fit'] = np.mean(np.absolute(residuals_linear_layer2))
                self.two_layer_hertz['residuals']['layer2']['data_linear_fit'] = residuals_linear_layer2


                if indenter_characteristics['geometry'] == 'parabolic':

                    e_modul_layer2 = np.power(abs(fit_trim_layer2[0]),3/2) * (1 - poisson_ratio**2) * 3 / (4 * math.sqrt(indenter_characteristics['radius [nm]']))

                    x_fit = copy.deepcopy(x_data)
                    ind = -(x_fit - self.two_layer_hertz['best_fit']['layer2']['contact_point']['value'])
                    ind[ind<0] = 0
                    y_fit_layer2 = np.power(abs(fit_trim_layer2[0]),3/2) * np.power(ind,3/2)

                    residuals_layer2 = y_fit_layer2[fit_start_mod_layer2:fit_end_mod_layer2] - y_data[fit_start_mod_layer2:fit_end_mod_layer2]

                    self.two_layer_hertz['best_fit']['layer2']['mean'] = np.mean(np.absolute(residuals_layer2))
                    self.two_layer_hertz['best_fit']['layer2']['data'] = residuals_layer2



                elif indenter_characteristics['geometry'] == 'conical':

                    e_modul_layer2 = fit_trim_layer2[0]**2 * (1 - poisson_ratio**2) * np.pi / (2 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                    x_fit = copy.deepcopy(x_data)
                    ind = -(x_fit - self.two_layer_hertz['best_fit']['layer2']['contact_point']['value'])
                    ind[ind<0] = 0
                    y_fit_layer2 = fit_trim_layer2[0]**2 * ind**2

                    residuals_layer2 = y_fit_layer2[fit_start_mod_layer2:fit_end_mod_layer2] - y_data[fit_start_mod_layer2:fit_end_mod_layer2]

                    self.two_layer_hertz['residuals']['layer2']['mean'] = np.mean(np.absolute(residuals_layer2))
                    self.two_layer_hertz['residuals']['layer2']['data'] = residuals_layer2


                elif indenter_characteristics['geometry'] == 'four-sided pyramid':

                    e_modul_layer2 = fit_trim_layer2[0]**2 * (1 - poisson_ratio**2) / (0.7453 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                    x_fit = copy.deepcopy(x_data)
                    ind = -(x_fit - self.two_layer_hertz['best_fit']['layer2']['contact_point']['value'])
                    ind[ind<0] = 0
                    y_fit_layer2 = fit_trim_layer2[0]**2 * ind**2

                    residuals_layer2 = y_fit_layer2[fit_start_mod_layer2:fit_end_mod_layer2] - y_data[fit_start_mod_layer2:fit_end_mod_layer2]

                    self.two_layer_hertz['residuals']['layer2']['mean'] = np.mean(np.absolute(residuals_layer2))
                    self.two_layer_hertz['residuals']['layer2']['data'] = residuals_layer2

            else:

                self.two_layer_hertz['best_fit']['layer2']['line_found'] = False
                self.two_layer_hertz['residuals']['layer2'] = dict()

                e_modul_layer2 = np.nan




            self.two_layer_hertz['poisson_ratio'] = poisson_ratio
            self.two_layer_hertz['units'] = copy.deepcopy(self.units)

            e_modul_layer1 = e_modul_layer1 * 10**9
            e_modul_layer2 = e_modul_layer2 * 10**9
            e_modul_unit = 'Pa'
            e_modul_factor = 1

            self.two_layer_hertz['young_modulus']['layer1'] = {'value': e_modul_layer1, 'unit': e_modul_unit, 'factor': e_modul_factor}
            self.two_layer_hertz['young_modulus']['layer2'] = {'value': e_modul_layer2, 'unit': e_modul_unit, 'factor': e_modul_factor}


            retract_plot = False
            plot_linear = False

            if 'retract_plot' in kwargs and kwargs['retract_plot']:

                retract_plot = True

            if 'plot_linear' in kwargs and kwargs['plot_linear']:

                plot_linear = True



            if 'plot_result' in kwargs and kwargs['plot_result']:

                if indenter_characteristics['geometry'] == 'parabolic':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'
                elif indenter_characteristics['geometry'] == 'conical':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Angle: ' +'%.2f' % indenter_characteristics['angle [grad]']+ ' grad'
                elif indenter_characteristics['geometry'] == 'four-sided pyramid':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Angle: ' +'%.2f' % indenter_characteristics['angle [grad]']+ ' grad'
                elif indenter_characteristics['geometry'] == 'cylindrical':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'


                x_plot = x_data * (1e-09 / self.units['distance']['factor'])

                if 'ax' in kwargs:

                    ax = kwargs['ax']

                else:

                    fig = plt.figure()
                    ax = fig.add_axes([0.15, 0.15, 0.75, 0.75])


                ax.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend', color = '#1f77b4ff')

                if retract_plot:

                    ax.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['y_key']], label = 'retract', color = '#ff7e0eff')



                if line_found_layer1:

                    y_plot_layer1 = y_fit_layer1 * (1e-09 / self.units['force']['factor'])

                    text1 = 'Young\'s modulus layer1: %.2f' % self.two_layer_hertz['young_modulus']['layer1']['value'] + ' ' + self.two_layer_hertz['young_modulus']['layer1']['unit'] + '\nContact point: ' +'%.2f' % self.two_layer_hertz['best_fit']['layer1']['contact_point']['value'] + ' ' + self.two_layer_hertz['units']['distance']['unit']
                    text2 = '\nFit index: (' + str(self.two_layer_hertz['best_fit']['layer1']['index'][0]) +', ' + str(self.two_layer_hertz['best_fit']['layer1']['index'][1])  + ')'
                    text3 = '\nFit parameter: a = %.2e' % self.two_layer_hertz['best_fit']['layer1']['fit_parameter']

                    ax.plot(x_plot, y_plot_layer1, label = 'lin. hertz model - layer 1 - complete', color = '#c8ab37ff', linestyle = '--')
                    ax.plot(x_plot[fit_start_mod_layer1:fit_end_mod_layer1], y_plot_layer1[fit_start_mod_layer1:fit_end_mod_layer1], label = 'lin. hertz model - layer 1 - fit range', color = '#ff053bff')

                else:

                    text1 = 'No soft layer detected\n'
                    text2 = ''
                    text3 = ''


                if line_found_layer2:

                    y_plot_layer2 = y_fit_layer2 * (1e-09 / self.units['force']['factor'])

                    text5 = '\nYoung\'s modulus layer2: %.2f' % self.two_layer_hertz['young_modulus']['layer2']['value'] + ' ' + self.two_layer_hertz['young_modulus']['layer2']['unit'] + '\n Virtual contact point: ' +'%.2f' % self.two_layer_hertz['best_fit']['layer2']['contact_point']['value'] + ' ' + self.two_layer_hertz['units']['distance']['unit']
                    text6 = '\nFit index: (' + str(self.two_layer_hertz['best_fit']['layer2']['index'][0]) +', ' + str(self.two_layer_hertz['best_fit']['layer2']['index'][1])  + ')'
                    text7 = '\nFit parameter: a = %.2e' % self.two_layer_hertz['best_fit']['layer2']['fit_parameter']

                    ax.plot(x_plot, y_plot_layer2, label = 'lin. hertz model - layer 2 - complete', color = '#abc837ff', linestyle = '--')
                    ax.plot(x_plot[fit_start_mod_layer2:fit_end_mod_layer2], y_plot_layer2[fit_start_mod_layer2:fit_end_mod_layer2], label = 'lin. hertz model - layer 2 - fit range', color = '#dd55ffff')

                else:

                    text5 = '\nNo stiff layer detected\n'
                    text6 = ''
                    text7 = ''


                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                ax.legend()
                ax.tick_params(direction = 'in', top = True, right = True)

                textstr = text1 + text2 + text3 + text5 + text6 + text7 + text4

                bbox_args = dict(boxstyle="round", fc= (1,1,1))
                an1 = ax.annotate(textstr, xy=(.23, .7), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox=bbox_args)
                an1.draggable() #allows to drag the box arround


                if plot_linear:

                    fig_lin = plt.figure()
                    ax_lin = fig_lin.add_axes([0.15, 0.15, 0.75, 0.75])
                    ax_lin.plot(x_data,y_data_scaled_layer2, label = 'scaled data')
                    ax_lin.plot(x_data,y_data_scaled_layer1, label = 'smoothened scaled data')

                    if line_found_layer1:

                        ax_lin.plot(x_data[fit_start_mod_layer1:fit_end_mod_layer1], x_data[fit_start_mod_layer1:fit_end_mod_layer1] *fit_trim_layer1[0] + fit_trim_layer1[1], label = 'linear fit - layer 1', color = '#ff053bff')



                    if line_found_layer2:

                        ax_lin.plot(x_data[fit_start_mod_layer2:fit_end_mod_layer2], x_data[fit_start_mod_layer2:fit_end_mod_layer2] *fit_trim_layer2[0] + fit_trim_layer2[1], label = 'linear fit - layer 2', color = '#dd55ffff')

                    ax_lin.set_title('Smoothened and Scaled Extend Data')
                    ax_lin.tick_params(direction = 'in', top = True, right = True)
                    ax_lin.legend()


            export = False

            if 'export_result' in kwargs:

                if type(kwargs['export_result']) is bool:

                    export = kwargs['export_result']
                    fileformat = ['svg', 'pdf', 'png', 'txt', 'pkl']

                elif type(kwargs['export_result']) is str:

                    fileformat = [kwargs['export_result']]
                    export = True

                elif type(kwargs['export_result']) is list:

                    fileformat = kwargs['export_result']
                    export = True

            if export:

                #fig_formats = ['svg', 'pdf', 'png', 'jpg']
                fig_export = [f for f in fileformat if f in ['svg', 'pdf', 'png', 'jpg']]

                plt.ioff()

                if indenter_characteristics['geometry'] == 'parabolic':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'
                elif indenter_characteristics['geometry'] == 'conical':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Angle: ' +'%.2f' % indenter_characteristics['angle [grad]']+ ' grad'
                elif indenter_characteristics['geometry'] == 'four-sided pyramid':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Angle: ' +'%.2f' % indenter_characteristics['angle [grad]']+ ' grad'
                elif indenter_characteristics['geometry'] == 'cylindrical':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'


                x_plot = x_data * (1e-09 / self.units['distance']['factor'])


                fig_exp = plt.figure()
                ax_exp = fig_exp.add_axes([0.15, 0.15, 0.75, 0.75])

                ax_exp.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend', color = '#1f77b4ff')

                if retract_plot:

                    ax_exp.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['ts_key']], label = 'retract', color = '#ff7e0eff')


                if line_found_layer1:

                    y_plot_layer1 = y_fit_layer1 * (1e-09 / self.units['force']['factor'])

                    text1 = 'Young\'s modulus layer1: %.2f' % self.two_layer_hertz['young_modulus']['layer1']['value'] + ' ' + self.two_layer_hertz['young_modulus']['layer1']['unit'] + '\nContact point: ' +'%.2f' % self.two_layer_hertz['best_fit']['layer1']['contact_point']['value'] + ' ' + self.two_layer_hertz['units']['unit']
                    text2 = '\nFit index: (' + str(self.two_layer_hertz['best_fit']['layer1']['index'][0]) +', ' + str(self.two_layer_hertz['best_fit']['layer1']['index'][1])  + ')'
                    text3 = '\nFit parameter: a = %.2e' % self.two_layer_hertz['best_fit']['layer1']['fit_parameter']

                    ax_exp.plot(x_plot, y_plot_layer1, label = 'lin. hertz model - layer 1 - complete', color = '#c8ab37ff', linestyle = '--')
                    ax_exp.plot(x_plot[fit_start_mod_layer1:fit_end_mod_layer1], y_plot_layer1[fit_start_mod_layer1:fit_end_mod_layer1], label = 'lin. hertz model - layer 1 - fit range', color = '#ff053bff')

                else:

                    text1 = 'No soft layer detected\n'
                    text2 = ''
                    text3 = ''


                if line_found_layer2:

                    y_plot_layer2 = y_fit_layer2 * (1e-09 / self.units['force']['factor'])

                    text5 = '\nYoung\'s modulus layer2: %.2f' % self.two_layer_hertz['young_modulus']['layer2']['value'] + ' ' + self.two_layer_hertz['young_modulus']['layer2']['unit'] + '\n Virtual contact point: ' +'%.2f' % self.two_layer_hertz['best_fit']['layer2']['contact_point']['value'] + ' ' + self.two_layer_hertz['units']['distance']['unit']
                    text6 = '\nFit index: (' + str(self.two_layer_hertz['best_fit']['layer2']['index'][0]) +', ' + str(self.two_layer_hertz['best_fit']['layer2']['index'][1])  + ')'
                    text7 = '\nFit parameter: a = %.2e' % self.two_layer_hertz['best_fit']['layer2']['fit_parameter']

                    ax_exp.plot(x_plot, y_plot_layer2, label = 'lin. hertz model - layer 2 - complete', color = '#abc837ff', linestyle = '--')
                    ax_exp.plot(x_plot[fit_start_mod_layer2:fit_end_mod_layer2], y_plot_layer2[fit_start_mod_layer2:fit_end_mod_layer2], label = 'lin. hertz model - layer 2 - fit range', color = '#dd55ffff')

                else:

                    text5 = '\nNo stiff layer detected\n'
                    text6 = ''
                    text7 = ''


                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                ax_exp.legend()
                ax_exp.tick_params(direction = 'in', top = True, right = True)

                textstr = text1 + text2 + text3 + text4

                bbox_args = dict(boxstyle="round", fc= (1,1,1))
                ax_exp.annotate(textstr, xy=(.23, .7), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox=bbox_args)


                if not os.path.isdir(os.path.join(self.file_info['save_directory'], 'two_layer_detection')):

                    os.makedirs(os.path.join(self.file_info['save_directory'], 'two_layer_detection'))


                for f in fig_export:

                    filename = os.path.join(self.file_info['save_directory'], 'two_layer_detection', 'two_layer_detection_linear_' + self.file_info['file_org'] + '.' + f)

                    try:

                         plt.savefig(filename)

                    except:

                          sys.stderr.write('ERROR! Cannot open/write file ' + filename)


                plt.close(fig_exp)

                plt.ion()

                if 'pkl' in fileformat:

                     try:

                        file_pickle = os.path.join(self.file_info['save_directory'], 'two_layer_detection', 'two_layer_detection_linear_' + self.file_info['file_org'] + '.pkl')
                        out_pkl = open(file_pickle, 'wb')

                        pickle.dump(self.two_layer_hertz, out_pkl)

                     except:

                          sys.stderr.write('ERROR! Cannot open/write file ' + file_pickle)

                     finally:

                          out_pkl.close()


        else:

            raise ValueError('ERROR! Data are not prepared for analysis. Perform corrections first.')



    def fit_two_layer_linearized_hertz_model_debug(self,
                        poisson_ratio = 0.5,
                        indenter_characteristics = {'geometry': 'parabolic', 'radius [nm]': 10},
                        transition_sensitivity = 1,
                        filter_correction_fraction = 0.5,
                        **kwargs):

        layer1_parameters = {'start_fit_length': 'automatic',
                             'savgol_filter_characteristics': {'length': 51, 'order': 1, 'deriv': 0, 'delta': 1.0, 'axis': -1, 'mode': 'interp', 'cval': 0.0},
                             'r_squared_limit':  0.98,
                             'residual_sensitivity': 1,
                             'final_fit_fraction': 0.8,
                             'with_residuals': True}

        layer2_parameters = {'start_fit_length': 'automatic',
                             #'savgol_filter_characteristics': {'length': 51, 'order': 1},
                             'r_squared_limit':  0.98,
                             'residual_sensitivity': 1,
                             'final_fit_fraction': 0.9,
                             'with_residuals': True,}


        if 'layer1_parameters' in kwargs:

            for key in kwargs['layer1_parameters'].keys():

                layer1_parameters[key] = kwargs['layer1_parameters'][key]


        if 'layer2_parameters' in kwargs:

            for key in kwargs['layer2_parameters'].keys():

                layer2_parameters[key] = kwargs['layer2_parameters'][key]



        residual_fac_layer1 = 5 - math.log10(layer1_parameters['residual_sensitivity'])
        residual_fac_layer2 = 5 - math.log10(layer2_parameters['residual_sensitivity'])
        transition_fac = 5 - math.log10(transition_sensitivity)


        if self.control_variables['allow_analysis']:

            self.two_layer_hertz = dict()
            self.two_layer_hertz['indenter'] = indenter_characteristics

            self.two_layer_hertz['method'] = dict()
            self.two_layer_hertz['method']['type'] = 'linear'
            self.two_layer_hertz['method']['parameter'] = dict()
            self.two_layer_hertz['method']['parameter']['transition_sensitivity'] = transition_sensitivity
            self.two_layer_hertz['method']['parameter']['transition_factor'] = transition_fac

            self.two_layer_hertz['method']['parameter']['layer1'] = dict()
            self.two_layer_hertz['method']['parameter']['layer1']['r_squared_limit'] = layer1_parameters['r_squared_limit']
            self.two_layer_hertz['method']['parameter']['layer1']['with_residuals'] = layer1_parameters['with_residuals']
            self.two_layer_hertz['method']['parameter']['layer1']['residual_sensitivity'] = layer1_parameters['residual_sensitivity']
            self.two_layer_hertz['method']['parameter']['layer1']['residual_factor'] = residual_fac_layer1
            self.two_layer_hertz['method']['parameter']['layer1']['final_fit_fraction'] = layer1_parameters['final_fit_fraction']

            self.two_layer_hertz['method']['parameter']['layer2'] = dict()
            self.two_layer_hertz['method']['parameter']['layer2']['r_squared_limit'] = layer2_parameters['r_squared_limit']
            self.two_layer_hertz['method']['parameter']['layer2']['with_residuals'] = layer2_parameters['with_residuals']
            self.two_layer_hertz['method']['parameter']['layer2']['residual_sensitivity'] = layer2_parameters['residual_sensitivity']
            self.two_layer_hertz['method']['parameter']['layer2']['residual_factor'] = residual_fac_layer2
            self.two_layer_hertz['method']['parameter']['layer2']['final_fit_fraction'] = layer2_parameters['final_fit_fraction']


            self.two_layer_hertz['filter'] = dict()
            self.two_layer_hertz['filter']['layer1'] = dict()
            self.two_layer_hertz['filter']['layer1']['type'] = 'savitzky-golay'
            self.two_layer_hertz['filter']['layer1']['parameter'] = dict()
            self.two_layer_hertz['filter']['layer1']['parameter']['length'] = layer1_parameters['savgol_filter_characteristics']['length']
            self.two_layer_hertz['filter']['layer1']['parameter']['order'] = layer1_parameters['savgol_filter_characteristics']['order']

            self.two_layer_hertz['best_fit'] = dict()
            self.two_layer_hertz['best_fit']['layer1'] = dict()
            self.two_layer_hertz['best_fit']['layer2'] = dict()

            self.two_layer_hertz['residuals'] = dict()
            self.two_layer_hertz['residuals']['layer1'] = dict()
            self.two_layer_hertz['residuals']['layer2'] = dict()

            self.two_layer_hertz['young_modulus'] = dict()

            x_data = self.data['extend'][self.keys['ts_key']] / (1e-09 / self.units['distance']['factor'])
            y_data = self.data['extend'][self.keys['y_key']] / (1e-09 / self.units['force']['factor'])
            noise_lvl_adapted = self.noise_level['value'] / (1e-09 / self.units['force']['factor'])

            # 1. smooth data
            y_data_savgol_layer1 = savgol_filter(y_data,layer1_parameters['savgol_filter_characteristics']['length'],
                                                 layer1_parameters['savgol_filter_characteristics']['order'],
                                                 deriv = layer1_parameters['savgol_filter_characteristics']['deriv'],
                                                 delta = layer1_parameters['savgol_filter_characteristics']['delta'],
                                                 axis = layer1_parameters['savgol_filter_characteristics']['axis'],
                                                 mode = layer1_parameters['savgol_filter_characteristics']['mode'],
                                                 cval = layer1_parameters['savgol_filter_characteristics']['cval'])


            # 2. find "transition" point where smoothing does not work anymore
            diff_data = y_data - y_data_savgol_layer1
            diff_data_std = np.std(diff_data[0:int(self.settings['samples']['extend']*0.2)])


            transition_found = False
            i = 0

            while not transition_found and i < self.settings['samples']['extend'] - 1:

                if abs(diff_data[i]) > diff_data_std * transition_fac:

                    transition_found = True

                else:

                    i += 1


            index_transition = i - int(filter_correction_fraction*layer1_parameters['savgol_filter_characteristics']['length'])

            self.two_layer_hertz['method']['parameter']['layer_transition'] = dict()
            self.two_layer_hertz['method']['parameter']['layer_transition']['detected'] = transition_found

            if transition_found:

                self.two_layer_hertz['method']['parameter']['layer_transition']['index'] = index_transition


            # 3. find transition between two regimes
            # if transition is found than only look up to that point for first regime

            if transition_found:

                index_end_layer1 = index_transition

            else:

                index_end_layer1 = self.settings['samples']['extend']


            if layer1_parameters['start_fit_length'] == 'automatic':

                fit_length_initial_layer1 = max(int(self.settings['samples']['extend'] * 0.1),2 * (layer1_parameters['savgol_filter_characteristics']['length'] - 1))
                #fit_length_initial_layer1 = 2 * (layer1_parameters['savgol_filter_characteristics']['length'] - 1)

            elif type(layer1_parameters['start_fit_length']) is int and layer1_parameters['start_fit_length'] > 0:

                fit_length_initial_layer1 = layer1_parameters['start_fit_length']

            else:

                fit_length_initial_layer1 = max(int(self.settings['samples']['extend'] * 0.1),2 * (layer1_parameters['savgol_filter_characteristics']['length'] - 1))


            if layer2_parameters['start_fit_length'] == 'automatic':

                fit_length_initial_layer2 = max(10,int(self.settings['samples']['extend'] * 0.02))

            elif type(layer2_parameters['start_fit_length']) is int and layer2_parameters['start_fit_length'] > 0:

                fit_length_initial_layer2 = layer2_parameters['start_fit_length']

            else:

                fit_length_initial_layer2 = max(10,int(self.settings['samples']['extend'] * 0.02))



            self.two_layer_hertz['method']['parameter']['layer1']['start_fit_length'] = fit_length_initial_layer1
            self.two_layer_hertz['method']['parameter']['layer2']['start_fit_length'] = fit_length_initial_layer2


            # 4. scale data and find soft layer - layer 1
            line_found_layer1 = False
            loop_run = True

            if indenter_characteristics['geometry'] == 'parabolic':

                y_data_scaled_layer1 = np.power(y_data_savgol_layer1,2/3)
                start_index_layer1 = np.amax(np.where(np.isnan(y_data_scaled_layer1))) + 1

            elif indenter_characteristics['geometry'] == 'conical' or indenter_characteristics['geometry'] == 'four-sided pyramid':

                # scale data
                y_data_scaled_layer1 = np.sqrt(y_data_savgol_layer1)
                # find the correct starting index
                start_index_layer1 = np.amax(np.where(np.isnan(y_data_scaled_layer1))) + 1


            fit_start_layer1 = start_index_layer1 + 1
            fit_end_layer1 = fit_start_layer1 + fit_length_initial_layer1

            if fit_end_layer1 > index_end_layer1 or start_index_layer1 > index_end_layer1:

                loop_run = False

            else:

                # fit and determine quality of fit
                fit_layer1 = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                residuals = x_data[fit_start_layer1:fit_end_layer1] *fit_layer1[0] + fit_layer1[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                squared_sum_residuals = np.sum(residuals**2)
                r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)

                print('layer1:', fit_start_layer1, fit_end_layer1, r_squared, np.sqrt(squared_sum_residuals))

                if not layer1_parameters['with_residuals']:

                    if r_squared > layer1_parameters['r_squared_limit']:

                        straight_line = True
                        line_found_layer1 = True

                    else:

                        straight_line = False


                    while fit_end_layer1 < index_end_layer1 and loop_run:

                        if straight_line:

                            fit_end_layer1 += 1

                            fit_layer1 = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                            residuals = x_data[fit_start_layer1:fit_end_layer1] *fit_layer1[0] + fit_layer1[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)
                            print('layer1:', fit_start_layer1, fit_end_layer1, r_squared, np.sqrt(squared_sum_residuals), line_found_layer1)

                            if r_squared > layer1_parameters['r_squared_limit']:

                                straight_line = True

                            else:

                                straight_line = False
                                loop_run = False


                        else:

                            fit_start_layer1 = fit_start_layer1 + 1
                            fit_end_layer1 = fit_start_layer1 + fit_length_initial_layer1

                            fit_layer1 = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                            residuals = x_data[fit_start_layer1:fit_end_layer1] *fit_layer1[0] + fit_layer1[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)
                            print('layer1:', fit_start_layer1, fit_end_layer1, r_squared, np.sqrt(squared_sum_residuals), line_found_layer1)

                            if r_squared > layer1_parameters['r_squared_limit']:

                                straight_line = True
                                line_found_layer1 = True


                else:

                    if r_squared > layer1_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer1 * noise_lvl_adapted:

                        straight_line = True
                        line_found_layer1 = True

                    else:

                        straight_line = False


                    while fit_end_layer1 < index_end_layer1 and loop_run:

                        if straight_line:

                            fit_end_layer1 += 1

                            fit_layer1 = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                            residuals = x_data[fit_start_layer1:fit_end_layer1] *fit_layer1[0] + fit_layer1[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)
                            print('layer1:', fit_start_layer1, fit_end_layer1, r_squared, np.sqrt(squared_sum_residuals), line_found_layer1)

                            if r_squared > layer1_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer1 * noise_lvl_adapted:

                                straight_line = True

                            else:

                                straight_line = False
                                loop_run = False


                        else:

                            fit_start_layer1 = fit_start_layer1 + 1
                            fit_end_layer1 = fit_start_layer1 + fit_length_initial_layer1

                            fit_layer1 = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                            residuals = x_data[fit_start_layer1:fit_end_layer1] *fit_layer1[0] + fit_layer1[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)
                            print('layer1:', fit_start_layer1, fit_end_layer1, r_squared, np.sqrt(squared_sum_residuals), line_found_layer1)


                            if r_squared > layer1_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer1 * noise_lvl_adapted:

                                straight_line = True
                                line_found_layer1 = True


            print('========LAYER 2========')
            # 5. scale data and find stiff layer - layer 2
            line_found_layer2 = False

            if transition_found:

                index_end_layer2 = index_transition


                loop_run = True

                if indenter_characteristics['geometry'] == 'parabolic':

                    y_data_scaled_layer2 = np.power(copy.deepcopy(y_data),2/3)
                    index_end_layer2 = max(index_end_layer2, np.amax(np.where(np.isnan(y_data_scaled_layer2))) + 1) # make sure that no nan numbers are hit


                elif indenter_characteristics['geometry'] == 'conical' or indenter_characteristics['geometry'] == 'four-sided pyramid':

                    # scale data
                    y_data_scaled_layer2 = np.sqrt(copy.deepcopy(y_data))
                    index_end_layer2 = max(index_end_layer2, np.amax(np.where(np.isnan(y_data_scaled_layer2))) + 1) # make sure that no nan numbers are hit


                start_index_layer2 = self.settings['samples']['extend']-1
                fit_end_layer2 = start_index_layer2+1 #reversed as search moves in opposite direction
                fit_start_layer2 = fit_end_layer2 - fit_length_initial_layer2

                fit_layer2 = np.polyfit(x_data[fit_start_layer2:fit_end_layer2], y_data_scaled_layer2[fit_start_layer2:fit_end_layer2],1)

                total_sum_of_squares = np.sum((y_data_scaled_layer2[fit_start_layer2:fit_end_layer2] - np.mean(y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]))**2 )
                residuals = x_data[fit_start_layer2:fit_end_layer2] *fit_layer2[0] + fit_layer2[1] - y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]
                squared_sum_residuals = np.sum(residuals**2)
                r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)

                print('layer2:', fit_start_layer2, fit_end_layer2-1, r_squared, np.sqrt(squared_sum_residuals))


                if not layer2_parameters['with_residuals']:

                    if r_squared > layer2_parameters['r_squared_limit']:

                        straight_line = True
                        line_found_layer2 = True

                    else:

                        straight_line = False


                    while fit_start_layer2 > index_end_layer2 and loop_run:

                        if straight_line:

                            fit_start_layer2 -= 1

                            fit_layer2 = np.polyfit(x_data[fit_start_layer2:fit_end_layer2], y_data_scaled_layer2[fit_start_layer2:fit_end_layer2],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer2[fit_start_layer2:fit_end_layer2] - np.mean(y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]))**2 )
                            residuals = x_data[fit_start_layer2:fit_end_layer2] *fit_layer2[0] + fit_layer2[1] - y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)
                            print('layer2:', fit_start_layer2, fit_end_layer2-1, r_squared, np.sqrt(squared_sum_residuals), line_found_layer2)

                            if r_squared > layer2_parameters['r_squared_limit']:

                                straight_line = True

                            else:

                                straight_line = False
                                loop_run = False

                        else:

                            fit_end_layer2 = fit_end_layer2 - 1
                            fit_start_layer2 = fit_end_layer2 - fit_length_initial_layer2

                            fit_layer2 = np.polyfit(x_data[fit_start_layer2:fit_end_layer2], y_data_scaled_layer2[fit_start_layer2:fit_end_layer2],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer2:fit_end_layer2] - np.mean(y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]))**2 )
                            residuals = x_data[fit_start_layer2:fit_end_layer2] *fit_layer2[0] + fit_layer2[1] - y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)
                            print('layer2:', fit_start_layer2, fit_end_layer2-1, r_squared, np.sqrt(squared_sum_residuals), line_found_layer2)


                            if r_squared > layer2_parameters['r_squared_limit']:

                                straight_line = True
                                line_found_layer2 = True


                else:

                    if r_squared > layer2_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer2 * noise_lvl_adapted:

                        straight_line = True
                        line_found_layer2 = True

                    else:

                        straight_line = False


                    while fit_start_layer2 > index_end_layer2 and loop_run:

                        if straight_line:

                            fit_start_layer2 -= 1

                            fit_layer2 = np.polyfit(x_data[fit_start_layer2:fit_end_layer2], y_data_scaled_layer2[fit_start_layer2:fit_end_layer2],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer2[fit_start_layer2:fit_end_layer2] - np.mean(y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]))**2 )
                            residuals = x_data[fit_start_layer2:fit_end_layer2] *fit_layer2[0] + fit_layer2[1] - y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)
                            print('layer2:', fit_start_layer2, fit_end_layer2-1, r_squared, np.sqrt(squared_sum_residuals), line_found_layer2)

                            if r_squared > layer2_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer2 * noise_lvl_adapted:

                                straight_line = True

                            else:

                                straight_line = False
                                loop_run = False

                        else:

                            fit_end_layer2 = fit_end_layer2 - 1
                            fit_start_layer2 = fit_end_layer2 - fit_length_initial_layer2

                            fit_layer2 = np.polyfit(x_data[fit_start_layer2:fit_end_layer2], y_data_scaled_layer2[fit_start_layer2:fit_end_layer2],1)

                            total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer2:fit_end_layer2] - np.mean(y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]))**2 )
                            residuals = x_data[fit_start_layer2:fit_end_layer2] *fit_layer2[0] + fit_layer2[1] - y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]
                            squared_sum_residuals = np.sum(residuals**2)
                            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)
                            print('layer2:', fit_start_layer2, fit_end_layer2-1, r_squared, np.sqrt(squared_sum_residuals), line_found_layer2)


                            if r_squared > layer2_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer2 * noise_lvl_adapted:

                                straight_line = True
                                line_found_layer2 = True



            else:

                index_end_layer2 = self.settings['samples']['extend']


            if line_found_layer1:

                fit_length_final_layer1 = fit_end_layer1 - fit_start_layer1
                fit_start_mod_layer1 = fit_start_layer1 + int(0.5*(1 - layer1_parameters['final_fit_fraction'])  * fit_length_final_layer1)
                fit_end_mod_layer1 = fit_start_layer1 + int(0.5 *(1 + layer1_parameters['final_fit_fraction']) * fit_length_final_layer1)

                fit_trim_layer1 = np.polyfit(x_data[fit_start_mod_layer1:fit_end_mod_layer1], y_data_scaled_layer1[fit_start_mod_layer1:fit_end_mod_layer1],1)

                # calculate the residuals

                residuals_linear_layer1 = x_data[fit_start_mod_layer1:fit_end_mod_layer1] *fit_trim_layer1[0] + fit_trim_layer1[1] - y_data_scaled_layer1[fit_start_mod_layer1:fit_end_mod_layer1]

                self.two_layer_hertz['best_fit']['layer1']['line_found'] = True
                self.two_layer_hertz['best_fit']['layer1']['index'] = (fit_start_mod_layer1,fit_end_mod_layer1-1)
                self.two_layer_hertz['best_fit']['layer1']['interval'] = (self.data['extend'][self.keys['ts_key']][fit_start_mod_layer1],self.data['extend'][self.keys['ts_key']][fit_end_mod_layer1-1])
                self.two_layer_hertz['best_fit']['layer1']['fit_parameter'] = - fit_trim_layer1[0]
                self.two_layer_hertz['best_fit']['layer1']['contact_point'] = dict()
                #contact point index as first point with value smaller than the calculated contact point
                self.two_layer_hertz['best_fit']['layer1']['contact_point']['index'] = np.argmax(self.data['extend'][self.keys['ts_key']] < -fit_trim_layer1[1]/fit_trim_layer1[0])
                self.two_layer_hertz['best_fit']['layer1']['contact_point']['value'] = -fit_trim_layer1[1]/fit_trim_layer1[0]

                self.two_layer_hertz['best_fit']['layer1']['specifics'] = dict()
                self.two_layer_hertz['best_fit']['layer1']['specifics']['start_index'] = start_index_layer1
                self.two_layer_hertz['best_fit']['layer1']['specifics']['full_index'] = (fit_start_layer1,fit_end_layer1-1)

                self.two_layer_hertz['residuals']['layer1']['unit'] = 'nN'

                self.two_layer_hertz['residuals']['layer1']['mean_linear_fit'] = np.mean(np.absolute(residuals_linear_layer1))
                self.two_layer_hertz['residuals']['layer1']['data_linear_fit'] = residuals_linear_layer1


                if indenter_characteristics['geometry'] == 'parabolic':

                    e_modul_layer1 = np.power(abs(fit_trim_layer1[0]),3/2) * (1 - poisson_ratio**2) * 3 / (4 * math.sqrt(indenter_characteristics['radius [nm]']))

                    x_fit = copy.deepcopy(x_data)
                    ind = -(x_fit - self.two_layer_hertz['best_fit']['layer1']['contact_point']['value'])
                    ind[ind<0] = 0
                    y_fit_layer1 = np.power(abs(fit_trim_layer1[0]),3/2) * np.power(ind,3/2)

                    residuals_layer1 = y_fit_layer1[fit_start_mod_layer1:fit_end_mod_layer1] - y_data[fit_start_mod_layer1:fit_end_mod_layer1]

                    self.two_layer_hertz['residuals']['layer1']['mean'] = np.mean(np.absolute(residuals_layer1))
                    self.two_layer_hertz['residuals']['layer1']['data'] = residuals_layer1


                elif indenter_characteristics['geometry'] == 'conical':

                    e_modul_layer1 = fit_trim_layer1[0]**2 * (1 - poisson_ratio**2) * np.pi / (2 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                    x_fit = copy.deepcopy(x_data)
                    ind = -(x_fit - self.two_layer_hertz['best_fit']['layer1']['contact_point']['value'])
                    ind[ind<0] = 0
                    y_fit_layer1 = fit_trim_layer1[0]**2 * ind**2

                    residuals_layer1 = y_fit_layer1[fit_start_mod_layer1:fit_end_mod_layer1] - y_data[fit_start_mod_layer1:fit_end_mod_layer1]

                    self.two_layer_hertz['residuals']['layer1']['mean'] = np.mean(np.absolute(residuals_layer1))
                    self.two_layer_hertz['residuals']['layer1']['data'] = residuals_layer1


                elif indenter_characteristics['geometry'] == 'four-sided pyramid':

                    e_modul_layer1 = fit_trim_layer1[0]**2 * (1 - poisson_ratio**2) / (0.7453 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                    x_fit = copy.deepcopy(x_data)
                    ind = -(x_fit - self.two_layer_hertz['best_fit']['layer1']['contact_point']['value'])
                    ind[ind<0] = 0
                    y_fit_layer1 = fit_trim_layer1[0]**2 * ind**2

                    residuals_layer1 = y_fit_layer1[fit_start_mod_layer1:fit_end_mod_layer1] - y_data[fit_start_mod_layer1:fit_end_mod_layer1]

                    self.two_layer_hertz['residuals']['layer1']['mean'] = np.mean(np.absolute(residuals_layer1))
                    self.two_layer_hertz['residuals']['layer1']['data'] = residuals_layer1

            else:

                self.two_layer_hertz['best_fit']['layer1']['line_found'] = False
                self.two_layer_hertz['residuals']['layer1'] = dict()

                e_modul_layer1 = np.nan


            if line_found_layer2:

                fit_length_final_layer2 = fit_end_layer2 - fit_start_layer2
                fit_end_mod_layer2 = fit_end_layer2
                # the issued for layer 2 seems to be rather the end points
                fit_start_mod_layer2 = fit_end_layer2 - int(layer2_parameters['final_fit_fraction'] * fit_length_final_layer2)
                #fit_start_mod_layer2 = fit_start_layer2 + int(0.5*(1 - layer2_parameters['final_fit_fraction'])  * fit_length_final_layer2)
                #fit_end_mod_layer2 = fit_start_layer2 + int(0.5 *(1 + layer2_parameters['final_fit_fraction']) * fit_length_final_layer2)

                fit_trim_layer2 = np.polyfit(x_data[fit_start_mod_layer2:fit_end_mod_layer2], y_data_scaled_layer2[fit_start_mod_layer2:fit_end_mod_layer2],1)

                # calculate the residuals

                residuals_linear_layer2 = x_data[fit_start_mod_layer2:fit_end_mod_layer2] *fit_trim_layer2[0] + fit_trim_layer2[1] - y_data_scaled_layer2[fit_start_mod_layer2:fit_end_mod_layer2]

                self.two_layer_hertz['best_fit']['layer2']['line_found'] = True
                self.two_layer_hertz['best_fit']['layer2']['index'] = (fit_start_mod_layer2,fit_end_mod_layer2-1)
                self.two_layer_hertz['best_fit']['layer2']['interval'] = (self.data['extend'][self.keys['ts_key']][fit_start_mod_layer2],self.data['extend'][self.keys['ts_key']][fit_end_mod_layer2-1])
                self.two_layer_hertz['best_fit']['layer2']['fit_parameter'] = - fit_trim_layer2[0]
                self.two_layer_hertz['best_fit']['layer2']['contact_point'] = dict()
                #contact point index as first point with value smaller than the calculated contact point
                self.two_layer_hertz['best_fit']['layer2']['contact_point']['index'] = np.argmax(self.data['extend'][self.keys['ts_key']] < -fit_trim_layer2[1]/fit_trim_layer2[0])
                self.two_layer_hertz['best_fit']['layer2']['contact_point']['value'] = -fit_trim_layer2[1]/fit_trim_layer2[0]

                self.two_layer_hertz['best_fit']['layer2']['specifics'] = dict()
                self.two_layer_hertz['best_fit']['layer2']['specifics']['start_index'] = start_index_layer2
                self.two_layer_hertz['best_fit']['layer2']['specifics']['full_index'] = (fit_start_layer2,fit_end_layer2-1)

                self.two_layer_hertz['residuals']['layer2']['unit'] = 'nN'

                self.two_layer_hertz['residuals']['layer2']['mean_linear_fit'] = np.mean(np.absolute(residuals_linear_layer2))
                self.two_layer_hertz['residuals']['layer2']['data_linear_fit'] = residuals_linear_layer2


                if indenter_characteristics['geometry'] == 'parabolic':

                    e_modul_layer2 = np.power(abs(fit_trim_layer2[0]),3/2) * (1 - poisson_ratio**2) * 3 / (4 * math.sqrt(indenter_characteristics['radius [nm]']))

                    x_fit = copy.deepcopy(x_data)
                    ind = -(x_fit - self.two_layer_hertz['best_fit']['layer2']['contact_point']['value'])
                    ind[ind<0] = 0
                    y_fit_layer2 = np.power(abs(fit_trim_layer2[0]),3/2) * np.power(ind,3/2)

                    residuals_layer2 = y_fit_layer2[fit_start_mod_layer2:fit_end_mod_layer2] - y_data[fit_start_mod_layer2:fit_end_mod_layer2]

                    self.two_layer_hertz['best_fit']['layer2']['mean'] = np.mean(np.absolute(residuals_layer2))
                    self.two_layer_hertz['best_fit']['layer2']['data'] = residuals_layer2



                elif indenter_characteristics['geometry'] == 'conical':

                    e_modul_layer2 = fit_trim_layer2[0]**2 * (1 - poisson_ratio**2) * np.pi / (2 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                    x_fit = copy.deepcopy(x_data)
                    ind = -(x_fit - self.two_layer_hertz['best_fit']['layer2']['contact_point']['value'])
                    ind[ind<0] = 0
                    y_fit_layer2 = fit_trim_layer2[0]**2 * ind**2

                    residuals_layer2 = y_fit_layer2[fit_start_mod_layer2:fit_end_mod_layer2] - y_data[fit_start_mod_layer2:fit_end_mod_layer2]

                    self.two_layer_hertz['residuals']['layer2']['mean'] = np.mean(np.absolute(residuals_layer2))
                    self.two_layer_hertz['residuals']['layer2']['data'] = residuals_layer2


                elif indenter_characteristics['geometry'] == 'four-sided pyramid':

                    e_modul_layer2 = fit_trim_layer2[0]**2 * (1 - poisson_ratio**2) / (0.7453 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                    x_fit = copy.deepcopy(x_data)
                    ind = -(x_fit - self.two_layer_hertz['best_fit']['layer2']['contact_point']['value'])
                    ind[ind<0] = 0
                    y_fit_layer2 = fit_trim_layer2[0]**2 * ind**2

                    residuals_layer2 = y_fit_layer2[fit_start_mod_layer2:fit_end_mod_layer2] - y_data[fit_start_mod_layer2:fit_end_mod_layer2]

                    self.two_layer_hertz['residuals']['layer2']['mean'] = np.mean(np.absolute(residuals_layer2))
                    self.two_layer_hertz['residuals']['layer2']['data'] = residuals_layer2

            else:

                self.two_layer_hertz['best_fit']['layer2']['line_found'] = False
                self.two_layer_hertz['residuals']['layer2'] = dict()

                e_modul_layer2 = np.nan




            self.two_layer_hertz['poisson_ratio'] = poisson_ratio
            self.two_layer_hertz['units'] = copy.deepcopy(self.units)

            e_modul_layer1 = e_modul_layer1 * 10**9
            e_modul_layer2 = e_modul_layer2 * 10**9
            e_modul_unit = 'Pa'
            e_modul_factor = 1

            self.two_layer_hertz['young_modulus']['layer1'] = {'value': e_modul_layer1, 'unit': e_modul_unit, 'factor': e_modul_factor}
            self.two_layer_hertz['young_modulus']['layer2'] = {'value': e_modul_layer2, 'unit': e_modul_unit, 'factor': e_modul_factor}

            retract_plot = False
            plot_linear = False
            plot_individual = False

            if 'retract_plot' in kwargs and kwargs['retract_plot']:

                retract_plot = True

            if 'plot_linear' in kwargs and kwargs['plot_linear']:

                plot_linear = True

            if 'plot_individual' in kwargs and kwargs['plot_individual']:

                plot_individual = True


            if 'plot_result' in kwargs and kwargs['plot_result']:

                if indenter_characteristics['geometry'] == 'parabolic':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'
                elif indenter_characteristics['geometry'] == 'conical':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Angle: ' +'%.2f' % indenter_characteristics['angle [grad]']+ ' grad'
                elif indenter_characteristics['geometry'] == 'four-sided pyramid':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Angle: ' +'%.2f' % indenter_characteristics['angle [grad]']+ ' grad'
                elif indenter_characteristics['geometry'] == 'cylindrical':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'


                x_plot = x_data * (1e-09 / self.units['distance']['factor'])




                fig = plt.figure()
                ax = fig.add_axes([0.15, 0.15, 0.75, 0.75])

                ax.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend', color = '#1f77b4ff')
                ax.plot(self.data['extend'][self.keys['ts_key']], y_data_savgol_layer1, label = 'extend', color = '#1f77b4ff')

                if retract_plot:

                    ax.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['y_key']], label = 'retract', color = '#ff7e0eff')



                if line_found_layer1:

                    y_plot_layer1 = y_fit_layer1 * (1e-09 / self.units['force']['factor'])

                    text1 = 'Young\'s modulus layer1: %.2f' % self.two_layer_hertz['young_modulus']['layer1']['value'] + ' ' + self.two_layer_hertz['young_modulus']['layer1']['unit'] + '\nContact point: ' +'%.2f' % self.two_layer_hertz['best_fit']['layer1']['contact_point']['value'] + ' ' + self.two_layer_hertz['units']['distance']['unit']
                    text2 = '\nFit index: (' + str(self.two_layer_hertz['best_fit']['layer1']['index'][0]) +', ' + str(self.two_layer_hertz['best_fit']['layer1']['index'][1])  + ')'
                    text3 = '\nFit parameter: a = %.2e' % self.two_layer_hertz['best_fit']['layer1']['fit_parameter']

                    ax.plot(x_plot, y_plot_layer1, label = 'lin. hertz model - layer 1 - complete', color = '#c8ab37ff', linestyle = '--')
                    ax.plot(x_plot[fit_start_mod_layer1:fit_end_mod_layer1], y_plot_layer1[fit_start_mod_layer1:fit_end_mod_layer1], label = 'lin. hertz model - layer 1 - fit range', color = '#ff053bff')

                else:

                    text1 = 'No soft layer detected\n'
                    text2 = ''
                    text3 = ''


                if line_found_layer2:

                    y_plot_layer2 = y_fit_layer2 * (1e-09 / self.units['force']['factor'])

                    text5 = '\nYoung\'s modulus layer2: %.2f' % self.two_layer_hertz['young_modulus']['layer2']['value'] + ' ' + self.two_layer_hertz['young_modulus']['layer2']['unit'] + '\n Virtual contact point: ' +'%.2f' % self.two_layer_hertz['best_fit']['layer2']['contact_point']['value'] + ' ' + self.two_layer_hertz['units']['distance']['unit']
                    text6 = '\nFit index: (' + str(self.two_layer_hertz['best_fit']['layer2']['index'][0]) +', ' + str(self.two_layer_hertz['best_fit']['layer2']['index'][1])  + ')'
                    text7 = '\nFit parameter: a = %.2e' % self.two_layer_hertz['best_fit']['layer2']['fit_parameter']

                    ax.plot(x_plot, y_plot_layer2, label = 'lin. hertz model - layer 2 - complete', color = '#abc837ff', linestyle = '--')
                    ax.plot(x_plot[fit_start_mod_layer2:fit_end_mod_layer2], y_plot_layer2[fit_start_mod_layer2:fit_end_mod_layer2], label = 'lin. hertz model - layer 2 - fit range', color = '#dd55ffff')

                else:

                    text5 = '\nNo stiff layer detected\n'
                    text6 = ''
                    text7 = ''

                if transition_found:

                    ax.plot(x_data[index_transition],y_data[index_transition], linestyle = '', marker = 'x', color = 'r', label = 'corrected transition point')

                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                ax.legend()
                ax.tick_params(direction = 'in', top = True, right = True)

                textstr = text1 + text2 + text3 + text5 + text6 + text7 + text4

                bbox_args = dict(boxstyle="round", fc= (1,1,1))
                an1 = ax.annotate(textstr, xy=(.23, .7), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox=bbox_args)
                an1.draggable() #allows to drag the box arround


                if plot_linear:

#                    layer1_plus = np.sqrt(y_data_savgol_layer1)
#                    layer1_minus = -np.sqrt(-y_data_savgol_layer1)
#                    layer1_plus[np.isnan(layer1_plus)] = 0
#                    layer1_minus[np.isnan(layer1_minus)] = 0
#                    y_data_scaled_layer1_plot = layer1_plus + layer1_minus
#
#                    layer2_plus = np.sqrt(copy.deepcopy(y_data))
#                    layer2_minus = -np.sqrt(-copy.deepcopy(y_data))
#                    layer2_plus[np.isnan(layer2_plus)] = 0
#                    layer2_minus[np.isnan(layer2_minus)] = 0
#                    y_data_scaled_layer2_plot = layer2_plus + layer2_minus


                    fig_lin = plt.figure()
                    ax_lin = fig_lin.add_axes([0.15, 0.15, 0.75, 0.75])
                    ax_lin.plot(x_data,y_data_scaled_layer2, label = 'scaled data')
                    ax_lin.plot(x_data,y_data_scaled_layer1, label = 'smoothened scaled data')

                    if transition_found:

                        ax_lin.plot(x_data[index_transition],y_data_scaled_layer1[index_transition], linestyle = '', marker = 'x', color = 'r', label = 'corrected transition point')
                    #ax_lin.plot(x_data,y_data_scaled_layer2_plot, label = 'scaled data')
                    #ax_lin.plot(x_data,y_data_scaled_layer1_plot, label = 'smoothened scaled data')


                    if line_found_layer1:

                        ax_lin.plot(x_data[fit_start_layer1:fit_end_layer1-1], x_data[fit_start_layer1:fit_end_layer1-1] *fit_layer1[0] + fit_layer1[1], label = 'linear fit - layer 1 - full range', color = '#000000ff')
                        ax_lin.plot(x_data[fit_start_mod_layer1:fit_end_mod_layer1], x_data[fit_start_mod_layer1:fit_end_mod_layer1] *fit_trim_layer1[0] + fit_trim_layer1[1], label = 'linear fit - layer 1', color = '#ff053bff')


                    if line_found_layer2:

                        ax_lin.plot(x_data[fit_start_layer2:fit_end_layer2], x_data[fit_start_layer2:fit_end_layer2] *fit_layer2[0] + fit_layer2[1], label = 'linear fit - layer 2 - full range', color = '#000000ff')
                        ax_lin.plot(x_data[fit_start_mod_layer2:fit_end_mod_layer2], x_data[fit_start_mod_layer2:fit_end_mod_layer2] *fit_trim_layer2[0] + fit_trim_layer2[1], label = 'linear fit - layer 2', color = '#dd55ffff')

                    ax_lin.set_title('Smoothened and Scaled Extend Data')
                    ax_lin.tick_params(direction = 'in', top = True, right = True)
                    ax_lin.legend()



                if plot_individual:

                    if line_found_layer1:

                        fig_lay1 = plt.figure()
                        ax_lay1 = fig_lay1.add_axes([0.15, 0.15, 0.75, 0.75])
                        ax_lay1.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend', color = '#1f77b4ff')

                        ax_lay1.plot(x_plot, y_plot_layer1, label = 'lin. hertz model - layer 1 - complete', color = '#abc837ff', linestyle = '--')
                        ax_lay1.plot(x_plot[fit_start_mod_layer1:fit_end_mod_layer1], y_plot_layer1[fit_start_mod_layer1:fit_end_mod_layer1], label = 'lin. hertz model - layer 1 - fit range', color = '#dd55ffff')

                        plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                        plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                        ax_lay1.legend()
                        ax_lay1.set_title('Layer 1')
                        ax_lay1.tick_params(direction = 'in', top = True, right = True)

                        if plot_linear:

                            fit_layer1 = np.polyfit(x_data[fit_start_layer1:fit_end_layer1-1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1-1],1)

                            fig_lay1_lin = plt.figure()
                            ax_lay1_lin = fig_lay1_lin.add_axes([0.15, 0.15, 0.75, 0.75])

                            ax_lay1_lin.plot(x_data,y_data_scaled_layer1, label = 'smoothened scaled data')
                            ax_lay1_lin.plot(x_data[fit_start_layer1:fit_end_layer1-1], x_data[fit_start_layer1:fit_end_layer1-1] *fit_layer1[0] + fit_layer1[1], label = 'linear fit - full range', color = '#888888ff')
                            ax_lay1_lin.plot(x_data[fit_start_mod_layer1:fit_end_mod_layer1], x_data[fit_start_mod_layer1:fit_end_mod_layer1] *fit_trim_layer1[0] + fit_trim_layer1[1], label = 'linear fit - adapted fit range', color = '#ff053bff')

                            plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                            plt.ylabel('Scaled Force Data' + ' / sqrt(' + self.channel_units[self.keys['y_key']] + ')')

                            ax_lay1_lin.legend()
                            ax_lay1_lin.set_title('Layer 1 - Linearized')
                            ax_lay1_lin.tick_params(direction = 'in', top = True, right = True)



                    if line_found_layer2:

                        fig_lay2 = plt.figure()
                        ax_lay2 = fig_lay2.add_axes([0.15, 0.15, 0.75, 0.75])
                        ax_lay2.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend', color = '#1f77b4ff')

                        ax_lay2.plot(x_plot, y_plot_layer2, label = 'lin. hertz model - layer 2 - complete', color = '#c8ab37ff', linestyle = '--')
                        ax_lay2.plot(x_plot[fit_start_mod_layer2:fit_end_mod_layer2], y_plot_layer2[fit_start_mod_layer2:fit_end_mod_layer2], label = 'lin. hertz model - layer 2 - fit range', color = '#ff053bff')

                        plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                        plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                        ax_lay2.legend()
                        ax_lay2.set_title('Layer 2')
                        ax_lay2.tick_params(direction = 'in', top = True, right = True)

                        if plot_linear:

                            fit_layer2 = np.polyfit(x_data[fit_start_layer2:fit_end_layer2], y_data_scaled_layer2[fit_start_layer2:fit_end_layer2],1)

                            fig_lay2_lin = plt.figure()
                            ax_lay2_lin = fig_lay2_lin.add_axes([0.15, 0.15, 0.75, 0.75])

                            ax_lay2_lin.plot(x_data,y_data_scaled_layer2, label = 'scaled data')
                            ax_lay2_lin.plot(x_data[fit_start_layer2:fit_end_layer2], x_data[fit_start_layer2:fit_end_layer2] *fit_layer2[0] + fit_layer2[1], label = 'linear fit - full range', color = '#888888ff')
                            ax_lay2_lin.plot(x_data[fit_start_mod_layer2:fit_end_mod_layer2], x_data[fit_start_mod_layer2:fit_end_mod_layer2] *fit_trim_layer2[0] + fit_trim_layer2[1], label = 'linear fit - adapted fit range', color = '#ff053bff')

                            plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                            plt.ylabel('Scaled Force Data' + ' / sqrt(' + self.channel_units[self.keys['y_key']] + ')')

                            ax_lay2_lin.legend()
                            ax_lay2_lin.set_title('Layer 2 - Linearized')
                            ax_lay2_lin.tick_params(direction = 'in', top = True, right = True)


        else:

            raise ValueError('ERROR! Data are not prepared for analysis. Perform corrections first.')




    def fit_multi_layer_linearized_hertz_model_test(self,
                                                     transition_sensitivity = 1,
                                                     filter_correction_fraction = 0.5,):


        #transition_fac = 5 - math.log10(transition_sensitivity)


        if self.control_variables['allow_analysis']:


            x_data = self.data['extend'][self.keys['ts_key']] / (1e-09 / self.units['distance']['factor'])
            y_data = self.data['extend'][self.keys['y_key']] / (1e-09 / self.units['force']['factor'])
            noise_lvl_adapted = self.noise_level['value'] / (1e-09 / self.units['force']['factor'])

            # 1. smooth data
            y_data_savgol_layer1 = savgol_filter(y_data,51,1)

            y_data_scaled_layer1_2 = np.sqrt(np.abs(y_data_savgol_layer1))

            y_data_scaled_2 = np.sqrt(np.abs(y_data))

            y_data_scaled_layer1 = np.sqrt(y_data_savgol_layer1)

            y_data_scaled_layer1_plus = np.sqrt(y_data_savgol_layer1)
            y_data_scaled_layer1_minus = np.sqrt(-y_data_savgol_layer1)

            y_data_scaled_layer1_plus[np.isnan(y_data_scaled_layer1_plus)] = 0
            y_data_scaled_layer1_minus[np.isnan(y_data_scaled_layer1_minus)] = 0

            y_data_scaled_layer1 = y_data_scaled_layer1_plus + y_data_scaled_layer1_minus

            window_length = 51

            vec_size = self.settings['samples']['extend'] - window_length
            local_elasticity = np.full((vec_size,1),np.nan)

            #start_index_layer1 = np.amax(np.where(np.isnan(y_data_scaled_layer1))) + 1
            start_index_layer1 = 0

            for i in range(vec_size):

                if i > start_index_layer1:

                    x_fit_data = x_data[0+i:window_length+i]
                    y_fit_data = y_data_scaled_layer1[0+i:window_length+i]

                    #idy = np.isfinite(y_fit_data)


                    fit_extend = np.polyfit(x_fit_data,y_fit_data,1)


                    #fit_extend = np.polyfit(x_fit_data[idy],y_fit_data[idy],1)

                #print(fit_extend)

                    local_elasticity[i] = fit_extend[0] **2 * (1 - 0.5**2) / (0.7453 * math.tan(35 * np.pi / 180)) * 10**9

                else:

                    local_elasticity[i] = np.nan


            window_length = 21

            vec_size = self.settings['samples']['extend'] - window_length
            local_elasticity_2 = np.full((vec_size,1),np.nan)

            #start_index_layer1 = np.amax(np.where(np.isnan(y_data_scaled_layer1))) + 1
            start_index_layer1 = 0

            for i in range(vec_size):

                if i > start_index_layer1:

                    x_fit_data = x_data[0+i:window_length+i]
                    y_fit_data = y_data_scaled_2[0+i:window_length+i]

                    #idy = np.isfinite(y_fit_data)


                    fit_extend = np.polyfit(x_fit_data,y_fit_data,1)


                    #fit_extend = np.polyfit(x_fit_data[idy],y_fit_data[idy],1)

                #print(fit_extend)

                    local_elasticity_2[i] = fit_extend[0] **2 * (1 - 0.5**2) / (0.7453 * math.tan(35 * np.pi / 180)) * 10**9

                else:

                    local_elasticity_2[i] = np.nan


            plt.figure()
            plt.plot(y_data_scaled_layer1)
            plt.plot(y_data_scaled_layer1_2)

            plt.figure()
            plt.plot(local_elasticity)
            plt.plot(local_elasticity_2)

            print(np.argmax(local_elasticity>5000))
            print(np.argmax(local_elasticity>50000))



    def fit_multi_layer_segments(self,
                                 poisson_ratio = 0.5,
                                 indenter_characteristics = {'geometry': 'parabolic', 'radius [nm]': 10},
                                 transition_sensitivity = 1,
                                 **kwargs):


        transition_fac = 5 - math.log10(transition_sensitivity) # is used in the _create_segments function

        segments = dict()
        segments[1] = dict()
        segments[1]['index'] = dict()
        segments[2] = dict()
        segments[2]['index'] = dict()
        segments[3] = dict()
        segments[3]['index'] = dict()

        segments[1]['parameter'] = dict()
        segments[1]['parameter']['limit [Pa]'] = 5000
        segments[1]['parameter']['filter'] = dict()
        segments[1]['parameter']['filter']['applied'] = True
        segments[1]['parameter']['filter']['type'] = 'savitzky-golay'
        segments[1]['parameter']['filter']['parameter'] = {'length': 51, 'order': 1, 'deriv': 0, 'delta': 1.0, 'axis': -1, 'mode': 'interp', 'cval': 0.0}
        segments[1]['parameter']['transition_fac'] = transition_fac
        segments[1]['parameter']['fit_length'] = 100
        segments[1]['parameter']['final_fit_fraction'] = 0.9
        segments[1]['parameter']['r_squared_limit'] = 0.98
        segments[1]['parameter']['residual_sensitivity'] = 1 #residual fac 5
        segments[1]['parameter']['with_residuals'] = True
        segments[1]['parameter']['reverse_search'] = False

        segments[2]['parameter'] = dict()
        segments[2]['parameter']['limit [Pa]'] = 250000
        segments[2]['parameter']['filter'] = dict()
        segments[2]['parameter']['filter']['applied'] = False
        segments[2]['parameter']['transition_fac'] = transition_fac
        segments[2]['parameter']['fit_length'] = 75
        segments[2]['parameter']['final_fit_fraction'] = 0.9
        segments[2]['parameter']['r_squared_limit'] = 0.95
        segments[2]['parameter']['residual_sensitivity'] = 1 #residual fac 5
        segments[2]['parameter']['with_residuals'] = True
        segments[2]['parameter']['reverse_search'] = False

        segments[3]['parameter'] = dict()
        segments[3]['parameter']['limit [Pa]'] = np.nan
        segments[3]['parameter']['filter'] = dict()
        segments[3]['parameter']['filter']['applied'] = False
        segments[3]['parameter']['transition_fac'] = transition_fac
        segments[3]['parameter']['fit_length'] = 10
        segments[3]['parameter']['final_fit_fraction'] = 0.5
        segments[3]['parameter']['r_squared_limit'] = 0.9
        segments[3]['parameter']['residual_sensitivity'] = 1
        segments[3]['parameter']['with_residuals'] = True
        segments[3]['parameter']['reverse_search'] = True




        if self.control_variables['allow_analysis']:

            x_data = self.data['extend'][self.keys['ts_key']] / (1e-09 / self.units['distance']['factor'])
            y_data = self.data['extend'][self.keys['y_key']] / (1e-09 / self.units['force']['factor'])
            #noise_lvl_adapted = self.noise_level['value'] / (1e-09 / self.units['force']['factor']) #changed in self._find_layer()

            # 1. make data sets according to segment properties:
            y_data_savgol = dict()
            y_data_scaled = dict()

            for seg in segments.keys():

                if segments[seg]['parameter']['filter']['applied']:

                    y_data_savgol[seg] = savgol_filter(y_data, segments[seg]['parameter']['filter']['parameter']['length'],
                                 segments[seg]['parameter']['filter']['parameter']['order'],
                                 deriv = segments[seg]['parameter']['filter']['parameter']['deriv'],
                                 delta = segments[seg]['parameter']['filter']['parameter']['delta'],
                                 axis = segments[seg]['parameter']['filter']['parameter']['axis'],
                                 mode = segments[seg]['parameter']['filter']['parameter']['mode'],
                                 cval = segments[seg]['parameter']['filter']['parameter']['cval'],
                                 )

                else:

                    y_data_savgol[seg] = y_data


                if indenter_characteristics['geometry'] == 'parabolic':

                    y_data_scaled[seg] = np.power(y_data_savgol[seg],2/3)
                    segments[seg]['index']['start'] = np.amax(np.where(np.isnan(y_data_scaled[seg]))) + 1

                elif indenter_characteristics['geometry'] == 'conical' or indenter_characteristics['geometry'] == 'four-sided pyramid':

                    y_data_scaled[seg] = np.sqrt(y_data_savgol[seg])
                    segments[seg]['index']['start'] = np.amax(np.where(np.isnan(y_data_scaled[seg]))) + 1

            # create three individual segments roughly based on the local elasticity during the indentation
            self._create_segments(segments, x_data, y_data, y_data_savgol, indenter_characteristics, poisson_ratio)

            layers = dict()
            # in each segment do a linearized hertz model fit
            y_fit, fit_trim = self._find_layer(layers, segments, x_data, y_data, y_data_scaled, indenter_characteristics, poisson_ratio)


            self.multi_layer_hertz['indenter'] = indenter_characteristics
            self.multi_layer_hertz['method'] = 'linear'
            self.multi_layer_hertz['parameter'] = dict()
            self.multi_layer_hertz['parameter']['transition_sensitivity'] = transition_sensitivity
            self.multi_layer_hertz['parameter']['transition_factor'] = transition_fac
            self.multi_layer_hertz['segments'] = segments
            self.multi_layer_hertz['layers'] = layers
            self.multi_layer_hertz['poisson_ratio'] = poisson_ratio
            self.multi_layer_hertz['units'] = copy.deepcopy(self.units)
            self.multi_layer_hertz['young_modulus'] = dict()

            for seg in segments.keys():

                self.multi_layer_hertz['young_modulus'][seg] = layers[seg]['young_modulus']['value']


            self.multi_layer_hertz['young_modulus']['unit'] = layers[1]['young_modulus']['unit']
            self.multi_layer_hertz['young_modulus']['factor'] = layers[1]['young_modulus']['factor']


#            for seg in segments.keys():
#
#                print('=== Segment', seg, '====')
#                print(segments[seg])
#                print('----------fit result------')
#                print(layers[seg]['fit'],layers[seg]['young_modulus'])




            retract_plot = False
            plot_linear = False

            if 'retract_plot' in kwargs and kwargs['retract_plot']:

                retract_plot = True

            if 'plot_linear' in kwargs and kwargs['plot_linear']:

                plot_linear = True



            if 'plot_result' in kwargs and kwargs['plot_result']:


                if indenter_characteristics['geometry'] == 'parabolic':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'
                elif indenter_characteristics['geometry'] == 'conical':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Angle: ' +'%.2f' % indenter_characteristics['angle [grad]']+ ' grad'
                elif indenter_characteristics['geometry'] == 'four-sided pyramid':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Angle: ' +'%.2f' % indenter_characteristics['angle [grad]']+ ' grad'
                elif indenter_characteristics['geometry'] == 'cylindrical':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'


                x_plot = x_data * (1e-09 / self.units['distance']['factor'])




                if 'ax' in kwargs:

                    ax = kwargs['ax']

                else:

                    fig = plt.figure()
                    ax = fig.add_axes([0.15, 0.15, 0.75, 0.75])

                ax.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend', color = '#1f77b4ff')

                if retract_plot:

                    ax.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['y_key']], label = 'retract', color = '#ff7e0eff')


                for seg in segments.keys():

                    if 'start' in segments[seg]['index'].keys():

                        ax.plot(self.data['extend'][self.keys['ts_key']][segments[seg]['index']['start']], self.data['extend'][self.keys['y_key']][segments[seg]['index']['start']], marker = 'x', label = 'segment start' , color = '#000000ff')



                ax.legend()

                color_layer_plots = dict()
                color_layer_plots[1] = '#ff053bff'
                color_layer_plots[2] = '#00ffccff'
                color_layer_plots[3] = '#dd55ffff'

                color_layer_plots_complete = dict()
                color_layer_plots_complete[1] = '#c8ab37ff'
                color_layer_plots_complete[2] = '#d38d5fff'
                color_layer_plots_complete[3] = '#abc837ff'


                text_layers = dict()
                y_plot = dict()
                textstr = str()

                for seg in segments.keys():

                    if layers[seg]['fit']['line_found']:

                        text1 = 'Young\'s modulus - Segment '+ str(seg)+': %.2f' % self.multi_layer_hertz['young_modulus'][seg] + ' ' + self.multi_layer_hertz['young_modulus']['unit'] + '\nContact point: ' +'%.2f' % self.multi_layer_hertz['layers'][seg]['fit']['contact_point']['value'] + ' ' + self.multi_layer_hertz['units']['distance']['unit']
                        text2 = '\nFit index: (' + str(self.multi_layer_hertz['layers'][seg]['fit']['index'][0]) +', ' + str(self.multi_layer_hertz['layers'][seg]['fit']['index'][1])  + ')'
                        text3 = '\nFit parameter: a = %.2e' % self.multi_layer_hertz['layers'][seg]['fit']['fit_parameter']

                        y_plot[seg] = y_fit[seg] * (1e-09 / self.units['force']['factor'])

                        ax.plot(x_plot, y_plot[seg], label = 'lin. hertz model - Segment '+str(seg) +' - complete', color = color_layer_plots_complete[seg], linestyle = '--')
                        ax.plot(x_plot[self.multi_layer_hertz['layers'][seg]['fit']['index'][0]:self.multi_layer_hertz['layers'][seg]['fit']['index'][1]], y_plot[seg][self.multi_layer_hertz['layers'][seg]['fit']['index'][0]:self.multi_layer_hertz['layers'][seg]['fit']['index'][1]], label = 'lin. hertz model - Segment ' + str(seg)+' - fit range', color = color_layer_plots[seg])


                    else:

                        text1 = 'Young\'s modulus - Segment '+ str(seg)+': No layer detected\n'
                        text2 = ''
                        text3 = ''

                    text_layers[seg] = text1 + text2 + text3 + '\n'
                    textstr = textstr +  text1 + text2 + text3 + '\n'


                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                if 'show_legend' in kwargs and kwargs['show_legend']:
                    ax.legend()

                ax.tick_params(direction = 'in', top = True, right = True)

                textstr = textstr + text4

                bbox_args = dict(boxstyle="round", fc= (1,1,1))
                an1 = ax.annotate(textstr, xy=(.25, .965), xycoords='axes fraction', fontsize = 'xx-small', linespacing = 2, bbox=bbox_args, verticalalignment = 'top')

                an1.draggable() #allows to drag the box arround


                if plot_linear:

                    fig_lin = plt.figure()
                    ax_lin = fig_lin.add_axes([0.15, 0.15, 0.75, 0.75])
                    ax_lin.plot(x_data,y_data_scaled[2], label = 'scaled data')
                    ax_lin.plot(x_data,y_data_scaled[1], label = 'smoothened scaled data')
                    plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                    plt.ylabel('Scaled Force')

                    for seg in segments.keys():

                        if layers[seg]['fit']['line_found']:

                            ax_lin.plot(x_plot[self.multi_layer_hertz['layers'][seg]['fit']['index'][0]:self.multi_layer_hertz['layers'][seg]['fit']['index'][1]], x_data[self.multi_layer_hertz['layers'][seg]['fit']['index'][0]:self.multi_layer_hertz['layers'][seg]['fit']['index'][1]] *fit_trim[seg][0] + fit_trim[seg][1],
                                        label = 'lin. hertz model - Segment ' + str(seg)+' - fit range', color = color_layer_plots[seg])


                        ax_lin.set_title('Smoothened and Scaled Extend Data')
                        ax_lin.tick_params(direction = 'in', top = True, right = True)
                        ax_lin.legend()


            export = False

            if 'export_result' in kwargs:

                if type(kwargs['export_result']) is bool:

                    export = kwargs['export_result']
                    fileformat = ['svg', 'pdf', 'png', 'pkl']

                elif type(kwargs['export_result']) is str:

                    fileformat = [kwargs['export_result']]
                    export = True

                elif type(kwargs['export_result']) is list and kwargs['export_result']:

                    fileformat = kwargs['export_result']
                    export = True

            if export:

                #fig_formats = ['svg', 'pdf', 'png', 'jpg']
                fig_export = [f for f in fileformat if f in ['svg', 'pdf', 'png']]

                plt.ioff()


                if indenter_characteristics['geometry'] == 'parabolic':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'
                elif indenter_characteristics['geometry'] == 'conical':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Angle: ' +'%.2f' % indenter_characteristics['angle [grad]']+ ' grad'
                elif indenter_characteristics['geometry'] == 'four-sided pyramid':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Angle: ' +'%.2f' % indenter_characteristics['angle [grad]']+ ' grad'
                elif indenter_characteristics['geometry'] == 'cylindrical':
                    text4 = '\nIndenter: ' + str(indenter_characteristics['geometry']) + '\n   Radius: ' +'%.2f' % indenter_characteristics['radius [nm]']+ ' nm'


                x_plot = x_data * (1e-09 / self.units['distance']['factor'])


                fig_exp = plt.figure()
                ax_exp = fig_exp.add_axes([0.15, 0.15, 0.75, 0.75])

                ax_exp.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend', color = '#1f77b4ff')

                if retract_plot:

                    ax_exp.plot(self.data['retract'][self.keys['ts_key']], self.data['retract'][self.keys['y_key']], label = 'retract', color = '#ff7e0eff')



                color_layer_plots = dict()
                color_layer_plots[1] = '#ff053bff'
                color_layer_plots[2] = '#00ffccff'
                color_layer_plots[3] = '#dd55ffff'

                color_layer_plots_complete = dict()
                color_layer_plots_complete[1] = '#c8ab37ff'
                color_layer_plots_complete[2] = '#d38d5fff'
                color_layer_plots_complete[3] = '#abc837ff'


                text_layers = dict()
                y_plot = dict()
                textstr = str()

                for seg in segments.keys():

                    if layers[seg]['fit']['line_found']:

                        text1 = 'Young\'s modulus - Segment '+ str(seg)+': %.2f' % self.multi_layer_hertz['young_modulus'][seg] + ' ' + self.multi_layer_hertz['young_modulus']['unit'] + '\nContact point: ' +'%.2f' % self.multi_layer_hertz['layers'][seg]['fit']['contact_point']['value'] + ' ' + self.multi_layer_hertz['units']['distance']['unit']
                        text2 = '\nFit index: (' + str(self.multi_layer_hertz['layers'][seg]['fit']['index'][0]) +', ' + str(self.multi_layer_hertz['layers'][seg]['fit']['index'][1])  + ')'
                        text3 = '\nFit parameter: a = %.2e' % self.multi_layer_hertz['layers'][seg]['fit']['fit_parameter']

                        y_plot[seg] = y_fit[seg] * (1e-09 / self.units['force']['factor'])

                        ax_exp.plot(x_plot, y_plot[seg], label = 'lin. hertz model - Segment '+str(seg) +' - complete', color = color_layer_plots_complete[seg], linestyle = '--')
                        ax_exp.plot(x_plot[self.multi_layer_hertz['layers'][seg]['fit']['index'][0]:self.multi_layer_hertz['layers'][seg]['fit']['index'][1]], y_plot[seg][self.multi_layer_hertz['layers'][seg]['fit']['index'][0]:self.multi_layer_hertz['layers'][seg]['fit']['index'][1]], label = 'lin. hertz model - Segment ' + str(seg)+' - fit range', color = color_layer_plots[seg])


                    else:

                        text1 = 'Young\'s modulus - Segment '+ str(seg)+': No layer detected\n'
                        text2 = ''
                        text3 = ''

                    text_layers[seg] = text1 + text2 + text3 + '\n'
                    textstr = textstr +  text1 + text2 + text3 + '\n'


                plt.xlabel(self.keys['ts_key'] + ' / ' + self.channel_units[self.keys['ts_key']])
                plt.ylabel(self.keys['y_key'] + ' / ' + self.channel_units[self.keys['y_key']])

                if 'show_legend' in kwargs and kwargs['show_legend']:
                    ax_exp.legend()

                ax_exp.tick_params(direction = 'in', top = True, right = True)

                textstr = textstr + text4

                bbox_args = dict(boxstyle="round", fc= (1,1,1))
                ax_exp.annotate(textstr, xy=(.25, .965), xycoords='axes fraction', fontsize = 'xx-small', linespacing = 2, bbox=bbox_args, verticalalignment = 'top')


                if not os.path.isdir(os.path.join(self.file_info['save_directory'], 'multi_layer_detection')):

                    os.makedirs(os.path.join(self.file_info['save_directory'], 'multi_layer_detection'))


                for f in fig_export:

                    filename = os.path.join(self.file_info['save_directory'], 'multi_layer_detection', 'multi_layer_detection_linear_' + self.file_info['file_org'] + '.' + f)

                    try:

                         plt.savefig(filename)

                    except:

                          sys.stderr.write('ERROR! Cannot open/write file ' + filename)


                plt.close(fig_exp)

                plt.ion()

                if 'pkl' in fileformat:

                     try:

                        file_pickle = os.path.join(self.file_info['save_directory'], 'multi_layer_detection', 'multi_layer_detection_linear_' + self.file_info['file_org'] + '.pkl')
                        out_pkl = open(file_pickle, 'wb')

                        pickle.dump(self.multi_layer_hertz, out_pkl)

                     except:

                          sys.stderr.write('ERROR! Cannot open/write file ' + file_pickle)

                     finally:

                          out_pkl.close()


        else:

            raise ValueError('ERROR! Data are not prepared for analysis. Perform corrections first.')




#
#
#
#
#
#
#
#
#
#
#
#
#
#    def fit_multi_layer_segments_old(self,
#                                 transition_sensitivity = 1):
#
#        transition_fac = 5 - math.log10(transition_sensitivity)
#        smooth_length = 51
#        residual_fac = 5 - math.log10(1)
#
#        if self.control_variables['allow_analysis']:
#
#            x_data = self.data['extend'][self.keys['ts_key']] / (1e-09 / self.units['distance']['factor'])
#            y_data = self.data['extend'][self.keys['y_key']] / (1e-09 / self.units['force']['factor'])
#
#
#            segments, y_data_savgol, y_data_scaled = self._create_segments_old(x_data,y_data,smooth_length,transition_fac,residual_fac)
#
##            segments[seg] = dict()
##            segments[seg]['index'] = dict()
##            segments[seg]['index']['start'] = np.amax(np.where(np.isnan(np.sqrt(y_data_savgol)))) + 1
##            segments[seg]['index']['end'] = min(index_transition,index_critical_elasticity)
##
##            segments[seg]['parameter'] = dict()
##            segments[seg]['parameter']['smooth'] = True
##            segments[seg]['parameter']['smooth_length'] = smooth_length
##            segments[seg]['parameter']['fit_length'] = 100
##            segments[seg]['parameter']['r_squared_limit'] = 0.98
##            segments[seg]['parameter']['residual_fac'] = residual_fac
#
#            print(segments)
#
#            layer = dict()
#            lay = 1
#
#            for seg in segments.keys():
#
#
#                end_segment = False
#
#
#                fit_start = segments[seg]['index']['start']
#
#                while not end_segment:
#
#                    control_param, results = self._find_layer_old(x_data, y_data_scaled[seg], fit_start, segments[seg])
#
#                    #control_param = dict()
#                    #control_param['line_found'] = line_found
#                    #control_param['end_segment'] = end_segment
#
#                    #results = dict()
#                    #results['fit_index'] = dict()
#                    #results['fit_index']['start'] = fit_start
#                    #results['fit_index']['end'] = fit_end
#                    #results['fit'] = fit
#
##                    results['fit'] = dict()
##                    results['fit']['fit_parameter'] = - fit_trim[0]
##                    results['fit']['contact_point'] = dict()
##                    results['fit']['contact_point']['index'] = np.argmax(self.data['extend'][self.keys['ts_key']] < -fit_trim[1]/fit_trim[0])
##                    results['fit']['contact_point']['value'] = -fit_trim[1]/fit_trim[0]
#
#
#                    end_segment = control_param['end_segment']
#                    line_found = control_param['line_found']
#
#
#                    if line_found:
#
#                        layer[lay] = dict()
#                        layer[lay]['fit'] = dict()
#                        layer[lay]['fit']['index'] = {'start': results['fit_index']['start'], 'end': results['fit_index']['end']}
#                        layer[lay]['fit']['results'] = results['fit']
#                        layer[lay]['parameters'] = dict()
#                        layer[lay]['parameters']['segment'] = seg
#
#                        fit_start = results['fit_index']['end'] + 1
#
#                        lay += 1
#
#            print(segments)
#            print('=====================\n')
#            print(layer)
#
#
#            #Plot results
#            x_plot = x_data * (1e-09 / self.units['distance']['factor'])
#
#
#
#
#            fig = plt.figure()
#            ax = fig.add_axes([0.15, 0.15, 0.75, 0.75])
#
#            ax.plot(self.data['extend'][self.keys['ts_key']], self.data['extend'][self.keys['y_key']], label = 'extend', color = '#1f77b4ff')
#            #ax.plot(self.data['extend'][self.keys['ts_key']], y_data_savgol[1], label = 'extend - smoothed', color = '#ff7f0eff')
#
#            for seg in segments.keys():
#
#                ax.plot(x_data[segments[seg]['index']['start']],y_data[segments[seg]['index']['start']], marker = 'x', label = 'segment start', color = '#ff0000ff')
#
#            for lay in layer.keys():
#
#
#                x_fit = copy.deepcopy(x_data)
#                ind = -(x_fit - layer[lay]['fit']['results']['contact_point']['value'])
#                ind[ind<0] = 0
#                y_fit = layer[lay]['fit']['results']['fit_parameter']**2 * ind**2
#
#                y_plot_fit = y_fit * (1e-09 / self.units['force']['factor'])
#
#                ax.plot(x_plot,y_plot_fit)
#
#
#
#
#
#    def fit_multi_layer_linearized_hertz_model_debug(self,
#                                                     transition_sensitivity = 1,
#                                                     filter_correction_fraction = 0.5,):
#
#
#        transition_fac = 5 - math.log10(transition_sensitivity)
#        smooth_length = 51
#        residual_fac = 5 - math.log10(1)
#
#        if self.control_variables['allow_analysis']:
#
#            x_data = self.data['extend'][self.keys['ts_key']] / (1e-09 / self.units['distance']['factor'])
#            y_data = self.data['extend'][self.keys['y_key']] / (1e-09 / self.units['force']['factor'])
#
#
#            seg = 1
#
#            segment = dict()
#            segment[1] = dict()
#            segment[1]['index'] = dict()
#            segment[1]['index']['start'] = 0
#
#            segment[1]['fit_length'] = 100
#            segment[1]['r_squared_limit'] = 0.98
#            segment[1]['residual_fac'] = residual_fac
#
#            y_data_savgol = dict()
#            diff_data = dict()
#
#
#            end_extend = False
#            ii = 0
#
#
#            # separate extend curve in different segments based on different properties
#            # start with 2 segments, before and after smoothing
#            while not end_extend:
#
#                if seg == 1:
#
#                    y_data_savgol[seg] = savgol_filter(y_data,51,1)
#                    diff_data = y_data - y_data_savgol[seg]
#                    diff_data_std = np.std(diff_data[0:int(self.settings['samples']['extend']*0.2)])
#
#                    transition_found = False
#
#                    i = 0
#
#                    while not transition_found and i < self.settings['samples']['extend'] - 1:
#
#                        if abs(diff_data[i]) > diff_data_std * transition_fac:
#
#                            transition_found = True
#
#                        else:
#
#                            i += 1
#
#
#                    index_transition = i - int(filter_correction_fraction*smooth_length)
#
#                    if transition_found:
#
#                        segment[seg]['index']['end'] = index_transition
#
#                    else:
#
#                        segment[seg]['index']['end'] = self.settings['samples']['extend']
#
#
#
#                    y_data_scaled = np.sqrt(y_data_savgol[seg])
#                    # find the correct starting index
#                    segment[1]['index']['start'] = np.amax(np.where(np.isnan(y_data_scaled))) + 1
#
#                    ii = index_transition
#
#                    if ii >= self.settings['samples']['extend']:
#
#                        end_extend = True
#
#                    seg += 1
#
#                else:
#
#                    segment[seg] = dict()
#                    segment[seg]['index'] = dict()
#                    segment[seg]['index']['start'] = index_transition + 1
#                    segment[seg]['index']['end'] = self.settings['samples']['extend']
#                    segment[seg]['fit_length'] = 10
#
#                    segment[seg]['r_squared_limit'] = 0.9
#                    segment[seg]['residual_fac'] = residual_fac
#
#                    y_data_savgol[seg] = y_data
#
#                    end_extend = True
#
#            print(segment)
#
#
#            layer = dict()
#            lay = 1
#
#            #find individual layer
#
#            for seg in segment.keys():
#
#
#                end_segment = False
#
#                y_data_scaled = np.sqrt(y_data_savgol[seg])
#                fit_start = segment[seg]['index']['start']
#
#                while not end_segment:
#
#                    control_param, results = self._find_layer(x_data, y_data_scaled, fit_start, segment[seg])
#
#                    #control_param = dict()
#                    #control_param['line_found'] = line_found
#                    #control_param['end_segment'] = end_segment
#
#                    #results = dict()
#                    #results['fit_index'] = dict()
#                    #results['fit_index']['start'] = fit_start
#                    #results['fit_index']['end'] = fit_end
#                    #results['fit'] = fit
#
#                    end_segment = control_param['end_segment']
#                    line_found = control_param['line_found']
#
#                    if line_found:
#
#                        layer[lay] = dict()
#                        layer[lay]['fit'] = dict()
#                        layer[lay]['fit']['index'] = {'start': results['fit_index']['start'], 'end': results['fit_index']['end']}
#                        layer[lay]['parameters'] = dict()
#                        layer[lay]['parameters']['segment'] = seg
#
#                        fit_start = results['fit_index']['end'] + 1
#
#                        lay += 1
#
#
#
#
#
#            print(layer)
#








#%% further data manipulation


    def reset_data(self, x_key = str()):

        if x_key in self.channels and x_key is not 'vDeflection':

            self.channels = [x_key, 'vDeflection']

        elif x_key in self.jpk_force_data.channels:

            self.channels = [self.get_x_key(), 'vDeflection']

        else:

            self.channels = [self.get_jpk_x_key(), 'vDeflection']

        self.channel_units = dict()

        for channel in self.channels:

            self.channel_units[channel] = self.jpk_force_data.channel_units[channel]


        self.set_keys(x_key = x_key)


        self.calibrations = copy.deepcopy(self.jpk_force_data.calibrations)
        self.settings = copy.deepcopy(self.jpk_force_data.settings)
        #self.file_info['date'] =self.jpk_force_data.file_info['date']
        #self.file_info['time'] =self.jpk_force_data.file_info['time']
        #self.file_info['file_org'] =self.jpk_force_data.file_info['file_org']


        for seg in self.jpk_force_data.data.keys():

            self.data[seg] = dict()

            for channel in self.channels:

                self.data[seg][channel] = copy.deepcopy(self.jpk_force_data.data[seg][channel])



        self.control_variables['file_imported'] = True
        self.control_variables['cantilever_calibrated'] = True
        self.control_variables['baseline_corrected'] = False
        self.control_variables['distance_corrected'] = False
        self.control_variables['tip_sample_separation_correction_performed'] = False
        self.control_variables['allow_analysis'] = False


        self.units['distance'] = dict()
        self.units['distance']['unit'] = 'm'
        self.units['distance']['factor'] = 1
        self.units['force'] = dict()
        self.units['force']['unit'] = 'N'
        self.units['force']['factor'] = 1


        self.corrections = dict()


        self.noise_level = dict()
        self.max_adhesion_force = dict()
        self.adhesion_energy = dict()
        self.snap_in = dict()
        self.rupture_length = dict()
        self.adhesion_signatures = dict()
        self.hertz_fit = dict()
        self.linearized_hertz_fit = dict()
        self.two_layer_hertz = dict()



        #self.adhesion_energy['units'] = dict()
        #self.adhesion_energy['units']['energy'] = dict()
        #self.adhesion_energy['units']['energy']['unit'] = 'J'
        #self.adhesion_energy['units']['energy']['factor'] = 1




    def calibrated_cantilever(self, sensitivity, spring_constant):

        if self.control_variables['cantilever_calibrated']:

            sys.stdout.write('Cantilever is already calibrated. Change calibration via set_sensitivity() and set_spring_constant()\n')

        else:

            self.settings['sensitivity'] = sensitivity
            self.settings['spring_constant'] = spring_constant

            for seg in self.data.keys():

                self.data[seg][self.keys['y_key']] = self.data[seg][self.keys['y_key']] * self.settings['sensitivity'] * self.settings['spring_constant']


            self.channel_units[self.keys['x_key']] = 'N'


            self.calibrations['spring_constant_calibrated'] = True
            self.calibrations['sensitivity_calibrated'] = True
            self.control_variables['cantilever_calibrated'] = True






    def set_spring_constant(self, value):

        self.calibrations['spring_constant'] = value

        fac = self.calibrations['spring_constant'] / self.jpk_force_data.calibrations['spring_constant']

        for seg in self.data.keys():

            self.data[seg][self.keys['y_key']] = self.data[seg][self.keys['y_key']] * fac

        #if ... was performed repeat it
        if self.control_variables['tip_sample_separation_correction_performed']:

            self.get_tip_sample_separation()

        #do not change adhesion force etc...because tip sample separation stuff has also influence e.g. on the adhesion energy and location of rupture events



    def reset_spring_constant(self):



        fac = self.jpk_force_data.calibrations['spring_constant'] / self.calibrations['spring_constant']

        self.calibrations['spring_constant'] = self.jpk_force_data.calibrations['spring_constant']

        for seg in self.data.keys():

            self.data[seg][self.keys['y_key']] = self.data[seg][self.keys['y_key']] * fac

        #if ... was performed repeat it
        if self.control_variables['tip_sample_separation_correction_performed']:

            self.get_tip_sample_separation()



    def set_sensitivity(self, value):

        self.calibrations['sensitivity'] = value

        fac = self.calibrations['sensitivity'] / self.jpk_force_data.calibrations['sensitivity']

        for seg in self.data.keys():

            self.data[seg][self.keys['y_key']] = self.data[seg][self.keys['y_key']] * fac

        #if ... was performed repeat it
        if self.control_variables['tip_sample_separation_correction_performed']:

            self.get_tip_sample_separation()




    def reset_sensitivity(self):

        fac = self.jpk_force_data.calibrations['sensitivity'] / self.calibrations['sensitivity']

        self.calibrations['sensitivity'] = self.jpk_force_data.calibrations['sensitivity']

        for seg in self.data.keys():

            self.data[seg][self.keys['y_key']] = self.data[seg][self.keys['y_key']] * fac

        #if ... was performed repeat it
        if self.control_variables['tip_sample_separation_correction_performed']:

            self.get_tip_sample_separation()





#%% accessing data stuff
    def get_jpk_x_key(self):

        if 'measuredHeight' in self.jpk_force_data.channels:

            x_key = 'measuredHeight'

        elif 'capacitiveSensorHeight' in self.jpk_force_data.channels:

            x_key = 'capacitiveSensorHeight'

        elif 'strainGaugeHeight' in self.jpk_force_data.channels:

            x_key = 'strainGaugeHeight'

        elif 'smoothedMeasuredHeight' in self.jpk_force_data.channels:

            x_key = 'smoothedMeasuredHeight'

        elif 'head-height' in self.jpk_force_data.channels:

            x_key = 'head-height'

        elif 'smoothedCapacitiveSensorHeight' in self.jpk_force_data.channels:

            x_key = 'smoothedCapacitiveSensorHeight'

        elif 'smoothedStrainGaugeHeight' in self.jpk_force_data.channels:

            x_key = 'smoothedStrainGaugeHeight'

        elif 'height' in self.jpk_force_data.channels:

            x_key = 'height'

        return x_key




    def get_x_key(self):

        return self.keys['x_key']


    def get_y_key(self):

        return self.keys['y_key']


    def get_ts_key(self):

        return self.keys['ts_key']


    def get_keys(self):

        return self.keys




    def set_x_key(self, channel = str()):

        if channel == str():

            self.keys['x_key'] = self.get_jpk_x_key()

        elif channel in self.channels and channel is not 'vDeflection':

            self.keys['x_key'] = channel

        else:

            self.keys['x_key'] = self.get_jpk_x_key()




    def set_keys(self, x_key):

        self.set_x_key(x_key)
        self.keys['y_key'] = 'vDeflection'
        self.keys['ts_key'] = 'separation'





#%% data visualization

    def data_plot(self, col1 = '', col2 = '', ax = 0, retract_plot = True, **kwargs):

        if len(col1) == 0 or len(col2) == 0:


            if self.control_variables['tip_sample_separation_correction_performed']:

                x_key = self.keys['ts_key']
                y_key = self.keys['y_key']

            else:

                x_key = self.keys['x_key']
                y_key = self.keys['y_key']

        elif len(col1) > 0 and len(col2) > 0 and col1 in self.channels and col2 in self.channels:

            x_key = col1
            y_key = col2


        x_unit_key = self.keys['x_key']


        if isinstance(ax, matplotlib.axes._axes.Axes):   # check whether ax is from the correct type (axes)

            line_extend = ax.plot(self.data['extend'][x_key], self.data['extend'][y_key], label = 'extend', **kwargs)
            if retract_plot:
                line_retract = ax.plot(self.data['retract'][x_key], self.data['retract'][y_key], label = 'retract', **kwargs)
            else:
                line_retract = None

            ax.set_xlabel(x_key + ' / ' + self.channel_units[x_unit_key])
            ax.set_ylabel(y_key + ' / ' + self.channel_units[y_key])
            ax.legend()
            ax.tick_params(direction = 'in', top = True, right = True)

            return (ax, line_extend, line_retract)


        elif ax == 0:

            fig = plt.figure()
            ax = fig.add_axes([0.15, 0.15, 0.75, 0.75])

            line_extend = plt.plot(self.data['extend'][x_key], self.data['extend'][y_key], label = 'extend', **kwargs)
            if retract_plot:
                line_retract = ax.plot(self.data['retract'][x_key], self.data['retract'][y_key], label = 'retract', **kwargs)
            else:
                line_retract = None

            plt.xlabel(x_key + ' / ' + self.channel_units[x_unit_key])
            plt.ylabel(y_key + ' / ' + self.channel_units[y_key])
            ax.legend()
            ax.tick_params(direction = 'in', top = True, right = True)

            return (ax, line_extend, line_retract)


        else:

            fig = plt.figure()
            ax = fig.add_axes([0.15, 0.15, 0.75, 0.75])

            line_extend = plt.plot(self.data['extend'][x_key], self.data['extend'][y_key], label = 'extend', **kwargs)
            if retract_plot:
                line_retract = ax.plot(self.data['retract'][x_key], self.data['retract'][y_key], label = 'retract', **kwargs)
            else:
                line_retract = None

            plt.xlabel(x_key + ' / ' + self.channel_units[x_unit_key])
            plt.ylabel(y_key + ' / ' + self.channel_units[y_key])
            ax.legend()
            ax.tick_params(direction = 'in', top = True, right = True)

            return (ax, line_extend, line_retract)



    def raw_data_plot(self, col1 = '', col2 = '', ax = 0, **kwargs):

        if len(col1) == 0 or len(col2) == 0:

            x_key = self.keys['x_key']
            y_key = self.keys['y_key']

        elif len(col1) > 0 and len(col2) > 0 and col1 in self.channels and col2 in self.channels:

            x_key = col1
            y_key = col2


        if isinstance(ax, matplotlib.axes._axes.Axes):   # check whether ax is from the correct type (axes)

            line_extend = ax.plot(self.jpk_force_data.data['extend'][x_key], self.jpk_force_data.data['extend'][y_key], label = 'extend', **kwargs)
            line_retract = ax.plot(self.jpk_force_data.data['retract'][x_key], self.jpk_force_data.data['retract'][y_key], label = 'retract', **kwargs)

            ax.set_xlabel(x_key + ' / ' + self.channel_units[x_key])
            ax.set_ylabel(y_key + ' / ' + self.channel_units[y_key])
            ax.legend()
            ax.tick_params(direction = 'in', top = True, right = True)

            return (ax, line_extend, line_retract)


        elif ax == 0:

            fig = plt.figure()
            ax = fig.add_axes([0.15, 0.15, 0.75, 0.75])

            line_extend = plt.plot(self.jpk_force_data.data['extend'][x_key], self.jpk_force_data.data['extend'][y_key], label = 'extend', **kwargs)
            line_retract = plt.plot(self.jpk_force_data.data['retract'][x_key], self.jpk_force_data.data['retract'][y_key], label = 'retract', **kwargs)

            plt.xlabel(x_key + ' / ' + self.jpk_force_data.channel_units[x_key])
            plt.ylabel(y_key + ' / ' + self.jpk_force_data.channel_units[y_key])
            ax.legend()
            ax.tick_params(direction = 'in', top = True, right = True)

            return (ax, line_extend, line_retract)


        else:

            fig = plt.figure()
            ax = fig.add_axes([0.15, 0.15, 0.75, 0.75])

            line_extend = plt.plot(self.jpk_force_data.data['extend'][x_key], self.jpk_force_data.data['extend'][y_key], label = 'extend', **kwargs)
            line_retract = plt.plot(self.jpk_force_data.data['retract'][x_key], self.jpk_force_data.data['retract'][y_key], label = 'retract', **kwargs)

            plt.xlabel(x_key + ' / ' + self.channel_units[x_key])
            plt.ylabel(y_key + ' / ' + self.channel_units[y_key])
            ax.legend()
            ax.tick_params(direction = 'in', top = True, right = True)

            return (ax, line_extend, line_retract)


#%% additional methods data analysis


    def get_last_adhesion_signature(self, sensitivity = 1):
        # determines the index when the last adhesion signature was observed
        ret_dict = dict()

        fac = 5 - math.log10(sensitivity)

        if fac < 2:

            fac = 2

        adh_event_found = False
        i = 1
        index = 0

        while not adh_event_found and i < self.settings['samples']['retract']:

            if self.data['retract'][self.keys['y_key']][-i] < - fac * self.noise_level['value']: # check whether point a bit before ref level is significantly smaller
                # if that is the case, confirm that it is not a single outlier

                adh_event_found = True
                index = self.settings['samples']['retract'] - i

                for j in range(0,5): #short check whether the point found was just an outlier

                   if self.data['retract'][self.keys['y_key']][-i-j] > - self.noise_level['value']:

                        adh_event_found = False
                        index = 0


            i += 1

        ret_dict['index'] = index
        #print(adh_event_found, ref_level)
        if adh_event_found: #finds the last point that is smaller than the reference level

            i = 1
            add = 0

            while i < 20 and self.data['retract'][self.keys['y_key']][index+i] < 0:

                add = i
                i += 1

            index = index + add + 1


        ret_dict['end_adh_event_index'] = index

        return ret_dict











#%% other stuff
    def set_save_directory(self, directory):

         self.file_info['save_directory'] = directory

         if not os.path.isdir(self.file_info['save_directory']):

              try:

                 os.makedirs(self.file_info['save_directory'])

              except:

                 self.file_info['save_directory'] = os.getcwd()



    def set_filepath(self, filepath):

        if os.path.isfile(filepath):

            if filepath[filepath.rfind('.'):] == '.jpk-force':

                self.file_info['filename'] = filepath

            else:

                raise TypeError('ERROR! Given file is not a jpk-force/jpk-qi-series file!')

        else:

            raise ValueError('ERROR! Given filepath or filename is incorrect!')


    def tangent(self, window_length = 50):

        x_data = self.data['extend'][self.keys['x_key']]
        y_data = self.data['extend'][self.keys['y_key']]
        #y_data_savgol = savgol_filter(y_data,51,1)

        vec_size = self.settings['samples']['extend'] - window_length
        tang = np.full((vec_size,1),np.nan)

        for i in range(vec_size):

            fit_extend = np.polyfit(x_data[0+i:window_length+i],
                                    y_data[0+i:window_length+i],
                                    1,)

            tang[i] = fit_extend[0]


        plt.figure()
        plt.plot(tang)



#%% additional methods - data correction
# --  does not work -- r_squared always to good -- longer fit r_squared actually gets larger
#    def baseline_correction_auto_linear(self, reference = 'individual'):
#
#
#        fit_end_extend = int(self.settings['samples']['extend'] * 0.1)
#
##        fit_extend = np.polyfit(self.data['extend'][self.keys['x_key']][0:fit_end_extend],
##                             self.data['extend'][self.keys['y_key']][0:fit_end_extend],
##                             1,)
##
##        total_sum_of_squares = np.sum((self.data['extend'][self.keys['y_key']][0:fit_end_extend] - np.mean(self.data['extend'][self.keys['y_key']][0:fit_end_extend]))**2 )
##        residuals = self.data['extend'][self.keys['x_key']][0:fit_end_extend]*fit_extend[0] + fit_extend[1] - self.data['extend'][self.keys['y_key']][0:fit_end_extend]
##        squared_sum_residuals = np.sum(residuals**2)
##        r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)
##
##        print('fit_extend:', 0 , fit_end_extend, r_squared, np.sqrt(squared_sum_residuals))
##
##        plt.figure()
##        plt.plot(self.data['extend'][self.keys['x_key']],self.data['extend'][self.keys['y_key']])
##        plt.plot(self.data['extend'][self.keys['x_key']][0:fit_end_extend],self.data['extend'][self.keys['x_key']][0:fit_end_extend]*fit_extend[0] + fit_extend[1])
#
#        x_data = self.data['extend'][self.keys['x_key']] / (1e-06 / self.units['distance']['factor'])
#        y_data = self.data['extend'][self.keys['y_key']] / (1e-09 / self.units['force']['factor'])
#        y_data_savgol = savgol_filter(y_data,51,1)
##        y_data_savgol = y_data
#
#
#        fit_extend = np.polyfit(x_data[0:fit_end_extend],
#                             y_data_savgol[0:fit_end_extend],
#                             1,)
#
#        total_sum_of_squares = np.sum((y_data_savgol[0:fit_end_extend] - np.mean(y_data_savgol[0:fit_end_extend]))**2 )
#        residuals = x_data[0:fit_end_extend]*fit_extend[0] + fit_extend[1] - y_data_savgol[0:fit_end_extend]
#        squared_sum_residuals = np.sum(residuals**2)
#        r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)
#
#        print('fit_extend:', 0 , fit_end_extend, r_squared, np.sqrt(squared_sum_residuals))
#
#
#
#
#        plt.figure()
#        plt.plot(x_data,y_data)
#        plt.plot(x_data,y_data_savgol)
#        plt.plot(x_data[0:fit_end_extend],x_data[0:fit_end_extend]*fit_extend[0] + fit_extend[1])
#
#
#        while r_squared > 0.99 and fit_end_extend < self.settings['samples']['extend']*0.5:
#
#            fit_end_extend += 1
#
#            fit_extend = np.polyfit(x_data[0:fit_end_extend],
#                                    y_data_savgol[0:fit_end_extend],
#                                    1,)
#
#            total_sum_of_squares = np.sum((y_data_savgol[0:fit_end_extend] - np.mean(y_data_savgol[0:fit_end_extend]))**2 )
#            residuals = x_data[0:fit_end_extend]*fit_extend[0] + fit_extend[1] - y_data_savgol[0:fit_end_extend]
#            squared_sum_residuals = np.sum(residuals**2)
#            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)
#
#            print('fit_extend:', 0 , fit_end_extend, r_squared, np.sqrt(squared_sum_residuals))
#
#
#        plt.figure()
#        plt.plot(x_data,y_data)
#        plt.plot(x_data,y_data_savgol)
#        plt.plot(x_data[0:fit_end_extend],x_data[0:fit_end_extend]*fit_extend[0] + fit_extend[1])
#


    def distance_correction_constant(self, reference = 'extend'):


        ret_dict = {'corr_ext': self.data['extend'][self.keys['x_key']][-1], 'corr_ret': self.data['retract'][self.keys['x_key']][0]}

        if reference == 'individual':

            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - self.data['extend'][self.keys['x_key']][-1]
            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - self.data['retract'][self.keys['x_key']][0]

        elif reference == 'mean':

            corr_mean = 0.5 * (self.data['extend'][self.keys['x_key']][-1] + self.data['retract'][self.keys['x_key']][0])

            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - corr_mean
            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - corr_mean

        elif reference == 'extend':

            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - self.data['extend'][self.keys['x_key']][-1]
            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - self.data['extend'][self.keys['x_key']][-1]

        elif reference == 'retract':

            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - self.data['retract'][self.keys['x_key']][0]
            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - self.data['retract'][self.keys['x_key']][0]

        return ret_dict



    def distance_correction_zero_force_intersect(self, reference = 'extend', smooth_applied = False, smooth_length = 51):

        #print('distance_correction_zero_force_intersect:', smooth_applied)
        #print('distance_correction_zero_force_intersect:', smooth_length)

        ext_0_int = self.get_zero_force_intersect_extend(smooth_applied, smooth_length)
        ret_0_int = self.get_zero_force_intersect_retract(smooth_applied, smooth_length)

        corr_ext = ext_0_int['value_h']
        corr_ret = ret_0_int['value_h']
        corr_mean = 0.5 * (corr_ext + corr_ret)


        if reference == 'individual':

            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - corr_ext
            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - corr_ret

        elif reference == 'mean':

            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - corr_mean
            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - corr_mean

        elif reference == 'extend':

            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - corr_ext
            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - corr_ext


        elif reference == 'retract':

            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - corr_ret
            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - corr_ret


        ret_dict = dict()

        ret_dict['corr_ext'] = corr_ext
        ret_dict['corr_ret'] = corr_ret


        return ret_dict



    def distance_correction_fit(self, reference = 'extend', length_fit = 20):
# this function fits a straight line to the data at contact. the intersection between this line and the zero line is shifted to zero

        ret_dict = dict()

        ext_fit_int = self.get_distance_correction_fit_extend(length_fit)
        ret_fit_int = self.get_distance_correction_fit_retract(length_fit)

        corr_ext = ext_fit_int['value_h']
        corr_ret = ret_fit_int['value_h']
        corr_mean = 0.5 * (corr_ext + corr_ret)

        if reference == 'individual':

            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - corr_ext
            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - corr_ret


        elif reference == 'mean':

            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - corr_mean
            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - corr_mean

        elif reference == 'extend':

            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - corr_ext
            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - corr_ext


        elif reference == 'retract':

            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - corr_ret
            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - corr_ret


        ret_dict['length_fit'] = length_fit

        ret_dict['corr_ext'] = corr_ext
        ret_dict['corr_ret'] = corr_ret



        return ret_dict




    def get_zero_force_intersect_extend(self, smooth_applied = False, smooth_length = 51):

        return_dict = dict()
        return_dict['smooth_applied'] = smooth_applied


        if not smooth_applied:

            index = self.settings['samples']['extend'] - np.argmax(np.flip(self.data['extend'][self.keys['y_key']], axis = 0)<0) - 1



        elif smooth_applied:

            index = self.settings['samples']['extend'] - np.argmax(np.flip(savgol_filter(copy.deepcopy(self.data['extend'][self.keys['y_key']]),smooth_length,1), axis = 0)<0) - 1


        return_dict['index'] = index
        return_dict['value_h'] = self.data['extend'][self.keys['x_key']][index]

        if self.control_variables['tip_sample_separation_correction_performed']:

            return_dict['value_ts'] = self.data['extend'][self.keys['ts_key']][index]


        return return_dict


    def get_zero_force_intersect_retract(self, smooth_applied = False, smooth_length = 51):

        return_dict = dict()
        return_dict['smooth_applied'] = smooth_applied


        if not smooth_applied:

            index = np.argmax(self.data['retract'][self.keys['y_key']]<0)

        elif smooth_applied:

            index = np.argmax(savgol_filter(copy.deepcopy(self.data['retract'][self.keys['y_key']]),smooth_length,1)<0)


        return_dict['index'] = index
        return_dict['value_h'] = self.data['retract'][self.keys['x_key']][index]

        if self.control_variables['tip_sample_separation_correction_performed']:

            return_dict['value_ts'] = self.data['retract'][self.keys['ts_key']][index]

        return return_dict



    def get_distance_correction_fit_extend(self, length_fit = 20):
# fit a straight line to the line at contact. determine intersection of this line with the baseline

        return_dict = dict()

        slope_h, y_intersect_h = np.polyfit(self.data['extend'][self.keys['x_key']][-1-length_fit:-1], self.data['extend'][self.keys['y_key']][-1-length_fit:-1]  ,1)
        x_intersect_h = (0 - y_intersect_h) / slope_h

        return_dict['value_h'] = x_intersect_h


        return return_dict




    def get_distance_correction_fit_retract(self, length_fit = 20):


        return_dict = dict()

        slope_h, y_intersect_h = np.polyfit(self.data['retract'][self.keys['x_key']][0:length_fit], self.data['retract'][self.keys['y_key']][0:length_fit],1)
        x_intersect_h = (0 - y_intersect_h) / slope_h
        return_dict['value_h'] = x_intersect_h

        return return_dict




#%% helper functions
    def _create_segments(self, segments, x_data, y_data, y_data_savgol, indenter_characteristics, poisson_ratio):

        y_data_scaled_abs = dict()

        for seg in segments.keys():

            y_data_scaled_abs[seg] = self._get_scaled_data(y_data_savgol[seg], indenter_characteristics)


        # 1. segment

        #smooth_length = segments[1]['parameter']['filter']['parameter']['length']
        fit_length = int(segments[1]['parameter']['fit_length'] * 0.5)

        diff_data = y_data - y_data_savgol[1]
        diff_data_std = np.std(diff_data[0:int(self.settings['samples']['extend']*0.2)])

        transition_found = bool(np.argmax(abs(diff_data)>diff_data_std * segments[1]['parameter']['transition_fac']))
        vec_size = self.settings['samples']['extend'] - fit_length
        local_elasticity = np.full((vec_size,1),np.nan)

        for i in range(vec_size):

            x_fit_data = x_data[0+i:fit_length+i]
            y_fit_data = y_data_scaled_abs[1][0+i:fit_length+i]
            fit_extend = np.polyfit(x_fit_data,y_fit_data,1)
            local_elasticity[i] = 10**9 * self._get_elasticity_from_linear_hertz_fit(fit_extend, poisson_ratio, indenter_characteristics)


        critical_elasticity_found = bool(np.argmax(np.flip(local_elasticity,0)<segments[1]['parameter']['limit [Pa]']))

        if critical_elasticity_found:

            #find the first point after which all following are larger than the critical elasticity
            index_critical_elasticity = vec_size - np.argmax(np.flip(local_elasticity,0)<segments[1]['parameter']['limit [Pa]']) + 1 + int(0.5 * fit_length)


        if critical_elasticity_found:

            if transition_found:

                index_transition = np.argmax(abs(diff_data)>diff_data_std * segments[1]['parameter']['transition_fac']) - int(0.5*fit_length)

                segments[1]['index']['end'] = min(index_transition,index_critical_elasticity)

            else:

                segments[1]['index']['end'] = index_critical_elasticity


            segments[1]['exist'] = True

            if (segments[1]['index']['end'] - segments[1]['index']['start']) > segments[1]['parameter']['fit_length']:

                segments[1]['find_layer'] = True

            else:

                segments[1]['find_layer'] = False


            # 2. segment

            fit_length = int(segments[2]['parameter']['fit_length'] * 0.25)
            vec_size = self.settings['samples']['extend'] - fit_length
            local_elasticity = np.full((vec_size,1),np.nan)

            for i in range(vec_size):

                x_fit_data = x_data[0+i:fit_length+i]
                y_fit_data = y_data_scaled_abs[2][0+i:fit_length+i]
                fit_extend = np.polyfit(x_fit_data,y_fit_data,1)
                local_elasticity[i] = 10**9 * self._get_elasticity_from_linear_hertz_fit(fit_extend, poisson_ratio, indenter_characteristics)


            critical_elasticity_found = bool(np.argmax(np.flip(local_elasticity,0)<segments[2]['parameter']['limit [Pa]']))

            if critical_elasticity_found:

               index_critical_elasticity = vec_size - np.argmax(np.flip(local_elasticity,0)<segments[2]['parameter']['limit [Pa]']) + 1

               segments[2]['index']['start'] = segments[1]['index']['end'] + 1
               segments[2]['index']['end'] = index_critical_elasticity
               segments[2]['exist'] = True

               if (segments[2]['index']['end'] - segments[2]['index']['start']) > segments[2]['parameter']['fit_length']:

                   segments[2]['find_layer'] = True

               else:

                   segments[2]['find_layer'] = False


               segments[3]['index']['start'] = index_critical_elasticity + 1
               segments[3]['index']['end'] = self.settings['samples']['extend']
               segments[3]['exist'] = True

               if (segments[3]['index']['end'] - segments[3]['index']['start']) > segments[3]['parameter']['fit_length']:

                   segments[3]['find_layer'] = True

               else:

                   segments[3]['find_layer'] = False

            else:

               segments[2]['index']['start'] = segments[1]['index']['end'] + 1
               segments[2]['index']['end'] = self.settings['samples']['extend']
               segments[2]['exist'] = True

               if (segments[2]['index']['end'] - segments[2]['index']['start']) > segments[2]['parameter']['fit_length']:

                   segments[2]['find_layer'] = True

               else:

                   segments[2]['find_layer'] = False

               segments[3]['exist'] = False
               segments[3]['find_layer'] = False
               segments[3]['index'] = {}


        else:

            if transition_found:

                index_transition = np.argmax(abs(diff_data)>diff_data_std * segments[1]['parameter']['transition_fac']) - int(0.5*fit_length)
                segments[1]['index']['end'] = index_transition

            else:

                segments[1]['index']['end'] = self.settings['samples']['extend']


            segments[1]['exist'] = True

            if (segments[1]['index']['end'] - segments[1]['index']['start']) > segments[1]['parameter']['fit_length']:

                segments[1]['find_layer'] = True

            else:

                segments[1]['find_layer'] = False


            segments[2]['exist'] = False
            segments[2]['find_layer'] = False
            segments[2]['index'] = {}
            segments[3]['exist'] = False
            segments[3]['find_layer'] = False
            segments[3]['index'] = {}









    def _find_layer(self, layers, segments, x_data, y_data, y_data_scaled, indenter_characteristics, poisson_ratio):

        y_fit = dict() # can be used later to plot stuff
        fit_trim = dict()

        noise_lvl_adapted = self.noise_level['value'] / (1e-09 / self.units['force']['factor'])

        for seg in segments.keys():

            if segments[seg]['parameter']['reverse_search']:

                residual_fac = 5 - math.log10(segments[seg]['parameter']['residual_sensitivity'])
                layers[seg] = dict()

                if segments[seg]['find_layer']:

                    line_found = False
                    loop_run = True

                    start_index = segments[seg]['index']['end'] - 1
                    #reversed as search moves in oposite direction
                    fit_end = start_index + 1
                    fit_start = fit_end - segments[seg]['parameter']['fit_length']


                    if fit_end > segments[seg]['index']['end']:

                        loop_run = False


                    else:

                        # fit and determine quality of fit
                        fit = np.polyfit(x_data[fit_start:fit_end], y_data_scaled[seg][fit_start:fit_end],1)

                        total_sum_of_squares = np.sum((y_data_scaled[seg][fit_start:fit_end] - np.mean(y_data_scaled[seg][fit_start:fit_end]))**2 )
                        residuals = x_data[fit_start:fit_end] *fit[0] + fit[1] - y_data_scaled[seg][fit_start:fit_end]
                        squared_sum_residuals = np.sum(residuals**2)
                        r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)

#                        print(fit_start, fit_end, r_squared, np.sqrt(squared_sum_residuals), residual_fac * self.noise_level['value'])
                        if segments[seg]['parameter']['with_residuals']:

                            if r_squared > segments[seg]['parameter']['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac * noise_lvl_adapted:

                                straight_line = True
                                line_found = True

                            else:

                                straight_line = False


                            while fit_start > segments[seg]['index']['start'] and loop_run:

                                if straight_line:

                                    fit_start -= 1

                                    fit = np.polyfit(x_data[fit_start:fit_end], y_data_scaled[seg][fit_start:fit_end],1)

                                    total_sum_of_squares = np.sum((y_data_scaled[seg][fit_start:fit_end] - np.mean(y_data_scaled[seg][fit_start:fit_end]))**2 )
                                    residuals = x_data[fit_start:fit_end] *fit[0] + fit[1] - y_data_scaled[seg][fit_start:fit_end]
                                    squared_sum_residuals = np.sum(residuals**2)
                                    r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                                    if r_squared > segments[seg]['parameter']['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac * noise_lvl_adapted:

                                        straight_line = True

                                    else:

                                        straight_line = False
                                        loop_run = False


                                else:

                                    fit_end = fit_end - 1
                                    fit_start = fit_end - segments[seg]['parameter']['fit_length']

                                    fit = np.polyfit(x_data[fit_start:fit_end], y_data_scaled[seg][fit_start:fit_end],1)

                                    total_sum_of_squares = np.sum((y_data_scaled[seg][fit_start:fit_end] - np.mean(y_data_scaled[seg][fit_start:fit_end]))**2 )
                                    residuals = x_data[fit_start:fit_end] *fit[0] + fit[1] - y_data_scaled[seg][fit_start:fit_end]
                                    squared_sum_residuals = np.sum(residuals**2)
                                    r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                                    if r_squared > segments[seg]['parameter']['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac * noise_lvl_adapted:

                                        straight_line = True
                                        line_found = True


                        else:

                            if r_squared > segments[seg]['parameter']['r_squared_limit']:

                                straight_line = True
                                line_found = True

                            else:

                                straight_line = False


                            while fit_start > segments[seg]['index']['start'] and loop_run:

                                if straight_line:

                                    fit_start -= 1

                                    fit = np.polyfit(x_data[fit_start:fit_end], y_data_scaled[seg][fit_start:fit_end],1)

                                    total_sum_of_squares = np.sum((y_data_scaled[seg][fit_start:fit_end] - np.mean(y_data_scaled[seg][fit_start:fit_end]))**2 )
                                    residuals = x_data[fit_start:fit_end] *fit[0] + fit[1] - y_data_scaled[seg][fit_start:fit_end]
                                    squared_sum_residuals = np.sum(residuals**2)
                                    r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                                    if r_squared > segments[seg]['parameter']['r_squared_limit']:

                                        straight_line = True

                                    else:

                                        straight_line = False
                                        loop_run = False


                                else:

                                    fit_end = fit_end - 1
                                    fit_start = fit_end - segments[seg]['parameter']['fit_length']

                                    fit = np.polyfit(x_data[fit_start:fit_end], y_data_scaled[seg][fit_start:fit_end],1)

                                    total_sum_of_squares = np.sum((y_data_scaled[seg][fit_start:fit_end] - np.mean(y_data_scaled[seg][fit_start:fit_end]))**2 )
                                    residuals = x_data[fit_start:fit_end] *fit[0] + fit[1] - y_data_scaled[seg][fit_start:fit_end]
                                    squared_sum_residuals = np.sum(residuals**2)
                                    r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                                    if r_squared > segments[seg]['parameter']['r_squared_limit']:

                                        straight_line = True
                                        line_found = True


                    layers[seg]['segment'] = seg
                    layers[seg]['find_layer'] = True
                    layers[seg]['fit'] = dict()

                    if line_found:

                        fit_length_final = fit_end - fit_start
                        fit_end_mod = fit_end
                        fit_start_mod = fit_end - int(segments[seg]['parameter']['final_fit_fraction'] * fit_length_final)

                        fit_trim[seg] = np.polyfit(x_data[fit_start_mod:fit_end_mod], y_data_scaled[seg][fit_start_mod:fit_end_mod],1)

                        # calculate the residuals
                        residuals_linear = x_data[fit_start_mod:fit_end_mod] * fit_trim[seg][0] + fit_trim[seg][1] - y_data_scaled[seg][fit_start_mod:fit_end_mod]

                        layers[seg]['fit']['line_found'] = True
                        layers[seg]['fit']['index'] = (fit_start_mod,fit_end_mod-1)
                        layers[seg]['fit']['interval'] = (self.data['extend'][self.keys['ts_key']][fit_start_mod],self.data['extend'][self.keys['ts_key']][fit_end_mod-1])
                        layers[seg]['fit']['fit_parameter'] = - fit_trim[seg][0]
                        layers[seg]['fit']['contact_point'] = dict()
                        layers[seg]['fit']['contact_point']['index'] = np.argmax(self.data['extend'][self.keys['ts_key']] < -fit_trim[seg][1]/fit_trim[seg][0])
                        layers[seg]['fit']['contact_point']['value'] = -fit_trim[seg][1]/fit_trim[seg][0]
                        layers[seg]['fit']['specifics'] = dict()
                        layers[seg]['fit']['specifics']['start_index'] = segments[seg]['index']['start']
                        layers[seg]['fit']['specifics']['full_index'] = (fit_start,fit_end-1)

                        layers[seg]['residuals'] = dict()
                        layers[seg]['residuals']['unit'] = 'nN'
                        layers[seg]['residuals']['mean_linear_fit'] = np.mean(np.absolute(residuals_linear))
                        layers[seg]['residuals']['data_linear_fit'] = residuals_linear


                        ##part dependend on indenter
                        if indenter_characteristics['geometry'] == 'parabolic':

                            e_modul = np.power(abs(fit_trim[seg][0]),3/2) * (1 - poisson_ratio**2) * 3 / (4 * math.sqrt(indenter_characteristics['radius [nm]']))

                            x_fit = copy.deepcopy(x_data)
                            ind = -(x_fit - layers[seg]['fit']['contact_point']['value'])
                            ind[ind<0] = 0
                            y_fit[seg] = np.power(abs(fit_trim[seg][0]),3/2) * np.power(ind,3/2)

                            residuals = y_fit[seg][fit_start:fit_end] - y_data[fit_start:fit_end]

                            layers[seg]['residuals']['mean'] = np.mean(np.absolute(residuals))
                            layers[seg]['residuals']['data'] = residuals



                        elif indenter_characteristics['geometry'] == 'conical':

                            e_modul = fit_trim[seg][0]**2 * (1 - poisson_ratio**2) * np.pi / (2 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                            x_fit = copy.deepcopy(x_data)
                            ind = -(x_fit - layers[seg]['fit']['contact_point']['value'])
                            ind[ind<0] = 0
                            y_fit[seg] = fit_trim[seg][0]**2 * ind**2

                            residuals = y_fit[seg][fit_start:fit_end] - y_data[fit_start:fit_end]

                            layers[seg]['residuals']['mean'] = np.mean(np.absolute(residuals))
                            layers[seg]['residuals']['data'] = residuals


                        elif indenter_characteristics['geometry'] == 'four-sided pyramid':

                            e_modul = fit_trim[seg][0]**2 * (1 - poisson_ratio**2) / (0.7453 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                            x_fit = copy.deepcopy(x_data)
                            ind = -(x_fit - layers[seg]['fit']['contact_point']['value'])
                            ind[ind<0] = 0
                            y_fit[seg] = fit_trim[seg][0]**2 * ind**2

                            residuals = y_fit[seg][fit_start:fit_end] - y_data[fit_start:fit_end]

                            layers[seg]['residuals']['mean'] = np.mean(np.absolute(residuals))
                            layers[seg]['residuals']['data'] = residuals



                    else:

                        layers[seg]['fit']['line_found'] = False
                        layers[seg]['residuals'] = dict()

                        e_modul = np.nan


                else:

                    layers[seg]['segment'] = seg
                    layers[seg]['find_layer'] = False
                    layers[seg]['fit'] = {'line_found': False}
                    layers[seg]['residuals'] = dict()

                    e_modul = np.nan


            else:

                residual_fac = 5 - math.log10(segments[seg]['parameter']['residual_sensitivity'])

                layers[seg] = dict()

                if segments[seg]['find_layer']:

                    line_found = False
                    loop_run = True

                    fit_start = segments[seg]['index']['start']
                    fit_end = fit_start + segments[seg]['parameter']['fit_length']

                    if fit_end > segments[seg]['index']['end']:

                        loop_run = False

                    else:

                        # fit and determine quality of fit
                        fit = np.polyfit(x_data[fit_start:fit_end], y_data_scaled[seg][fit_start:fit_end],1)

                        total_sum_of_squares = np.sum((y_data_scaled[seg][fit_start:fit_end] - np.mean(y_data_scaled[seg][fit_start:fit_end]))**2 )
                        residuals = x_data[fit_start:fit_end] *fit[0] + fit[1] - y_data_scaled[seg][fit_start:fit_end]
                        squared_sum_residuals = np.sum(residuals**2)
                        r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                        if segments[seg]['parameter']['with_residuals']:

                            if r_squared > segments[seg]['parameter']['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac * noise_lvl_adapted:

                                straight_line = True
                                line_found = True

                            else:

                                straight_line = False


                            while fit_end < segments[seg]['index']['end'] and loop_run:

                                if straight_line:

                                    fit_end += 1

                                    fit = np.polyfit(x_data[fit_start:fit_end], y_data_scaled[seg][fit_start:fit_end],1)

                                    total_sum_of_squares = np.sum((y_data_scaled[seg][fit_start:fit_end] - np.mean(y_data_scaled[seg][fit_start:fit_end]))**2 )
                                    residuals = x_data[fit_start:fit_end] *fit[0] + fit[1] - y_data_scaled[seg][fit_start:fit_end]
                                    squared_sum_residuals = np.sum(residuals**2)
                                    r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                                    if r_squared > segments[seg]['parameter']['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac * noise_lvl_adapted:

                                        straight_line = True

                                    else:

                                        straight_line = False
                                        loop_run = False


                                else:

                                    fit_start = fit_start + 1
                                    fit_end = fit_start + segments[seg]['parameter']['fit_length']

                                    fit = np.polyfit(x_data[fit_start:fit_end], y_data_scaled[seg][fit_start:fit_end],1)

                                    total_sum_of_squares = np.sum((y_data_scaled[seg][fit_start:fit_end] - np.mean(y_data_scaled[seg][fit_start:fit_end]))**2 )
                                    residuals = x_data[fit_start:fit_end] *fit[0] + fit[1] - y_data_scaled[seg][fit_start:fit_end]
                                    squared_sum_residuals = np.sum(residuals**2)
                                    r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                                    if r_squared > segments[seg]['parameter']['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac * noise_lvl_adapted:

                                        straight_line = True
                                        line_found = True



                        else:

                            if r_squared > segments[seg]['parameter']['r_squared_limit']:

                                straight_line = True
                                line_found = True

                            else:

                                straight_line = False


                            while fit_end < segments[seg]['index']['end'] and loop_run:

                                if straight_line:

                                    fit_end += 1

                                    fit = np.polyfit(x_data[fit_start:fit_end], y_data_scaled[seg][fit_start:fit_end],1)

                                    total_sum_of_squares = np.sum((y_data_scaled[seg][fit_start:fit_end] - np.mean(y_data_scaled[seg][fit_start:fit_end]))**2 )
                                    residuals = x_data[fit_start:fit_end] *fit[0] + fit[1] - y_data_scaled[seg][fit_start:fit_end]
                                    squared_sum_residuals = np.sum(residuals**2)
                                    r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                                    if r_squared > segments[seg]['parameter']['r_squared_limit']:

                                        straight_line = True

                                    else:

                                        straight_line = False
                                        loop_run = False


                                else:

                                    fit_start = fit_start + 1
                                    fit_end = fit_start + segments[seg]['parameter']['fit_length']

                                    fit = np.polyfit(x_data[fit_start:fit_end], y_data_scaled[seg][fit_start:fit_end],1)

                                    total_sum_of_squares = np.sum((y_data_scaled[seg][fit_start:fit_end] - np.mean(y_data_scaled[seg][fit_start:fit_end]))**2 )
                                    residuals = x_data[fit_start:fit_end] *fit[0] + fit[1] - y_data_scaled[seg][fit_start:fit_end]
                                    squared_sum_residuals = np.sum(residuals**2)
                                    r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                                    if r_squared > segments[seg]['parameter']['r_squared_limit']:

                                        straight_line = True
                                        line_found = True


                    layers[seg]['segment'] = seg
                    layers[seg]['find_layer'] = True
                    layers[seg]['fit'] = dict()



                    if line_found:

                        fit_length_final = fit_end - fit_start
                        fit_start_mod = fit_start + int(0.5*(1 - segments[seg]['parameter']['final_fit_fraction'])  * fit_length_final)
                        fit_end_mod = fit_start + int(0.5 *(1 + segments[seg]['parameter']['final_fit_fraction']) * fit_length_final)

                        fit_trim[seg] = np.polyfit(x_data[fit_start_mod:fit_end_mod], y_data_scaled[seg][fit_start_mod:fit_end_mod],1)

                        # calculate the residuals
                        residuals_linear = x_data[fit_start_mod:fit_end_mod] * fit_trim[seg][0] + fit_trim[seg][1] - y_data_scaled[seg][fit_start_mod:fit_end_mod]

                        layers[seg]['fit']['line_found'] = True
                        layers[seg]['fit']['index'] = (fit_start_mod,fit_end_mod-1)
                        layers[seg]['fit']['interval'] = (self.data['extend'][self.keys['ts_key']][fit_start_mod],self.data['extend'][self.keys['ts_key']][fit_end_mod-1])
                        layers[seg]['fit']['fit_parameter'] = - fit_trim[seg][0]
                        layers[seg]['fit']['contact_point'] = dict()
                        layers[seg]['fit']['contact_point']['index'] = np.argmax(self.data['extend'][self.keys['ts_key']] < -fit_trim[seg][1]/fit_trim[seg][0])
                        layers[seg]['fit']['contact_point']['value'] = -fit_trim[seg][1]/fit_trim[seg][0]
                        layers[seg]['fit']['specifics'] = dict()
                        layers[seg]['fit']['specifics']['start_index'] = segments[seg]['index']['start']
                        layers[seg]['fit']['specifics']['full_index'] = (fit_start,fit_end-1)

                        layers[seg]['residuals'] = dict()
                        layers[seg]['residuals']['unit'] = 'nN'
                        layers[seg]['residuals']['mean_linear_fit'] = np.mean(np.absolute(residuals_linear))
                        layers[seg]['residuals']['data_linear_fit'] = residuals_linear


                        ##part dependend on indenter
                        if indenter_characteristics['geometry'] == 'parabolic':

                            e_modul = np.power(abs(fit_trim[seg][0]),3/2) * (1 - poisson_ratio**2) * 3 / (4 * math.sqrt(indenter_characteristics['radius [nm]']))

                            x_fit = copy.deepcopy(x_data)
                            ind = -(x_fit - layers[seg]['fit']['contact_point']['value'])
                            ind[ind<0] = 0
                            y_fit[seg] = np.power(abs(fit_trim[seg][0]),3/2) * np.power(ind,3/2)

                            residuals = y_fit[seg][fit_start:fit_end] - y_data[fit_start:fit_end]

                            layers[seg]['residuals']['mean'] = np.mean(np.absolute(residuals))
                            layers[seg]['residuals']['data'] = residuals



                        elif indenter_characteristics['geometry'] == 'conical':

                            e_modul = fit_trim[seg][0]**2 * (1 - poisson_ratio**2) * np.pi / (2 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                            x_fit = copy.deepcopy(x_data)
                            ind = -(x_fit - layers[seg]['fit']['contact_point']['value'])
                            ind[ind<0] = 0
                            y_fit[seg] = fit_trim[seg][0]**2 * ind**2

                            residuals = y_fit[seg][fit_start:fit_end] - y_data[fit_start:fit_end]

                            layers[seg]['residuals']['mean'] = np.mean(np.absolute(residuals))
                            layers[seg]['residuals']['data'] = residuals


                        elif indenter_characteristics['geometry'] == 'four-sided pyramid':

                            e_modul = fit_trim[seg][0]**2 * (1 - poisson_ratio**2) / (0.7453 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                            x_fit = copy.deepcopy(x_data)
                            ind = -(x_fit - layers[seg]['fit']['contact_point']['value'])
                            ind[ind<0] = 0
                            y_fit[seg] = fit_trim[seg][0]**2 * ind**2

                            residuals = y_fit[seg][fit_start:fit_end] - y_data[fit_start:fit_end]

                            layers[seg]['residuals']['mean'] = np.mean(np.absolute(residuals))
                            layers[seg]['residuals']['data'] = residuals



                    else:

                        layers[seg]['fit']['line_found'] = False
                        layers[seg]['residuals'] = dict()

                        e_modul = np.nan


                else:

                    layers[seg]['segment'] = seg
                    layers[seg]['find_layer'] = False
                    layers[seg]['fit'] = {'line_found': False}
                    layers[seg]['residuals'] = dict()

                    e_modul = np.nan


            e_modul = e_modul * 10**9
            e_modul_unit = 'Pa'
            e_modul_factor = 1

            layers[seg]['young_modulus'] = {'value': e_modul, 'unit': e_modul_unit, 'factor': e_modul_factor}

        return y_fit, fit_trim



    def _get_elasticity_from_linear_hertz_fit(self, fit, poisson_ratio, indenter_characteristics):

        if indenter_characteristics['geometry'] == 'parabolic':

            E = np.power(abs(fit[0]),3/2) * (1 - poisson_ratio**2) * 3 / (4 * math.sqrt(indenter_characteristics['radius [nm]']))

        elif indenter_characteristics['geometry'] == 'conical':

            E = fit[0]**2 * (1 - poisson_ratio**2) * np.pi / (2 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

        elif indenter_characteristics['geometry'] == 'four-sided pyramid':

            E = fit[0]**2 * (1 - poisson_ratio**2) / (0.7453 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

        return E




    def _get_scaled_data(self, data, indenter_characteristics):

        if indenter_characteristics['geometry'] == 'parabolic':

            data_scaled = np.power(np.abs(data),2/3)

        elif indenter_characteristics['geometry'] == 'conical':

            data_scaled = np.sqrt(np.abs(data))

        elif indenter_characteristics['geometry'] == 'four-sided pyramid':

            data_scaled = np.sqrt(np.abs(data))


        return data_scaled





class ForceDistanceCurve_Batch():

    def __init__(self):

        self.file_info = dict()
        self.file_info['save_directory'] = os.getcwd()

        self.jpk_force_data = None
        self.data = dict()

        self.channels = list()
        self.channel_units = dict()

        self.settings = dict()

        self.calibrations = dict()


        self.keys = dict()

        #self.corrections = dict()

        self.units = dict()


        self.noise_level = dict()
        self.max_adhesion_force = dict()
        self.adhesion_energy = dict()
        self.snap_in = dict()
        self.rupture_length = dict()
        self.adhesion_signatures = dict()
        self.breakthrough_events = dict()
        self.hertz_fit = dict()
        self.linearized_hertz_fit = dict()
        self.two_layer_hertz = dict()
        self.multi_layer_hertz = dict()


        self.control_variables = dict()
        self.control_variables['file_imported'] = False
        #self.control_variables['baseline_corrected'] = False
        #self.control_variables['distance_corrected'] = False
        self.control_variables['tip_sample_separation_correction_performed'] = False #requried for set sensitivity etc.
        #self.control_variables['allow_analysis'] = False # is checked before running loop



#%%
    def import_data(self, filepath = str(), x_key = str()):

        if len(filepath) == 0:

            filepath = self.file_info['filename']

        if os.path.isfile(filepath):

            if filepath[filepath.rfind('.'):] == '.jpk-force':

                self.file_info['filename'] = filepath
                self.import_data_jpk_force(filepath, x_key)

            else:

                raise TypeError('ERROR! Given file is not a jpk-force file!')


        else:

            raise ValueError('ERROR! Given filepath or filename is incorrect!')




    def correct_data(self, **kwargs):

        #if self.control_variables['file_imported']:

        self.set_force_unit(kwargs['force_unit'])
        self.set_distance_unit(kwargs['distance_unit'])

        self.get_noise_level(frac_data = kwargs['noise_lvl']['frac_data'], method = kwargs['noise_lvl']['method'])

        if kwargs['baseline_correction']['applied']:

            self.baseline_correction(method = kwargs['baseline_correction']['method'],
                                     reference = kwargs['baseline_correction']['reference'],
                                     frac_data = kwargs['baseline_correction']['frac_data'])


        if kwargs['distance_correction']['applied']:

            self.distance_correction(method = kwargs['distance_correction']['method'],
                                     reference = kwargs['distance_correction']['reference'],
                                     smooth_applied = kwargs['distance_correction']['smooth_applied'],
                                     smooth_length = kwargs['distance_correction']['smooth_length'],
                                     length_fit = kwargs['distance_correction']['length_fit'])

        self.get_noise_level(frac_data = kwargs['noise_lvl']['frac_data'], method = kwargs['noise_lvl']['method'])
        self.get_tip_sample_separation()


#%% data import stuff
    def import_data_jpk_force(self, filepath, x_key):

        self.jpk_force_data = JPK_ForceFile()
        self.jpk_force_data.open_force_file(filepath)

        if x_key in self.jpk_force_data.channels:

            self.channels = [x_key, 'vDeflection']

        else:

            self.channels = [self.get_jpk_x_key(), 'vDeflection']


        for channel in self.channels:

            self.channel_units[channel] = self.jpk_force_data.channel_units[channel]


        self.set_keys(x_key = x_key)

        self.calibrations = copy.deepcopy(self.jpk_force_data.calibrations)
        self.settings = copy.deepcopy(self.jpk_force_data.settings)
        self.file_info['date'] =self.jpk_force_data.file_info['date']
        self.file_info['time'] =self.jpk_force_data.file_info['time']
        self.file_info['file_org'] =self.jpk_force_data.file_info['file_org']


        for seg in self.jpk_force_data.data.keys():

            self.data[seg] = dict()

            for channel in self.channels:

                self.data[seg][channel] = copy.deepcopy(self.jpk_force_data.data[seg][channel])



        self.control_variables['file_imported'] = True

        self.units['distance'] = dict()
        self.units['distance']['unit'] = 'm'
        self.units['distance']['factor'] = 1
        self.units['force'] = dict()
        self.units['force']['unit'] = 'N'
        self.units['force']['factor'] = 1

#        self.adhesion_energy['units'] = dict()
#        self.adhesion_energy['units']['energy'] = dict()
#        self.adhesion_energy['units']['energy']['unit'] = 'J'
#        self.adhesion_energy['units']['energy']['factor'] = 1



#%% data correction stuff
    def set_force_unit(self, magn = 'nN'):

        if magn in ['N', 'nN', 'pN']:

            if magn == 'N':

                fac = 1

            elif magn == 'nN':

                fac = 10**-9

            elif magn == 'pN':

                fac = 10**-12


            change_magn = self.units['force']['factor'] / fac

            self.units['force']['unit'] = magn
            self.units['force']['factor'] = self.units['force']['factor'] / change_magn

            for seg in self.data.keys():

                self.data[seg][self.keys['y_key']] = self.data[seg][self.keys['y_key']] * change_magn


            self.channel_units[self.keys['y_key']] = magn

        else:

            raise ValueError('ERROR! Given str is not a valid magnitude!')




    def set_distance_unit(self, magn = 'nm'):

        if magn in ['m', 'um', 'nm']:

            if magn == 'm':

                fac = 1

            elif magn == 'um':

                fac = 10**-6

            elif magn == 'nm':

                fac = 10**-9


            change_magn = self.units['distance']['factor'] / fac

            self.units['distance']['unit'] = magn
            self.units['distance']['factor'] = self.units['distance']['factor'] / change_magn

            for seg in self.data.keys():

                for channel in self.data[seg].keys():

                    if channel in JPK_ForceFile._distance_channel:

                        self.data[seg][channel] = self.data[seg][channel] * change_magn
                        self.channel_units[channel] = magn

        else:

            raise ValueError('ERROR! Given str is not a valid magnitude!')



    def get_noise_level(self, frac_data = 0.5, method = 'std_dev'):

        if method == 'std_dev':

            stddev_ext = np.std(self.data['extend'][self.keys['y_key']][0:int(self.settings['samples']['extend'] * frac_data)])
            stddev_ret = np.std(self.data['retract'][self.keys['y_key']][-int(self.settings['samples']['retract'] * frac_data):-1])

            self.noise_level['value'] = max([stddev_ext, stddev_ret])
            self.noise_level['unit'] = copy.deepcopy(self.units['force']['unit'])
            self.noise_level['factor'] = copy.deepcopy(self.units['force']['factor'])
            self.noise_level['method'] = 'std_dev'
            self.noise_level['extend'] = stddev_ext
            self.noise_level['retract'] = stddev_ret

        elif method == 'linear':

            linear_ext = np.mean(np.absolute(self.data['extend'][self.keys['y_key']][0:int(self.settings['samples']['extend'] * frac_data)]) - np.mean(self.data['extend'][self.keys['y_key']][0:int(self.settings['samples']['extend'] * frac_data)]))
            linear_ret = np.mean(np.absolute(self.data['retract'][self.keys['y_key']][-int(self.settings['samples']['retract'] * frac_data):-1]) - np.mean(self.data['retract'][self.keys['y_key']][-int(self.settings['samples']['retract'] * frac_data):-1]))

            self.noise_level['value'] = max([linear_ext, linear_ret])
            self.noise_level['unit'] = copy.deepcopy(self.units['force']['unit'])
            self.noise_level['factor'] = copy.deepcopy(self.units['force']['factor'])
            self.noise_level['method'] = 'linear'
            self.noise_level['extend'] = stddev_ext
            self.noise_level['retract'] = stddev_ret





    def baseline_correction(self, method = 'linear', reference = 'individual', frac_data = (0,0.5)):

        ret_dict = dict()

        if method == 'constant':

            corr_ext = np.mean(self.data['extend'][self.keys['y_key']][int((self.settings['samples']['extend']-1) * frac_data[0]):int((self.settings['samples']['extend']-1) * frac_data[1])])
            corr_ret = np.mean(self.data['retract'][self.keys['y_key']][-int(self.settings['samples']['retract'] * frac_data[1])-1:-int(self.settings['samples']['extend'] * frac_data[0])-1])

            ret_dict['parameter'] = {'corr_ext': corr_ext, 'corr_ret': corr_ret}

            if reference == 'individual':

                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - corr_ext
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - corr_ret

            elif reference == 'mean':

                corr_mean = 0.5 * (corr_ext + corr_ret)

                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - corr_mean
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - corr_mean

            elif reference == 'extend':

                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - corr_ext
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - corr_ext

            elif reference == 'retract':

                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - corr_ret
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - corr_ret


        elif method == 'linear':

            slope_ext, baseline_ext = np.polyfit(self.data['extend'][self.keys['x_key']][int((self.settings['samples']['extend']-1) * frac_data[0]):int((self.settings['samples']['extend']-1) * frac_data[1])],
                                                 self.data['extend'][self.keys['y_key']][int((self.settings['samples']['extend']-1) * frac_data[0]):int((self.settings['samples']['extend']-1) * frac_data[1])],1)
            slope_ret, baseline_ret = np.polyfit(self.data['retract'][self.keys['x_key']][-int(self.settings['samples']['retract'] * frac_data[1])-1:-int(self.settings['samples']['extend'] * frac_data[0])-1],
                                                 self.data['retract'][self.keys['y_key']][-int(self.settings['samples']['retract'] * frac_data[1])-1:-int(self.settings['samples']['extend'] * frac_data[0])-1],1)

            ret_dict['parameter'] = {'slope_ext': slope_ext, 'y_intercept_ext': baseline_ext,'slope_ret': slope_ret, 'y_intercept_ret': baseline_ret}

            if reference == 'individual':


                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - baseline_ext - (slope_ext * self.data['extend'][self.keys['x_key']])
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - baseline_ret - (slope_ret * self.data['retract'][self.keys['x_key']])

            elif reference == 'mean':

                slope_mean = 0.5 * (slope_ext + slope_ret)
                baseline_mean = 0.5 * (baseline_ext + baseline_ret)

                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - baseline_mean - (slope_mean * self.data['extend'][self.keys['x_key']])
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - baseline_mean - (slope_mean * self.data['retract'][self.keys['x_key']])

            elif reference == 'extend':

                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - baseline_ext - (slope_ext * self.data['extend'][self.keys['x_key']])
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - baseline_ext - (slope_ext * self.data['retract'][self.keys['x_key']])


            elif reference == 'retract':

                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - baseline_ret - (slope_ret * self.data['extend'][self.keys['x_key']])
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - baseline_ret - (slope_ret * self.data['retract'][self.keys['x_key']])


        elif method == 'quadratic':

            a2_ext, a1_ext, a0_ext = np.polyfit(self.data['extend'][self.keys['x_key']][int((self.settings['samples']['extend']-1) * frac_data[0]):int((self.settings['samples']['extend']-1) * frac_data[1])],
                                                 self.data['extend'][self.keys['y_key']][int((self.settings['samples']['extend']-1) * frac_data[0]):int((self.settings['samples']['extend']-1) * frac_data[1])],2)

            a2_ret, a1_ret, a0_ret = np.polyfit(self.data['retract'][self.keys['x_key']][-int(self.settings['samples']['retract'] * frac_data[1])-1:-int(self.settings['samples']['extend'] * frac_data[0])-1],
                                                 self.data['retract'][self.keys['y_key']][-int(self.settings['samples']['retract'] * frac_data[1])-1:-int(self.settings['samples']['extend'] * frac_data[0])-1],2)

            ret_dict['parameter']: {'a2_ext': a2_ext, 'a1_ext': a1_ext, 'a0_ext': a0_ext, 'a2_ret': a2_ret, 'a1_ret': a1_ret, 'a0_ret': a0_ret}


            if reference == 'individual':

                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - (a2_ext * self.data['extend'][self.keys['x_key']] * self.data['extend'][self.keys['x_key']] + a1_ext * self.data['extend'][self.keys['x_key']] + a0_ext)
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - (a2_ret * self.data['retract'][self.keys['x_key']] * self.data['retract'][self.keys['x_key']] + a1_ret * self.data['retract'][self.keys['x_key']] + a0_ret)

            elif reference == 'mean':

                a2_mean = 0.5 * (a2_ext + a2_ret)
                a1_mean = 0.5 * (a1_ext + a1_ret)
                a0_mean = 0.5 * (a0_ext + a0_ret)

                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - (a2_mean * self.data['extend'][self.keys['x_key']] * self.data['extend'][self.keys['x_key']] + a1_mean * self.data['extend'][self.keys['x_key']] + a0_mean)
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - (a2_mean * self.data['retract'][self.keys['x_key']] * self.data['retract'][self.keys['x_key']] + a1_mean * self.data['retract'][self.keys['x_key']] + a0_mean)

            elif reference == 'extend':

                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - (a2_ext * self.data['extend'][self.keys['x_key']] * self.data['extend'][self.keys['x_key']] + a1_ext * self.data['extend'][self.keys['x_key']] + a0_ext)
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - (a2_ext * self.data['retract'][self.keys['x_key']] * self.data['retract'][self.keys['x_key']] + a1_ext * self.data['retract'][self.keys['x_key']] + a0_ext)


            elif reference == 'retract':

                self.data['extend'][self.keys['y_key']] = self.data['extend'][self.keys['y_key']] - (a2_ret * self.data['extend'][self.keys['x_key']] * self.data['extend'][self.keys['x_key']] + a1_ret * self.data['extend'][self.keys['x_key']] + a0_ret)
                self.data['retract'][self.keys['y_key']] = self.data['retract'][self.keys['y_key']] - (a2_ret * self.data['retract'][self.keys['x_key']] * self.data['retract'][self.keys['x_key']] + a1_ret * self.data['retract'][self.keys['x_key']] + a0_ret)



        ret_dict['method'] = method
        ret_dict['reference'] = reference
        ret_dict['frac_data'] = frac_data


        return ret_dict




    def get_tip_sample_separation(self):

        for seg in self.data.keys():

            self.data[seg]['separation'] = self.data[seg][self.keys['x_key']] + self.data[seg][self.keys['y_key']] * self.units['force']['factor']/(self.calibrations['spring_constant'] * self.units['distance']['factor'])


        self.channels.append('separation')
        self.channel_units['separation'] = self.channel_units[self.keys['x_key']]

        self.control_variables['tip_sample_separation_correction_performed'] = True




    def distance_correction(self, method = 'zero_force', reference = 'extend', **kwargs):

        ret_dict = dict()
        ret_dict['method'] = method
        ret_dict['reference'] = reference



        if method == 'constant':

            ret_dict['parameter'] = self.distance_correction_constant(reference)


        elif method == 'zero_force':

            #start_type = ['contact', 'distance']

            if 'smooth_applied' in kwargs and type(kwargs['smooth_applied']) is bool:

                s_type = kwargs['smooth_applied']

            else:

                s_type = False

            if 'smooth_length' in kwargs and type(kwargs['smooth_length']) == int and kwargs['smooth_length'] > 0:

                s_length = kwargs['smooth_length']

            else:

                s_length = 51



            ret_dict['parameter'] = self.distance_correction_zero_force_intersect(reference, s_type, s_length)
            ret_dict['smooth_applied'] = s_type
            ret_dict['smooth_length'] = s_length


        elif method == 'fit':

            if 'length_fit' in kwargs:

                ret_dict['parameter'] = self.distance_correction_fit(reference, kwargs['length_fit'])
                ret_dict['length_fit'] = kwargs['length_fit']
            else:

                ret_dict['parameter'] = self.distance_correction_fit(reference)
                ret_dict['length_fit'] = 20

        else:

            ret_dict['parameter'] = self.distance_correction_constant()
            ret_dict['method'] = 'constant'

        return ret_dict




#%% data analysis


    def get_max_adhesion_force(self, **kwargs):

        index = np.argmin(self.data['retract'][self.keys['y_key']])

        self.max_adhesion_force['value'] = abs(self.data['retract'][self.keys['y_key']][index])
        self.max_adhesion_force['index'] = index
        self.max_adhesion_force['at_x_value'] = self.data['retract'][self.keys['ts_key']][index]
        self.max_adhesion_force['units'] = copy.deepcopy(self.units)




    def get_rupture_length(self, sensitivity = 1, text_out = False, **kwargs):

        fac = 5 - math.log10(sensitivity)

        if fac < 2:

            fac = 2

        #data = self.data['retract'][self.keys['y_key']]

        adh_event_found = False
        i = 1
        index = 0

        while not adh_event_found and i < self.settings['samples']['retract']:

            if self.data['retract'][self.keys['y_key']][-i] < - fac * self.noise_level['value']: # check whether point a bit before ref level is significantly smaller
                # if that is the case, confirm that it is not a single outlier

                adh_event_found = True
                index = self.settings['samples']['retract'] - i

                for j in range(0,5): #short check whether the point found was just an outlier

                   if self.data['retract'][self.keys['y_key']][-i-j] > - self.noise_level['value']:

                        adh_event_found = False
                        index = 0


            i += 1

        index_trigger = index

        if adh_event_found: #finds the last point that is smaller than the reference level

            i = 1
            add = 0

            while i < 20 and self.data['retract'][self.keys['y_key']][index+i] < - self.noise_level['value']:

                add = i
                i += 1


            index = index + add + 1

        # find the start of the final rupture event:
        index_start = index_trigger
        i = 0

        if adh_event_found:

            while self.data['retract'][self.keys['y_key']][index_start-i-1] < self.data['retract'][self.keys['y_key']][index_start-i] and i < index - 1:

                i += 1


            index_start = index_start - i


        zero_force = self.get_zero_force_intersect_retract(smooth_applied = False)
        zero_force_index = zero_force['index']

        self.rupture_length['index'] = index
        self.rupture_length['value'] = self.data['retract'][self.keys['ts_key']][index] - self.data['retract'][self.keys['ts_key']][zero_force_index]
        self.rupture_length['units'] = copy.deepcopy(self.units)
        self.rupture_length['sensitivity'] = sensitivity
        self.rupture_length['sensitivity_factor'] = fac
        self.rupture_length['additional_information'] = dict()
        self.rupture_length['additional_information']['zero_force_index'] = zero_force_index
        self.rupture_length['additional_information']['zero_force_value'] = zero_force['value_ts']
        self.rupture_length['additional_information']['last_rupture_end'] = self.data['retract'][self.keys['ts_key']][index]
        self.rupture_length['additional_information']['last_rupture_start'] = self.data['retract'][self.keys['ts_key']][index_start]
        self.rupture_length['additional_information']['rupture_start_index'] = index_start




    def get_adhesion_energy(self, sensitivity = 1, range_selection = {'method': 'automatic'}, **kwargs):

        self.adhesion_energy['range_selection'] = dict()

        if range_selection['method'] == 'automatic':

            self.adhesion_energy['range_selection']['method'] = 'automatic'
            start_index = self.get_zero_force_intersect_retract(smooth_applied = False)['index']
            end_index = self.get_last_adhesion_signature(sensitivity)['end_adh_event_index']

        elif range_selection['method'] == 'index':

            self.adhesion_energy['range_selection']['method'] = 'index'

            start_index = range_selection['range'][0]
            end_index = range_selection['range'][1]

        elif range_selection['method'] == 'interval':

            self.adhesion_energy['range_selection']['method'] = 'interval'

            end_index = np.argmax(self.data['extend'][self.keys['ts_key']]>range_selection['range'][1])
            start_index = np.argmin(self.data['extend'][self.keys['ts_key']]<range_selection['range'][0])

            if end_index and start_index:

                self.adhesion_energy['range_selection']['method'] = 'automatic'
                start_index = self.get_zero_force_intersect_retract(smooth_applied = False)['index']
                end_index = self.get_last_adhesion_signature(sensitivity)['end_adh_event_index']



        self.adhesion_energy['range_selection']['index_range'] = (start_index, end_index)
        self.adhesion_energy['range_selection']['interval'] = (self.data['retract'][self.keys['ts_key']][start_index], self.data['retract'][self.keys['ts_key']][end_index])


        bar_height = 0.5 * (self.data['retract'][self.keys['y_key']][start_index:end_index] + self.data['retract'][self.keys['y_key']][start_index+1:end_index+1])
        bar_width_ts = self.data['retract'][self.keys['ts_key']][start_index:end_index] - self.data['retract'][self.keys['ts_key']][start_index+1:end_index+1]
        bar_width_x = self.data['retract'][self.keys['x_key']][start_index:end_index] - self.data['retract'][self.keys['x_key']][start_index+1:end_index+1]
        bar_height[bar_height>0] = 0

        #print(bar_height*bar_width_ts)

        sum_eng_ts = np.sum(bar_height*bar_width_ts)
        sum_eng_x = np.sum(bar_height*bar_width_x)


        self.adhesion_energy['value'] = abs(sum_eng_x)
        self.adhesion_energy['value_ts'] = abs(sum_eng_ts)

        self.adhesion_energy['units'] = dict()
        self.adhesion_energy['units']['distance'] = dict()
        self.adhesion_energy['units']['distance']['unit'] = copy.deepcopy(self.units['distance']['unit'])
        self.adhesion_energy['units']['distance']['factor'] = copy.deepcopy(self.units['distance']['factor'])

        self.adhesion_energy['units']['energy'] = dict()
        self.adhesion_energy['units']['energy']['unit'] = str(10**round(np.log10(self.units['distance']['factor']*self.units['force']['factor']))) + ' J'
        self.adhesion_energy['units']['energy']['factor'] = 10**round(np.log10(self.units['distance']['factor']*self.units['force']['factor']))




    def get_snap_in(self, sensitivity = 1, event_sep = 0, mean_length = 5, **kwargs):

        fac = 5 - math.log10(sensitivity)

        if fac < 2:

            fac = 2


        data_y_reverse = copy.deepcopy(self.data['extend'][self.keys['y_key']])
        data_y_reverse = data_y_reverse[::-1]

        potential_events = list()
        i = mean_length

        while i < self.settings['samples']['extend'] - 100:

            j = 0

            while data_y_reverse[i+j] < data_y_reverse[i+j+1] and i + j < self.settings['samples']['extend'] - 50:

                j += 1


            if j > 0:

                potential_events.append((i,i+j))

            j += 1
            i += j

        diff_list = list()


        for events in potential_events:

             if mean_length > 0:

                  diff = np.mean(data_y_reverse[events[0]-mean_length:events[0]]) - np.mean(data_y_reverse[events[1]:events[1]+mean_length])

                  if diff > 0:

                       diff = 0

                  diff_list.append(abs(diff))

             else:

                  diff_list.append(abs(data_y_reverse[events[0]]-data_y_reverse[events[1]]))


        events_reverse = [(potential_events[i]) for i in range(0,len(diff_list)) if diff_list[i] > self.noise_level['value'] * fac]


        if event_sep > 0:

           events_comb_reverse = combine_tuple(events_reverse, event_sep)

        else:

           events_comb_reverse = events_reverse


        if len(events_comb_reverse) > 0: #there is an event

            event = events_comb_reverse[0]

            #find the end of the snap in
            end_found = False
            i = self.settings['samples']['extend']-event[1]
            start_snap_in = self.data['extend'][self.keys['y_key']][self.settings['samples']['extend']-event[1]-1]

            while not end_found and i < self.settings['samples']['extend'] - 1:

                if self.data['extend'][self.keys['y_key']][i] < start_snap_in:

                    i += 1

                else:

                     end_found = True

            #find the minimum of the snap in
            min_snap_in = self.data['extend'][self.keys['y_key']][self.settings['samples']['extend']-event[1]-1]
            min_index = self.settings['samples']['extend']-event[1]-1
            j = self.settings['samples']['extend']-event[0]-1

            while j < self.settings['samples']['extend'] - 1:

                if self.data['extend'][self.keys['y_key']][j] < min_snap_in:

                    min_snap_in = self.data['extend'][self.keys['y_key']][j]
                    min_index = j

                j += 1


            magn = self.data['extend'][self.keys['y_key']][self.settings['samples']['extend']-event[0]-1] - self.data['extend'][self.keys['y_key']][self.settings['samples']['extend']-event[1]-1]
            magn = min_snap_in - self.data['extend'][self.keys['y_key']][self.settings['samples']['extend']-event[1]-1]

            self.snap_in['exists'] = True
            self.snap_in['magn'] = abs(magn)
            self.snap_in['index'] = self.settings['samples']['extend']-event[1]-1
            self.snap_in['start_x_value'] = self.data['extend'][self.keys['ts_key']][self.snap_in['index']]
            self.snap_in['end_index'] = i
            self.snap_in['end_x_value'] = self.data['extend'][self.keys['ts_key']][i]
            self.snap_in['units'] = copy.deepcopy(self.units)


        else:

            self.snap_in['exists'] = False
            self.snap_in['magn'] = 0
            self.snap_in['index'] = 0
            self.snap_in['start_x_value'] = 0
            self.snap_in['end_index'] = 0
            self.snap_in['end_x_value'] = 0
            self.snap_in['units'] = copy.deepcopy(self.units)




    def get_adhesion_signatures(self, method = 'derivation', sensitivity = 1, event_sep = 0, mean_length = 5, range_selection = {'method': 'automatic'}, only_after_max_adh = False, **kwargs):

        fac = 5 - math.log10(sensitivity)

        if fac < 2:

            fac = 2


        self.adhesion_signatures['range_selection'] = dict()

        if range_selection['method'] == 'automatic':

            self.adhesion_signatures['range_selection']['method'] = 'automatic'
            start_index = self.get_zero_force_intersect_retract(smooth_applied = False)['index']
            end_index = self.get_last_adhesion_signature(sensitivity)['end_adh_event_index']

        elif range_selection['method'] == 'index':

            self.adhesion_signatures['range_selection']['method'] = 'index'

            start_index = range_selection['range'][0]
            end_index = range_selection['range'][1]

        elif range_selection['method'] == 'interval':

            self.adhesion_signatures['range_selection']['method'] = 'interval'

            end_index = np.argmax(self.data['extend'][self.keys['ts_key']]>range_selection['range'][1])
            start_index = np.argmin(self.data['extend'][self.keys['ts_key']]<range_selection['range'][0])

            if end_index and start_index:

                self.adhesion_signatures['range_selection']['method'] = 'automatic'
                start_index = self.get_zero_force_intersect_retract(smooth_applied = False)['index']
                end_index = self.get_last_adhesion_signature(sensitivity)['end_adh_event_index']



        self.adhesion_signatures['range_selection']['index_range'] = (start_index, end_index)
        self.adhesion_signatures['range_selection']['interval'] = (self.data['retract'][self.keys['ts_key']][start_index], self.data['retract'][self.keys['ts_key']][end_index])
        self.adhesion_signatures['range_selection']['only_after_max_adh'] = only_after_max_adh

        if only_after_max_adh:

            #start_index = max(start_index, np.argmin(self.data['retract'][self.keys['y_key']]))
            start_index = np.argmin(self.data['retract'][self.keys['y_key']])


        self.adhesion_signatures['method'] = method

        #end_adh = self.get_last_adhesion_signature(sensitivity = sensitivity) unnecessary


        if method == 'derivation':

            #data_x = self.data['retract'][self.keys['x_key']][start_index:end_index]
            #data_y = self.data['retract'][self.keys['y_key']][start_index:end_index]


            # 1. get potential rupture events
            potential_rupt_index = list()
            avg_slope = np.mean(np.absolute(self.data['retract'][self.keys['y_key']][-50:-2] - self.data['retract'][self.keys['y_key']][-49:-1]))

            i = start_index

            #for i in range(start_index, end_index-1):
            while i < end_index - 1:

                x_diff = max(0,self.data['retract'][self.keys['x_key']][i+1] - self.data['retract'][self.keys['x_key']][i])
                y_diff = self.data['retract'][self.keys['y_key']][i+1] - self.data['retract'][self.keys['y_key']][i]

                #if x_diff <= 0:

                #    diff = y_diff

                #else:

                #    diff = y_diff/x_diff


                if y_diff/(x_diff or not 0) > avg_slope * fac:

                    potential_rupt_index.append(i)

                    while (self.data['retract'][self.keys['x_key']][i+1] - self.data['retract'][self.keys['x_key']][i])/((self.data['retract'][self.keys['y_key']][i+1] - self.data['retract'][self.keys['y_key']][i]) or not 0) > avg_slope * fac:

                        i += 1

                i += 1


            # 3. get start and end index of all of these potential rupture events
            #rupt_events = dict()
            events = list()
            for i in range(0, len(potential_rupt_index)):

                i_minus = 0
                i_plus = 0

                while self.data['retract'][self.keys['y_key']][potential_rupt_index[i]+i_plus+1] > self.data['retract'][self.keys['y_key']][potential_rupt_index[i]+i_plus]:

                    i_plus += 1

                while self.data['retract'][self.keys['y_key']][potential_rupt_index[i]-i_minus] > self.data['retract'][self.keys['y_key']][potential_rupt_index[i]-i_minus-1]:

                    i_minus += 1


                #rupt_events[i] = [potential_rupt_index[i] - i_minus, potential_rupt_index[i] + i_plus + 1]
                events.append((potential_rupt_index[i] - i_minus, potential_rupt_index[i] + i_plus))


            if event_sep > 0:

                events_comb = combine_tuple(events, event_sep)

            else:

                events_comb = combine_tuple(events, 0) #combine any overlapping events

            # sort out any events that are too small

            events_final = list()

            for i in range(0, len(events_comb)):

                if mean_length > 0:

                     diff = abs(np.mean(self.data['retract'][self.keys['y_key']][events_comb[i][0]-mean_length:events_comb[i][0]])) - abs(np.mean(self.data['retract'][self.keys['y_key']][events_comb[i][1]:events_comb[i][1]+mean_length]))

                else:

                     diff = abs(self.data['retract'][self.keys['y_key']][events_comb[i][0]]) - abs(self.data['retract'][self.keys['y_key']][events_comb[i][1]])

                #diff = abs(data_y[events_comb[i][0]]) - abs(data_y[events_comb[i][1]])

                if diff > self.noise_level['value'] * fac:

                    events_final.append(events_comb[i])

            # 4. confirm that the suggested events are rupture events

            self.adhesion_signatures['events'] = list()

            confirmed_counter = 0
            unclear_counter = 0

            for i in range(0, len(events_final)):

                self.adhesion_signatures['events'].append(dict())
                self.adhesion_signatures['events'][i]['event_num'] = i

                magn = abs(self.data['retract'][self.keys['y_key']][events_final[i][0]]) - abs(self.data['retract'][self.keys['y_key']][events_final[i][1]])
                #diff = abs(data_y[events_final[i][0]]) - abs(data_y[events_final[i][1]])

                if mean_length > 0:

                     diff = abs(np.mean(self.data['retract'][self.keys['y_key']][events_final[i][0]-mean_length:events_final[i][0]])) - abs(np.mean(self.data['retract'][self.keys['y_key']][events_final[i][1]:events_final[i][1]+mean_length]))

                else:

                     diff = abs(self.data['retract'][self.keys['y_key']][events_final[i][0]]) - abs(self.data['retract'][self.keys['y_key']][events_final[i][1]])


                if diff > self.noise_level['value'] * fac * 2:

                    self.adhesion_signatures['events'][i]['status'] = 'confirmed'
                    confirmed_counter += 1

                else:

                    self.adhesion_signatures['events'][i]['status'] = 'unclear'
                    unclear_counter += 1


                self.adhesion_signatures['events'][i]['force_start'] = abs(self.data['retract'][self.keys['y_key']][events_final[i][0]])
                self.adhesion_signatures['events'][i]['magnitude'] = magn
                self.adhesion_signatures['events'][i]['index'] = (events_final[i][0],events_final[i][1])
                #rupt_events_final['events'][i]['type'] = 'non-characterized'


                self.adhesion_signatures['events'][i]['x_loc_start_ts'] = self.data['retract'][self.keys['ts_key']][events_final[i][0]]
                self.adhesion_signatures['events'][i]['x_loc_end_ts'] = self.data['retract'][self.keys['ts_key']][events_final[i][1]]
                self.adhesion_signatures['events'][i]['x_loc_start_h'] = self.data['retract'][self.keys['x_key']][events_final[i][0]]
                self.adhesion_signatures['events'][i]['x_loc_end_h'] = self.data['retract'][self.keys['x_key']][events_final[i][1]]



        elif method == 'jump':

            self.adhesion_signatures['events'] = list()

            # 1. get potential events
            potential_events = list()

            i = start_index

            while i < end_index - mean_length + 1:

                j = 0

                while self.data['retract'][self.keys['y_key']][i+j] < self.data['retract'][self.keys['y_key']][i+j+1] and i + j < self.settings['samples']['retract'] - 50:

                    j += 1


                if j > 0:

                    potential_events.append((i,i+j))


                j += 1
                i += j


            # 2. calculate difference between start and end for potential events
            diff_list = list()

            for events in potential_events:

                if mean_length > 0:

                     #diff = abs(statistics.mean(data_y[events_final[i][0]-mean_length:events_final[i][0]])) - abs(statistics.mean(data_y[events_final[i][1]:events_final[i][1]+mean_length]))
                     diff = np.mean(self.data['retract'][self.keys['y_key']][events[1]:events[1]+mean_length]) - np.mean(self.data['retract'][self.keys['y_key']][events[0]-mean_length:events[0]])

                else:

                     diff = self.data['retract'][self.keys['y_key']][events[0]]-self.data['retract'][self.keys['y_key']][events[1]]

                diff_list.append(diff)



            events = [(potential_events[i]) for i in range(0,len(diff_list)) if diff_list[i] > self.noise_level['value'] * fac]

            if event_sep > 0:

                events_comb = combine_tuple(events, event_sep)

            else:

                events_comb = events

            confirmed_counter = 0
            unclear_counter = 0

            for i in range(0, len(events_comb)):

                self.adhesion_signatures['events'].append(dict())
                self.adhesion_signatures['events'][i]['event_num'] = i

                magn = abs(self.data['retract'][self.keys['y_key']][events_comb[i][0]]) - abs(self.data['retract'][self.keys['y_key']][events_comb[i][1]])
                diff = abs(self.data['retract'][self.keys['y_key']][events_comb[i][0]]) - abs(self.data['retract'][self.keys['y_key']][events_comb[i][1]])

                if mean_length > 0:

                     diff = abs(np.mean(self.data['retract'][self.keys['y_key']][events_comb[i][0]-mean_length:events_comb[i][0]])-np.mean(self.data['retract'][self.keys['y_key']][events_comb[i][1]:events_comb[i][1]+mean_length]))
                     #diff = abs(data_y[events_comb[i][0]]) - abs(data_y[events_comb[i][1]])

                else:

                     diff = abs(self.data['retract'][self.keys['y_key']][events_comb[i][0]]) - abs(self.data['retract'][self.keys['y_key']][events_comb[i][1]])


                if diff > self.noise_level['value'] * fac * 2:

                    self.adhesion_signatures['events'][i]['status'] = 'confirmed'
                    confirmed_counter += 1

                else:

                    self.adhesion_signatures['events'][i]['status'] = 'unclear'
                    unclear_counter += 1



                self.adhesion_signatures['events'][i]['force_start'] = abs(self.data['retract'][self.keys['y_key']][events_comb[i][0]])
                self.adhesion_signatures['events'][i]['magnitude'] = magn
                self.adhesion_signatures['events'][i]['index'] = (events_comb[i][0],events_comb[i][1])
                #rupt_events_final['events'][i]['type'] = 'non-characterized'

                self.adhesion_signatures['events'][i]['x_loc_start_ts_separation'] = self.data['retract'][self.keys['ts_key']][events_comb[i][0]]
                self.adhesion_signatures['events'][i]['x_loc_end_ts_separation'] = self.data['retract'][self.keys['ts_key']][events_comb[i][1]]
                self.adhesion_signatures['events'][i]['x_loc_start_h'] = self.data['retract'][self.keys['x_key']][events_comb[i][0]]
                self.adhesion_signatures['events'][i]['x_loc_end_h'] = self.data['retract'][self.keys['x_key']][events_comb[i][1]]

        self.adhesion_signatures['confirmed_events'] = confirmed_counter
        self.adhesion_signatures['unclear_events'] = unclear_counter
        self.adhesion_signatures['sensitivity'] = sensitivity
        self.adhesion_signatures['sensitivity_factor'] = fac
        self.adhesion_signatures['event_sep'] = event_sep
        self.adhesion_signatures['event_sep'] = mean_length

        self.adhesion_signatures['units'] = copy.deepcopy(self.units)




    def get_slope_contact(self, frac_data = (0.95,1)):

        slope_ext, baseline_ext = np.polyfit(self.data['extend'][self.keys['ts_key']][int(self.settings['samples']['extend'] * frac_data[0]):int(self.settings['samples']['extend'] * frac_data[1])],
                                             self.data['extend'][self.keys['y_key']][int(self.settings['samples']['extend'] * frac_data[0]):int(self.settings['samples']['extend'] * frac_data[1])],1)
        slope_ret, baseline_ret = np.polyfit(self.data['retract'][self.keys['ts_key']][-int(self.settings['samples']['retract'] * frac_data[1])-1:-int(self.settings['samples']['extend'] * frac_data[0])-1],
                                             self.data['retract'][self.keys['y_key']][-int(self.settings['samples']['retract'] * frac_data[1])-1:-int(self.settings['samples']['extend'] * frac_data[0])-1],1)

#            ret_dict = dict()
#            ret_dict['results'] = dict()
#            ret_dict['results']['extend'] = {'slope': slope_ext, 'baseline': baseline_ext}
#            ret_dict['results']['retract'] = {'slope': slope_ret, 'baseline': baseline_ret}
#            ret_dict['parameter'] = dict()
#            ret_dict['parameter']['frac_data'] = frac_data
#            ret_dict = {'results': {'extend': {'slope': slope_ext, 'baseline': baseline_ext}, 'retract': {'slope': slope_ret, 'baseline': baseline_ret}}, 'parameters': {'frac_data': frac_data}}

        ret_dict = {'results': {'extend': {'slope': abs(slope_ext)}, 'retract': {'slope': abs(slope_ret)}}, 'parameter': {'frac_data': frac_data}}

        return ret_dict



    def get_breakthrough_events(self, sensitivity = 1, start_fraction = 0.5, event_sep = 1):

        fac = 5 - math.log10(sensitivity)

        end_index = len(self.data['extend'][self.keys['ts_key']]) - 1
        i =  int((end_index + 1) * start_fraction)

        # 1. get list of potential events, every event where the deflection is smaller than before is a potential event
        events_potential = list()
        while i < end_index:

            j = 0
            # finds all the events were the deflection is reduced for consecutive points
            while i + j + 1 < end_index and self.data['extend'][self.keys['y_key']][i+j] > self.data['extend'][self.keys['y_key']][i+j+1]:

                j += 1

            if j > 0:

                events_potential.append((i,i+j))

            i = i + j + 1

        # 2. calculate magnitude for each potential event and remove all events that are too small
        events_new = list()

        for event in events_potential:

            diff = self.data['extend'][self.keys['y_key']][event[0]] - self.data['extend'][self.keys['y_key']][event[1]]

            if diff > self.noise_level['value'] * fac:

                events_new.append(event)

        # 3. combine events

        if event_sep > 0:

            events_final = _Helper_Functions_General.combine_tuple(events_new, event_sep)

        else:

            events_final = events_new

        self.breakthrough_events['exists'] = bool(len(events_final))
        self.breakthrough_events['parameter'] = {'sensitivity': sensitivity, 'sensitivity_factor':fac, 'event_separation':event_sep}
        self.breakthrough_events['noise_level'] = self.noise_level['value']
        self.breakthrough_events['units'] = copy.deepcopy(self.units)
        self.breakthrough_events['events'] = dict()

        for i in range(len(events_final)):

            self.breakthrough_events['events'][i] = dict()
            self.breakthrough_events['events'][i]['index'] = events_final[i]
            self.breakthrough_events['events'][i]['indentation'] = (self.data['extend'][self.keys['ts_key']][events_final[i][0]],self.data['extend'][self.keys['ts_key']][events_final[i][1]])
            self.breakthrough_events['events'][i]['force'] = (self.data['extend'][self.keys['y_key']][events_final[i][0]],self.data['extend'][self.keys['y_key']][events_final[i][1]])
            self.breakthrough_events['events'][i]['magnitude'] = self.data['extend'][self.keys['y_key']][events_final[i][0]] - self.data['extend'][self.keys['y_key']][events_final[i][1]]
            self.breakthrough_events['events'][i]






    def fit_hertz_model(self, #fit_type = 'constrained',
                        mode = 'free_contact_point', #maybe use the method type parameter
                        residuals_baseline_weight = 0,
                        y_offset = 'zero',
                        distance_to_contact = 50, poisson_ratio = 0.5,
                        indenter_characteristics = {'geometry': 'parabolic', 'radius [nm]': 10},
                        max_indentation = np.inf, force_limit = np.inf, #threshold_sensitivity = 0,
                        min_fit_length = 20):


        self.hertz_fit['method'] = dict()
        #self.hertz_fit['method']['type'] = mode
        self.hertz_fit['method']['parameter'] = dict()
        self.hertz_fit['method']['parameter']['force_limit'] = force_limit
        self.hertz_fit['method']['parameter']['max_indentation'] = max_indentation
        self.hertz_fit['method']['parameter']['distance_to_contact'] = distance_to_contact
        self.hertz_fit['method']['parameter']['min_fit_length'] = min_fit_length
        #self.hertz_fit['method']['parameter']['threshold_sensitivity'] = threshold_sensitivity
        self.hertz_fit['method']['parameter']['residuals_baseline_weight'] = residuals_baseline_weight

        self.hertz_fit['filter'] = dict()
        self.hertz_fit['filter']['type'] = 'none'



        x_data = self.data['extend'][self.keys['ts_key']] / (1e-09 / self.units['distance']['factor'])
        y_data = self.data['extend'][self.keys['y_key']] / (1e-09 / self.units['force']['factor'])

        #min_force_threshold = threshold_sensitivity * np.std(self.data['extend'][self.keys['y_key']][0:int(self.settings['samples']['extend']*0.2)])

        if indenter_characteristics['geometry'] == 'parabolic':

            hertz_func_fit = parabolic_hertz_fit_new
            hertz_func = parabolic_hertz_new
            indenter_param = indenter_characteristics['radius [nm]']
            conv_list_paran = False
            e_modul_func = e_modul_parabolic

        elif indenter_characteristics['geometry'] == 'conical':

            hertz_func_fit = conical_hertz_fit_new
            hertz_func = conical_hertz_new
            indenter_param = indenter_characteristics['angle [grad]']
            conv_list_paran = False
            e_modul_func = e_modul_conical

        elif indenter_characteristics['geometry'] == 'cylindrical':

            hertz_func_fit = cylindrical_hertz_fit_new
            hertz_func = cylindrical_hertz_new
            indenter_param = indenter_characteristics['radius [nm]']
            conv_list_paran = False
            e_modul_func = e_modul_cylindrical

        elif indenter_characteristics['geometry'] == 'four-sided pyramid':

            hertz_func_fit = four_side_pyramid_hertz_fit_new
            hertz_func = four_side_pyramid_hertz_new
            indenter_param = indenter_characteristics['angle [grad]']
            conv_list_paran = False
            e_modul_func = e_modul_four_sided_pyramid

        elif indenter_characteristics['geometry'] == 'spherical':

            hertz_func_fit = spherical_hertz_fit_new
            hertz_func = spherical_hertz_new
            indenter_param = indenter_characteristics['radius [nm]']
            conv_list_paran = Conversion_List_Spherical_Indenter_Hertz(indenter_characteristics['radius [nm]'],1, int(max(x_data)-min(x_data))+10)
            e_modul_func = e_modul_spherical


        if mode not in ['free_contact_point','fixed_contact_point','constrained_contact_point']:

            mode = 'free_contact_point'


        if mode == 'free_contact_point':

            self.hertz_fit['method']['parameter']['mode'] = 'free_contact_point'
            self.hertz_fit['method']['parameter']['y_offset'] = y_offset

            start_index = np.argmax(self.data['extend'][self.keys['ts_key']]<0) - distance_to_contact - 3

            res_i = np.ones(self.settings['samples']['extend'] - start_index - min_fit_length)
            fits = {'popt': list(), 'pcov': list(), 'residuals':list()}

            for i in range(self.settings['samples']['extend'] - start_index - min_fit_length):

                i_shifted = i + start_index

                contact_point_x = -x_data[i_shifted]

                if y_offset == 'zero':

                    contact_point_y_offset = 0

                elif y_offset == 'mean_contact_point':

                    contact_point_y_offset = np.mean(y_data[i_shifted-2:i_shifted+3])

                else:

                    contact_point_y_offset = y_data[i_shifted]



                end_fit_ind_max_ind = np.argmax(-x_data>contact_point_x + max_indentation)
                end_fit_ind_max_force = np.argmax(y_data>force_limit + contact_point_y_offset)


                if end_fit_ind_max_ind and end_fit_ind_max_force:

                    end_index = min(end_fit_ind_max_ind,end_fit_ind_max_force)

                elif end_fit_ind_max_ind or end_fit_ind_max_force:

                    end_index = max(end_fit_ind_max_ind,end_fit_ind_max_force)

                else:

                    end_index = self.settings['samples']['extend'] - 1

                start_index_fit = i_shifted - distance_to_contact

                #if np.mean(y_data[end_index-3:end_index+2]) - contact_point_y_offset > min_force_threshold:

                popt, pcov = curve_fit(hertz_func_fit(contact_point_x, contact_point_y_offset, indenter_param, conv_list_paran), -x_data[start_index_fit:end_index], y_data[start_index_fit:end_index])
                residuals = hertz_func(-x_data[start_index_fit:end_index], *popt, contact_point_x, contact_point_y_offset, indenter_param, conv_list_paran) - y_data[start_index_fit:end_index]

                res_baseline = np.sum(np.absolute(residuals[0:distance_to_contact])) / len(residuals[0:distance_to_contact])
                res_hertz = np.sum(np.absolute(residuals[distance_to_contact:])) / len(residuals[distance_to_contact:])
                res_i[i] = res_hertz + res_baseline * residuals_baseline_weight

                fits['popt'].append(popt)
                fits['pcov'].append(pcov)
                fits['residuals'].append(residuals)

                #else:

                #    res_i[i] = np.inf
                #    fits['popt'].append(0)
                #    fits['pcov'].append(0)
                #    fits['residuals'].append(np.inf)

            res_i[np.isnan(res_i)] = np.inf

            min_index = np.argmin(res_i)
            contact_point = x_data[min_index + start_index]
            residuals = fits['residuals'][min_index]

            e_modul = e_modul_func(fits['popt'][min_index][0],poisson_ratio,indenter_param)

            best_fit_result = fits['popt'][min_index]

            #print(best_fit_result)

        elif mode == 'constrained_contact_point':

            print('not implemented yet')

        elif mode == 'fixed_contact_point':

            self.hertz_fit['method']['parameter']['mode'] = 'fixed_contact_point'
            self.hertz_fit['method']['parameter']['y_offset'] = 'zero'

            start_index = np.argmax(self.data['extend'][self.keys['ts_key']]<0) - 1

            res_i = np.ones(1)
            fits = {'popt': list(), 'pcov': list(), 'residuals':list()}

            contact_point_x = -x_data[start_index]
            contact_point_y_offset = 0


            end_fit_ind_max_ind = np.argmax(-x_data>contact_point_x + max_indentation)
            end_fit_ind_max_force = np.argmax(y_data>force_limit + contact_point_y_offset)


            if end_fit_ind_max_ind and end_fit_ind_max_force:

                end_index = min(end_fit_ind_max_ind,end_fit_ind_max_force)

            elif end_fit_ind_max_ind or end_fit_ind_max_force:

                end_index = max(end_fit_ind_max_ind,end_fit_ind_max_force)

            else:

                end_index = self.settings['samples']['extend'] - 1

            start_index_fit = start_index

            #if np.mean(y_data[end_index-3:end_index+2]) - contact_point_y_offset > min_force_threshold:

            popt, pcov = curve_fit(hertz_func_fit(contact_point_x, contact_point_y_offset, indenter_param, conv_list_paran), -x_data[start_index_fit:end_index], y_data[start_index_fit:end_index])
            residuals = hertz_func(-x_data[start_index_fit:end_index], *popt, contact_point_x, contact_point_y_offset, indenter_param, conv_list_paran) - y_data[start_index_fit:end_index]

            res_baseline = np.sum(np.absolute(residuals[0:distance_to_contact])) / len(residuals[0:distance_to_contact])
            res_hertz = np.sum(np.absolute(residuals[distance_to_contact:])) / len(residuals[distance_to_contact:])
            res_i[0] = res_hertz + res_baseline * residuals_baseline_weight

            fits['popt'].append(popt)
            fits['pcov'].append(pcov)
            fits['residuals'].append(residuals)

                #else:

                #    res_i[i] = np.inf
                #    fits['popt'].append(0)
                #    fits['pcov'].append(0)
                #    fits['residuals'].append(np.inf)


            min_index = np.argmin(res_i)
            contact_point = x_data[start_index]
            residuals = fits['residuals'][min_index]

            e_modul = e_modul_func(fits['popt'][min_index][0],poisson_ratio,indenter_param)

            best_fit_result = fits['popt'][min_index]




        self.hertz_fit['best_fit'] = dict()
        self.hertz_fit['best_fit']['index'] = (start_index + min_index,end_index)
        self.hertz_fit['best_fit']['interval'] = (self.data['extend'][self.keys['ts_key']][start_index + min_index],self.data['extend'][self.keys['ts_key']][end_index])
        self.hertz_fit['best_fit']['fit_parameter'] = fits['popt'][min_index][0]
        self.hertz_fit['best_fit']['contact_point'] = dict()
        self.hertz_fit['best_fit']['contact_point']['index'] = start_index + min_index
        self.hertz_fit['best_fit']['contact_point']['value'] = contact_point

        self.hertz_fit['residuals'] = dict()
        self.hertz_fit['residuals']['unit'] = 'nN'
        self.hertz_fit['residuals']['mean_fit'] = res_i[min_index]
        self.hertz_fit['residuals']['mean'] = np.mean(np.absolute(residuals[distance_to_contact:]))
        self.hertz_fit['residuals']['data'] = list()

        self.hertz_fit['poisson_ratio'] = poisson_ratio
        self.hertz_fit['units'] = copy.deepcopy(self.units)

        e_modul = e_modul * 10**9
        e_modul_unit = 'Pa'
        e_modul_factor = 1

        self.hertz_fit['young_modulus'] = {'value': e_modul, 'unit': e_modul_unit, 'factor': e_modul_factor}




    def fit_linearized_hertz_model(self,
                        poisson_ratio = 0.5,
                        indenter_characteristics = {'geometry': 'parabolic', 'radius [nm]': 10},
                        transition_sensitivity = 1,
                        stop_at_transition = True,
                        filter_correction_fraction = 0.5,
                        **kwargs):

        layer1_parameters = {'start_fit_length': 'automatic',
                             'savgol_filter_characteristics': {'length': 51, 'order': 1, 'deriv': 0, 'delta': 1.0, 'axis': -1, 'mode': 'interp', 'cval': 0.0},
                             'r_squared_limit':  0.98,
                             'residual_sensitivity': 1,
                             'final_fit_fraction': 0.8,
                             'with_residuals': True}


        if 'layer1_parameters' in kwargs:

            for key in kwargs['layer1_parameters'].keys():

                layer1_parameters[key] = kwargs['layer1_parameters'][key]


        residual_fac_layer1 = 5 - math.log10(layer1_parameters['residual_sensitivity'])
        transition_fac = 5 - math.log10(transition_sensitivity)


        self.linearized_hertz_fit = dict()
        self.linearized_hertz_fit['indenter'] = indenter_characteristics

        self.linearized_hertz_fit['method'] = dict()
        self.linearized_hertz_fit['method']['type'] = 'linear'
        self.linearized_hertz_fit['method']['parameter'] = dict()
        self.linearized_hertz_fit['method']['parameter']['transition_sensitivity'] = transition_sensitivity
        self.linearized_hertz_fit['method']['parameter']['transition_factor'] = transition_fac
        self.linearized_hertz_fit['method']['parameter']['stop_at_transition'] = stop_at_transition

        self.linearized_hertz_fit['method']['parameter']['layer1'] = dict()
        self.linearized_hertz_fit['method']['parameter']['layer1']['r_squared_limit'] = layer1_parameters['r_squared_limit']
        self.linearized_hertz_fit['method']['parameter']['layer1']['with_residuals'] = layer1_parameters['with_residuals']
        self.linearized_hertz_fit['method']['parameter']['layer1']['residual_sensitivity'] = layer1_parameters['residual_sensitivity']
        self.linearized_hertz_fit['method']['parameter']['layer1']['residual_factor'] = residual_fac_layer1
        self.linearized_hertz_fit['method']['parameter']['layer1']['final_fit_fraction'] = layer1_parameters['final_fit_fraction']

        self.linearized_hertz_fit['filter'] = dict()
        self.linearized_hertz_fit['filter']['type'] = 'savitzky-golay'
        self.linearized_hertz_fit['filter']['parameter'] = dict()
        self.linearized_hertz_fit['filter']['parameter']['length'] = layer1_parameters['savgol_filter_characteristics']['length']
        self.linearized_hertz_fit['filter']['parameter']['order'] = layer1_parameters['savgol_filter_characteristics']['order']

        self.linearized_hertz_fit['best_fit'] = dict()
        self.linearized_hertz_fit['residuals'] = dict()
        self.linearized_hertz_fit['young_modulus'] = dict()

        x_data = self.data['extend'][self.keys['ts_key']] / (1e-09 / self.units['distance']['factor'])
        y_data = self.data['extend'][self.keys['y_key']] / (1e-09 / self.units['force']['factor'])
        noise_lvl_adapted = self.noise_level['value'] / (1e-09 / self.units['force']['factor'])

        # 1. smooth data
        y_data_savgol_layer1 = savgol_filter(y_data,layer1_parameters['savgol_filter_characteristics']['length'],
                                             layer1_parameters['savgol_filter_characteristics']['order'],
                                             deriv = layer1_parameters['savgol_filter_characteristics']['deriv'],
                                             delta = layer1_parameters['savgol_filter_characteristics']['delta'],
                                             axis = layer1_parameters['savgol_filter_characteristics']['axis'],
                                             mode = layer1_parameters['savgol_filter_characteristics']['mode'],
                                             cval = layer1_parameters['savgol_filter_characteristics']['cval'])


        # 2. find "transition" point where smoothing does not work anymore
        diff_data = y_data - y_data_savgol_layer1
        diff_data_std = np.std(diff_data[0:int(self.settings['samples']['extend']*0.2)])



        transition_found = False
        i = 0

        while not transition_found and i < self.settings['samples']['extend'] - 1:

            if abs(diff_data[i]) > diff_data_std * transition_fac:

                transition_found = True

            else:

                i += 1


        index_transition = i - int(filter_correction_fraction*layer1_parameters['savgol_filter_characteristics']['length'])

        self.linearized_hertz_fit['method']['parameter']['layer_transition'] = dict()
        self.linearized_hertz_fit['method']['parameter']['layer_transition']['detected'] = transition_found

        if transition_found:

            self.linearized_hertz_fit['method']['parameter']['layer_transition']['index'] = index_transition

        # 3. find transition between two regimes
        # if transition is found than only look up to that point for first regime
        if stop_at_transition:

            if transition_found:

                index_end_layer1 = index_transition

            else:

                index_end_layer1 = self.settings['samples']['extend']

        else:

            index_end_layer1 = self.settings['samples']['extend']


        if layer1_parameters['start_fit_length'] == 'automatic':

            fit_length_initial_layer1 = max(int(self.settings['samples']['extend'] * 0.1),2 * (layer1_parameters['savgol_filter_characteristics']['length'] - 1))


        elif type(layer1_parameters['start_fit_length']) is int and layer1_parameters['start_fit_length'] > 0:

            fit_length_initial_layer1 = layer1_parameters['start_fit_length']

        else:

            fit_length_initial_layer1 = max(int(self.settings['samples']['extend'] * 0.1),2 * (layer1_parameters['savgol_filter_characteristics']['length'] - 1))


        self.linearized_hertz_fit['method']['parameter']['layer1']['start_fit_length'] = fit_length_initial_layer1

        # 4. scale data and find soft layer - layer 1
        line_found_layer1 = False
        loop_run = True

        if indenter_characteristics['geometry'] == 'parabolic':

            y_data_scaled_layer1 = np.power(y_data_savgol_layer1,2/3)
            start_index_layer1 = np.amax(np.where(np.isnan(y_data_scaled_layer1))) + 1

        elif indenter_characteristics['geometry'] == 'conical' or indenter_characteristics['geometry'] == 'four-sided pyramid':
            # scale data
            y_data_scaled_layer1 = np.sqrt(y_data_savgol_layer1)
            # find the correct starting index
            start_index_layer1 = np.amax(np.where(np.isnan(y_data_scaled_layer1))) + 1

        fit_start_layer1 = start_index_layer1 + 1
        fit_end_layer1 = fit_start_layer1 + fit_length_initial_layer1

        if fit_end_layer1 > index_end_layer1 or start_index_layer1 > index_end_layer1:

            loop_run = False

        else:
            # fit and determine quality of fit
            fit_layer1 = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

            total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
            residuals = x_data[fit_start_layer1:fit_end_layer1] *fit_layer1[0] + fit_layer1[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
            squared_sum_residuals = np.sum(residuals**2)
            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


            if not layer1_parameters['with_residuals']:

                if r_squared > layer1_parameters['r_squared_limit']:

                    straight_line = True
                    line_found_layer1 = True

                else:

                    straight_line = False


                while fit_end_layer1 < index_end_layer1 and loop_run:

                    if straight_line:

                        fit_end_layer1 += 1

                        fit_layer1 = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                        total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                        residuals = x_data[fit_start_layer1:fit_end_layer1] *fit_layer1[0] + fit_layer1[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                        squared_sum_residuals = np.sum(residuals**2)
                        r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                        if r_squared > layer1_parameters['r_squared_limit']:

                            straight_line = True

                        else:

                            straight_line = False
                            loop_run = False


                    else:

                        fit_start_layer1 = fit_start_layer1 + 1
                        fit_end_layer1 = fit_start_layer1 + fit_length_initial_layer1

                        fit_layer1 = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                        total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                        residuals = x_data[fit_start_layer1:fit_end_layer1] *fit_layer1[0] + fit_layer1[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                        squared_sum_residuals = np.sum(residuals**2)
                        r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)

                        if r_squared > layer1_parameters['r_squared_limit']:

                            straight_line = True
                            line_found_layer1 = True


            else:

                if r_squared > layer1_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer1 * noise_lvl_adapted:

                    straight_line = True
                    line_found_layer1 = True

                else:

                    straight_line = False


                while fit_end_layer1 < index_end_layer1 and loop_run:

                    if straight_line:

                        fit_end_layer1 += 1

                        fit_layer1 = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                        total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                        residuals = x_data[fit_start_layer1:fit_end_layer1] *fit_layer1[0] + fit_layer1[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                        squared_sum_residuals = np.sum(residuals**2)
                        r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                        if r_squared > layer1_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer1 * noise_lvl_adapted:

                            straight_line = True

                        else:

                            straight_line = False
                            loop_run = False


                    else:

                        fit_start_layer1 = fit_start_layer1 + 1
                        fit_end_layer1 = fit_start_layer1 + fit_length_initial_layer1

                        fit_layer1 = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                        total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                        residuals = x_data[fit_start_layer1:fit_end_layer1] *fit_layer1[0] + fit_layer1[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                        squared_sum_residuals = np.sum(residuals**2)
                        r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                        if r_squared > layer1_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer1 * noise_lvl_adapted:

                            straight_line = True
                            line_found_layer1 = True


        if line_found_layer1:

            fit_length_final_layer1 = fit_end_layer1 - fit_start_layer1
            fit_start_mod_layer1 = fit_start_layer1 + int(0.5*(1 - layer1_parameters['final_fit_fraction'])  * fit_length_final_layer1)
            fit_end_mod_layer1 = fit_start_layer1 + int(0.5 *(1 + layer1_parameters['final_fit_fraction']) * fit_length_final_layer1)

            fit_trim_layer1 = np.polyfit(x_data[fit_start_mod_layer1:fit_end_mod_layer1], y_data_scaled_layer1[fit_start_mod_layer1:fit_end_mod_layer1],1)

            # calculate the residuals

            residuals_linear_layer1 = x_data[fit_start_mod_layer1:fit_end_mod_layer1] *fit_trim_layer1[0] + fit_trim_layer1[1] - y_data_scaled_layer1[fit_start_mod_layer1:fit_end_mod_layer1]

            self.linearized_hertz_fit['best_fit']['line_found'] = True
            self.linearized_hertz_fit['best_fit']['index'] = (fit_start_mod_layer1,fit_end_mod_layer1-1)
            self.linearized_hertz_fit['best_fit']['interval'] = (self.data['extend'][self.keys['ts_key']][fit_start_mod_layer1],self.data['extend'][self.keys['ts_key']][fit_end_mod_layer1-1])
            self.linearized_hertz_fit['best_fit']['fit_parameter'] = - fit_trim_layer1[0]
            self.linearized_hertz_fit['best_fit']['contact_point'] = dict()
            #contact point index as first point with value smaller than the calculated contact point
            self.linearized_hertz_fit['best_fit']['contact_point']['index'] = np.argmax(self.data['extend'][self.keys['ts_key']] < -fit_trim_layer1[1]/fit_trim_layer1[0])
            self.linearized_hertz_fit['best_fit']['contact_point']['value'] = -fit_trim_layer1[1]/fit_trim_layer1[0]

            self.linearized_hertz_fit['best_fit']['specifics'] = dict()
            self.linearized_hertz_fit['best_fit']['specifics']['start_index'] = start_index_layer1
            self.linearized_hertz_fit['best_fit']['specifics']['full_index'] = (fit_start_layer1,fit_end_layer1-1)

            self.linearized_hertz_fit['residuals']['unit'] = 'nN'

            self.linearized_hertz_fit['residuals']['mean_linear_fit'] = np.mean(np.absolute(residuals_linear_layer1))
            self.linearized_hertz_fit['residuals']['data_linear_fit'] = residuals_linear_layer1


            if indenter_characteristics['geometry'] == 'parabolic':

                e_modul_layer1 = np.power(abs(fit_trim_layer1[0]),3/2) * (1 - poisson_ratio**2) * 3 / (4 * math.sqrt(indenter_characteristics['radius [nm]']))

                x_fit = copy.deepcopy(x_data)
                ind = -(x_fit - self.linearized_hertz_fit['best_fit']['contact_point']['value'])
                ind[ind<0] = 0
                y_fit_layer1 = np.power(abs(fit_trim_layer1[0]),3/2) * np.power(ind,3/2)

                residuals_layer1 = y_fit_layer1[fit_start_mod_layer1:fit_end_mod_layer1] - y_data[fit_start_mod_layer1:fit_end_mod_layer1]

                self.linearized_hertz_fit['residuals']['mean'] = np.mean(np.absolute(residuals_layer1))
                self.linearized_hertz_fit['residuals']['data'] = residuals_layer1



            elif indenter_characteristics['geometry'] == 'conical':

                e_modul_layer1 = fit_trim_layer1[0]**2 * (1 - poisson_ratio**2) * np.pi / (2 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                x_fit = copy.deepcopy(x_data)
                ind = -(x_fit - self.linearized_hertz_fit['best_fit']['contact_point']['value'])
                ind[ind<0] = 0
                y_fit_layer1 = fit_trim_layer1[0]**2 * ind**2

                residuals_layer1 = y_fit_layer1[fit_start_mod_layer1:fit_end_mod_layer1] - y_data[fit_start_mod_layer1:fit_end_mod_layer1]

                self.linearized_hertz_fit['residuals']['mean'] = np.mean(np.absolute(residuals_layer1))
                self.linearized_hertz_fit['residuals']['data'] = residuals_layer1


            elif indenter_characteristics['geometry'] == 'four-sided pyramid':

                e_modul_layer1 = fit_trim_layer1[0]**2 * (1 - poisson_ratio**2) / (0.7453 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                x_fit = copy.deepcopy(x_data)
                ind = -(x_fit - self.linearized_hertz_fit['best_fit']['contact_point']['value'])
                ind[ind<0] = 0
                y_fit_layer1 = fit_trim_layer1[0]**2 * ind**2

                residuals_layer1 = y_fit_layer1[fit_start_mod_layer1:fit_end_mod_layer1] - y_data[fit_start_mod_layer1:fit_end_mod_layer1]

                self.linearized_hertz_fit['residuals']['mean'] = np.mean(np.absolute(residuals_layer1))
                self.linearized_hertz_fit['residuals']['data'] = residuals_layer1

        else:

            self.linearized_hertz_fit['best_fit']['line_found'] = False
            self.linearized_hertz_fit['residuals'] = dict()

            e_modul_layer1 = np.nan


        self.linearized_hertz_fit['poisson_ratio'] = poisson_ratio
        self.linearized_hertz_fit['units'] = copy.deepcopy(self.units)

        e_modul_layer1 = e_modul_layer1 * 10**9
        e_modul_unit = 'Pa'
        e_modul_factor = 1

        self.linearized_hertz_fit['young_modulus'] = {'value': e_modul_layer1, 'unit': e_modul_unit, 'factor': e_modul_factor}




    def fit_two_layer_linearized_hertz_model(self,
                        poisson_ratio = 0.5,
                        indenter_characteristics = {'geometry': 'parabolic', 'radius [nm]': 10},
                        transition_sensitivity = 1,
                        filter_correction_fraction = 0.5,
                        layer1_parameters = {'start_fit_length': 'automatic',
                             'savgol_filter_characteristics': {'length': 51, 'order': 1, 'deriv': 0, 'delta': 1.0, 'axis': -1, 'mode': 'interp', 'cval': 0.0},
                             'r_squared_limit':  0.98,
                             'residual_sensitivity': 1,
                             'final_fit_fraction': 0.8,
                             'with_residuals': True},
                        layer2_parameters = {'start_fit_length': 'automatic',
                             #'savgol_filter_characteristics': {'length': 51, 'order': 1},
                             'r_squared_limit':  0.98,
                             'residual_sensitivity': 1,
                             'final_fit_fraction': 0.9,
                             'with_residuals': True}):


#        layer1_parameters = {'start_fit_length': 'automatic',
#                             'savgol_filter_characteristics': {'length': 51, 'order': 1},
#                             'r_squared_limit':  0.98,
#                             'residual_sensitivity': 1,
#                             'final_fit_fraction': 0.8,
#                             'with_residuals': True},
#
#        layer2_parameters = {'start_fit_length': 'automatic',
#                             #'savgol_filter_characteristics': {'length': 51, 'order': 1},
#                             'r_squared_limit':  0.98,
#                             'residual_sensitivity': 1,
#                             'final_fit_fraction': 0.9,
#                             'with_residuals': True,
#                             'fit_limit': 0.8}
#
#
#        if 'layer1_parameters' in kwargs:
#
#            for key in kwargs['layer1_parameters'].keys():
#
#                layer1_parameters[key] = kwargs['layer1_parameters'][key]
#
#
#        if 'layer2_parameters' in kwargs:
#
#            for key in kwargs['layer2_parameters'].keys():
#
#                layer2_parameters[key] = kwargs['layer2_parameters'][key]


        residual_fac_layer1 = 5 - math.log10(layer1_parameters['residual_sensitivity'])
        residual_fac_layer2 = 5 - math.log10(layer2_parameters['residual_sensitivity'])
        transition_fac = 5 - math.log10(transition_sensitivity)

        self.two_layer_hertz = dict()
        self.two_layer_hertz['indenter'] = indenter_characteristics

        self.two_layer_hertz['method'] = dict()
        self.two_layer_hertz['method']['type'] = 'linear'
        self.two_layer_hertz['method']['parameter'] = dict()
        self.two_layer_hertz['method']['parameter']['transition_sensitivity'] = transition_sensitivity
        self.two_layer_hertz['method']['parameter']['transition_factor'] = transition_fac

        self.two_layer_hertz['method']['parameter']['layer1'] = dict()
        self.two_layer_hertz['method']['parameter']['layer1']['r_squared_limit'] = layer1_parameters['r_squared_limit']
        self.two_layer_hertz['method']['parameter']['layer1']['with_residuals'] = layer1_parameters['with_residuals']
        self.two_layer_hertz['method']['parameter']['layer1']['residual_sensitivity'] = layer1_parameters['residual_sensitivity']
        self.two_layer_hertz['method']['parameter']['layer1']['residual_factor'] = residual_fac_layer1
        self.two_layer_hertz['method']['parameter']['layer1']['final_fit_fraction'] = layer1_parameters['final_fit_fraction']

        self.two_layer_hertz['method']['parameter']['layer2'] = dict()
        self.two_layer_hertz['method']['parameter']['layer2']['r_squared_limit'] = layer2_parameters['r_squared_limit']
        self.two_layer_hertz['method']['parameter']['layer2']['with_residuals'] = layer2_parameters['with_residuals']
        self.two_layer_hertz['method']['parameter']['layer2']['residual_sensitivity'] = layer2_parameters['residual_sensitivity']
        self.two_layer_hertz['method']['parameter']['layer2']['residual_factor'] = residual_fac_layer2
        self.two_layer_hertz['method']['parameter']['layer2']['final_fit_fraction'] = layer2_parameters['final_fit_fraction']


        self.two_layer_hertz['filter'] = dict()
        self.two_layer_hertz['filter']['layer1'] = dict()
        self.two_layer_hertz['filter']['layer1']['type'] = 'savitzky-golay'
        self.two_layer_hertz['filter']['layer1']['parameter'] = dict()
        self.two_layer_hertz['filter']['layer1']['parameter']['length'] = layer1_parameters['savgol_filter_characteristics']['length']
        self.two_layer_hertz['filter']['layer1']['parameter']['order'] = layer1_parameters['savgol_filter_characteristics']['order']

        self.two_layer_hertz['best_fit'] = dict()
        self.two_layer_hertz['best_fit']['layer1'] = dict()
        self.two_layer_hertz['best_fit']['layer2'] = dict()

        self.two_layer_hertz['residuals'] = dict()
        self.two_layer_hertz['residuals']['layer1'] = dict()
        self.two_layer_hertz['residuals']['layer2'] = dict()

        self.two_layer_hertz['young_modulus'] = dict()


        x_data = self.data['extend'][self.keys['ts_key']] / (1e-09 / self.units['distance']['factor'])
        y_data = self.data['extend'][self.keys['y_key']] / (1e-09 / self.units['force']['factor'])
        noise_lvl_adapted = self.noise_level['value'] / (1e-09 / self.units['force']['factor'])

        # 1. smooth data
        y_data_savgol_layer1 = savgol_filter(y_data,layer1_parameters['savgol_filter_characteristics']['length'],
                                             layer1_parameters['savgol_filter_characteristics']['order'],
                                             deriv = layer1_parameters['savgol_filter_characteristics']['deriv'],
                                             delta = layer1_parameters['savgol_filter_characteristics']['delta'],
                                             axis = layer1_parameters['savgol_filter_characteristics']['axis'],
                                             mode = layer1_parameters['savgol_filter_characteristics']['mode'],
                                             cval = layer1_parameters['savgol_filter_characteristics']['cval'])

        # 2. find "transition" point where smoothing does not work anymore
        diff_data = y_data - y_data_savgol_layer1
        diff_data_std = np.std(diff_data[0:int(self.settings['samples']['extend']*0.2)])

        transition_found = False
        i = 0

        while not transition_found and i < self.settings['samples']['extend'] - 1:

            if abs(diff_data[i]) > diff_data_std * transition_fac:

                transition_found = True

            else:

                i += 1


        index_transition = i - int(0.5*layer1_parameters['savgol_filter_characteristics']['length'])

        self.two_layer_hertz['method']['parameter']['layer_transition'] = dict()
        self.two_layer_hertz['method']['parameter']['layer_transition']['detected'] = transition_found

        if transition_found:

            self.two_layer_hertz['method']['parameter']['layer_transition']['index'] = index_transition


        # 3. find transition between two regimes
        # if transition is found than only look up to that point for first regime

        if transition_found:

            index_end_layer1 = index_transition

        else:

            index_end_layer1 = self.settings['samples']['extend']


        if layer1_parameters['start_fit_length'] == 'automatic':

            #fit_length_initial_layer1 = 2 * (layer1_parameters['savgol_filter_characteristics']['length'] - 1)
            fit_length_initial_layer1 = max(int(self.settings['samples']['extend'] * 0.1),2 * (layer1_parameters['savgol_filter_characteristics']['length'] - 1))

        elif type(layer1_parameters['start_fit_length']) is int and layer1_parameters['start_fit_length'] > 0:

            fit_length_initial_layer1 = layer1_parameters['start_fit_length']

        else:

            fit_length_initial_layer1 = max(int(self.settings['samples']['extend'] * 0.1),2 * (layer1_parameters['savgol_filter_characteristics']['length'] - 1))



        if layer2_parameters['start_fit_length'] == 'automatic':

            fit_length_initial_layer2 = max(10,int(self.settings['samples']['extend'] * 0.02))

        elif type(layer2_parameters['start_fit_length']) is int and layer2_parameters['start_fit_length'] > 0:

            fit_length_initial_layer2 = layer2_parameters['start_fit_length']

        else:

            fit_length_initial_layer2 = max(10,int(self.settings['samples']['extend'] * 0.02))


        self.two_layer_hertz['method']['parameter']['layer1']['start_fit_length'] = fit_length_initial_layer1
        self.two_layer_hertz['method']['parameter']['layer2']['start_fit_length'] = fit_length_initial_layer2


        # 4. scale data and find soft layer - layer 1
        line_found_layer1 = False
        loop_run = True

        if indenter_characteristics['geometry'] == 'parabolic':

            y_data_scaled_layer1 = np.power(y_data_savgol_layer1,2/3)
            start_index_layer1 = np.amax(np.where(np.isnan(y_data_scaled_layer1))) + 1

        elif indenter_characteristics['geometry'] == 'conical' or indenter_characteristics['geometry'] == 'four-sided pyramid':

            # scale data
            y_data_scaled_layer1 = np.sqrt(y_data_savgol_layer1)
            # find the correct starting index
            start_index_layer1 = np.amax(np.where(np.isnan(y_data_scaled_layer1))) + 1


        fit_start_layer1 = start_index_layer1 + 1
        fit_end_layer1 = fit_start_layer1 + fit_length_initial_layer1

        if fit_end_layer1 > index_end_layer1 or start_index_layer1 > index_end_layer1:

            loop_run = False

        else:

            # fit and determine quality of fit
            fit = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

            total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
            residuals = x_data[fit_start_layer1:fit_end_layer1] *fit[0] + fit[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
            squared_sum_residuals = np.sum(residuals**2)
            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


            if not layer1_parameters['with_residuals']:

                if r_squared > layer1_parameters['r_squared_limit']:

                    straight_line = True
                    line_found_layer1 = True

                else:

                    straight_line = False


                while fit_end_layer1 < index_end_layer1 and loop_run:

                    if straight_line:

                        fit_end_layer1 += 1

                        fit = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                        total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                        residuals = x_data[fit_start_layer1:fit_end_layer1] *fit[0] + fit[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                        squared_sum_residuals = np.sum(residuals**2)
                        r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)

                        if r_squared > layer1_parameters['r_squared_limit']:

                            straight_line = True

                        else:

                            straight_line = False
                            loop_run = False


                    else:

                        fit_start_layer1 = fit_start_layer1 + 1
                        fit_end_layer1 = fit_start_layer1 + fit_length_initial_layer1

                        fit = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                        total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                        residuals = x_data[fit_start_layer1:fit_end_layer1] *fit[0] + fit[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                        squared_sum_residuals = np.sum(residuals**2)
                        r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                        if r_squared > layer1_parameters['r_squared_limit']:

                            straight_line = True
                            line_found_layer1 = True


            else:

                if r_squared > layer1_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer1 * noise_lvl_adapted:

                    straight_line = True
                    line_found_layer1 = True

                else:

                    straight_line = False


                while fit_end_layer1 < index_end_layer1 and loop_run:

                    if straight_line:

                        fit_end_layer1 += 1

                        fit = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                        total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                        residuals = x_data[fit_start_layer1:fit_end_layer1] *fit[0] + fit[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                        squared_sum_residuals = np.sum(residuals**2)
                        r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)

                        if r_squared > layer1_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer1 * noise_lvl_adapted:

                            straight_line = True

                        else:

                            straight_line = False
                            loop_run = False


                    else:

                        fit_start_layer1 = fit_start_layer1 + 1
                        fit_end_layer1 = fit_start_layer1 + fit_length_initial_layer1

                        fit = np.polyfit(x_data[fit_start_layer1:fit_end_layer1], y_data_scaled_layer1[fit_start_layer1:fit_end_layer1],1)

                        total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer1:fit_end_layer1] - np.mean(y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]))**2 )
                        residuals = x_data[fit_start_layer1:fit_end_layer1] *fit[0] + fit[1] - y_data_scaled_layer1[fit_start_layer1:fit_end_layer1]
                        squared_sum_residuals = np.sum(residuals**2)
                        r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                        if r_squared > layer1_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer1 * noise_lvl_adapted:

                            straight_line = True
                            line_found_layer1 = True


        # 5. scale data and find stiff layer - layer 2
        line_found_layer2 = False

        if transition_found:

            index_end_layer2 = index_transition


            loop_run = True

            if indenter_characteristics['geometry'] == 'parabolic':

                y_data_scaled_layer2 = np.power(copy.deepcopy(y_data),2/3)
                index_end_layer2 = max(index_end_layer2, np.amax(np.where(np.isnan(y_data_scaled_layer2))) + 1) # make sure that no nan numbers are hit


            elif indenter_characteristics['geometry'] == 'conical' or indenter_characteristics['geometry'] == 'four-sided pyramid':

                # scale data
                y_data_scaled_layer2 = np.sqrt(copy.deepcopy(y_data))
                index_end_layer2 = max(index_end_layer2, np.amax(np.where(np.isnan(y_data_scaled_layer2))) + 1) # make sure that no nan numbers are hit


            start_index_layer2 = self.settings['samples']['extend'] - 1
            fit_end_layer2 = start_index_layer2+1 #reversed as search moves in opposite direction
            fit_start_layer2 = fit_end_layer2 - fit_length_initial_layer2

            fit = np.polyfit(x_data[fit_start_layer2:fit_end_layer2], y_data_scaled_layer2[fit_start_layer2:fit_end_layer2],1)

            total_sum_of_squares = np.sum((y_data_scaled_layer2[fit_start_layer2:fit_end_layer2] - np.mean(y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]))**2 )
            residuals = x_data[fit_start_layer2:fit_end_layer2] *fit[0] + fit[1] - y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]
            squared_sum_residuals = np.sum(residuals**2)
            r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


            if not layer2_parameters['with_residuals']:

                if r_squared > layer2_parameters['r_squared_limit']:

                    straight_line = True
                    line_found_layer2 = True

                else:

                    straight_line = False


                while fit_start_layer2 > index_end_layer2 and loop_run:

                    if straight_line:

                        fit_start_layer2 -= 1

                        fit = np.polyfit(x_data[fit_start_layer2:fit_end_layer2], y_data_scaled_layer2[fit_start_layer2:fit_end_layer2],1)

                        total_sum_of_squares = np.sum((y_data_scaled_layer2[fit_start_layer2:fit_end_layer2] - np.mean(y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]))**2 )
                        residuals = x_data[fit_start_layer2:fit_end_layer2] *fit[0] + fit[1] - y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]
                        squared_sum_residuals = np.sum(residuals**2)
                        r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)

                        if r_squared > layer2_parameters['r_squared_limit']:

                            straight_line = True

                        else:

                            straight_line = False
                            loop_run = False

                    else:

                        fit_end_layer2 = fit_end_layer2 - 1
                        fit_start_layer2 = fit_end_layer2 - fit_length_initial_layer2

                        fit = np.polyfit(x_data[fit_start_layer2:fit_end_layer2], y_data_scaled_layer2[fit_start_layer2:fit_end_layer2],1)

                        total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer2:fit_end_layer2] - np.mean(y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]))**2 )
                        residuals = x_data[fit_start_layer2:fit_end_layer2] *fit[0] + fit[1] - y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]
                        squared_sum_residuals = np.sum(residuals**2)
                        r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                        if r_squared > layer2_parameters['r_squared_limit']:

                            straight_line = True
                            line_found_layer2 = True


            else:

                if r_squared > layer2_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer2 * noise_lvl_adapted:

                    straight_line = True
                    line_found_layer2 = True

                else:

                    straight_line = False


                while fit_start_layer2 > index_end_layer2 and loop_run:

                    if straight_line:

                        fit_start_layer2 -= 1

                        fit = np.polyfit(x_data[fit_start_layer2:fit_end_layer2], y_data_scaled_layer2[fit_start_layer2:fit_end_layer2],1)

                        total_sum_of_squares = np.sum((y_data_scaled_layer2[fit_start_layer2:fit_end_layer2] - np.mean(y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]))**2 )
                        residuals = x_data[fit_start_layer2:fit_end_layer2] *fit[0] + fit[1] - y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]
                        squared_sum_residuals = np.sum(residuals**2)
                        r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)

                        if r_squared > layer2_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer2 * noise_lvl_adapted:

                            straight_line = True

                        else:

                            straight_line = False
                            loop_run = False

                    else:

                        fit_end_layer2 = fit_end_layer2 - 1
                        fit_start_layer2 = fit_end_layer2 - fit_length_initial_layer2

                        fit = np.polyfit(x_data[fit_start_layer2:fit_end_layer2], y_data_scaled_layer2[fit_start_layer2:fit_end_layer2],1)

                        total_sum_of_squares = np.sum((y_data_scaled_layer1[fit_start_layer2:fit_end_layer2] - np.mean(y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]))**2 )
                        residuals = x_data[fit_start_layer2:fit_end_layer2] *fit[0] + fit[1] - y_data_scaled_layer2[fit_start_layer2:fit_end_layer2]
                        squared_sum_residuals = np.sum(residuals**2)
                        r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                        if r_squared > layer2_parameters['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac_layer2 * noise_lvl_adapted:

                            straight_line = True
                            line_found_layer2 = True

        else:

            index_end_layer2 = self.settings['samples']['extend']


        if line_found_layer1:

            fit_length_final_layer1 = fit_end_layer1 - fit_start_layer1
            fit_start_mod_layer1 = fit_start_layer1 + int(0.5*(1 - layer1_parameters['final_fit_fraction'])  * fit_length_final_layer1)
            fit_end_mod_layer1 = fit_start_layer1 + int(0.5 *(1 + layer1_parameters['final_fit_fraction']) * fit_length_final_layer1)

            fit_trim_layer1 = np.polyfit(x_data[fit_start_mod_layer1:fit_end_mod_layer1], y_data_scaled_layer1[fit_start_mod_layer1:fit_end_mod_layer1],1)

            # calculate the residuals

            residuals_linear_layer1 = x_data[fit_start_mod_layer1:fit_end_mod_layer1] *fit_trim_layer1[0] + fit_trim_layer1[1] - y_data_scaled_layer1[fit_start_mod_layer1:fit_end_mod_layer1]

            self.two_layer_hertz['best_fit']['layer1']['line_found'] = True
            self.two_layer_hertz['best_fit']['layer1']['index'] = (fit_start_mod_layer1,fit_end_mod_layer1-1)
            self.two_layer_hertz['best_fit']['layer1']['interval'] = (self.data['extend'][self.keys['ts_key']][fit_start_mod_layer1],self.data['extend'][self.keys['ts_key']][fit_end_mod_layer1-1])
            self.two_layer_hertz['best_fit']['layer1']['fit_parameter'] = - fit_trim_layer1[0]
            self.two_layer_hertz['best_fit']['layer1']['contact_point'] = dict()
            #contact point index as first point with value smaller than the calculated contact point
            self.two_layer_hertz['best_fit']['layer1']['contact_point']['index'] = np.argmax(self.data['extend'][self.keys['ts_key']] < -fit_trim_layer1[1]/fit_trim_layer1[0])
            self.two_layer_hertz['best_fit']['layer1']['contact_point']['value'] = -fit_trim_layer1[1]/fit_trim_layer1[0]

            self.two_layer_hertz['best_fit']['layer1']['specifics'] = dict()
            self.two_layer_hertz['best_fit']['layer1']['specifics']['start_index'] = start_index_layer1
            self.two_layer_hertz['best_fit']['layer1']['specifics']['full_index'] = (fit_start_layer1,fit_end_layer1-1)

            self.two_layer_hertz['residuals']['layer1']['unit'] = 'nN'

            self.two_layer_hertz['residuals']['layer1']['mean_linear_fit'] = np.mean(np.absolute(residuals_linear_layer1))
            self.two_layer_hertz['residuals']['layer1']['data_linear_fit'] = residuals_linear_layer1


            if indenter_characteristics['geometry'] == 'parabolic':

                e_modul_layer1 = np.power(abs(fit_trim_layer1[0]),3/2) * (1 - poisson_ratio**2) * 3 / (4 * math.sqrt(indenter_characteristics['radius [nm]']))

                x_fit = copy.deepcopy(x_data)
                ind = -(x_fit - self.two_layer_hertz['best_fit']['layer1']['contact_point']['value'])
                ind[ind<0] = 0
                y_fit_layer1 = np.power(abs(fit_trim_layer1[0]),3/2) * np.power(ind,3/2)

                residuals_layer1 = y_fit_layer1[fit_start_mod_layer1:fit_end_mod_layer1] - y_data[fit_start_mod_layer1:fit_end_mod_layer1]

                self.two_layer_hertz['residuals']['layer1']['mean'] = np.mean(np.absolute(residuals_layer1))
                self.two_layer_hertz['residuals']['layer1']['data'] = residuals_layer1



            elif indenter_characteristics['geometry'] == 'conical':

                e_modul_layer1 = fit_trim_layer1[0]**2 * (1 - poisson_ratio**2) * np.pi / (2 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                x_fit = copy.deepcopy(x_data)
                ind = -(x_fit - self.two_layer_hertz['best_fit']['layer1']['contact_point']['value'])
                ind[ind<0] = 0
                y_fit_layer1 = fit_trim_layer1[0]**2 * ind**2

                residuals_layer1 = y_fit_layer1[fit_start_mod_layer1:fit_end_mod_layer1] - y_data[fit_start_mod_layer1:fit_end_mod_layer1]

                self.two_layer_hertz['residuals']['layer1']['mean'] = np.mean(np.absolute(residuals_layer1))
                self.two_layer_hertz['residuals']['layer1']['data'] = residuals_layer1


            elif indenter_characteristics['geometry'] == 'four-sided pyramid':

                e_modul_layer1 = fit_trim_layer1[0]**2 * (1 - poisson_ratio**2) / (0.7453 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                x_fit = copy.deepcopy(x_data)
                ind = -(x_fit - self.two_layer_hertz['best_fit']['layer1']['contact_point']['value'])
                ind[ind<0] = 0
                y_fit_layer1 = fit_trim_layer1[0]**2 * ind**2

                residuals_layer1 = y_fit_layer1[fit_start_mod_layer1:fit_end_mod_layer1] - y_data[fit_start_mod_layer1:fit_end_mod_layer1]

                self.two_layer_hertz['residuals']['layer1']['mean'] = np.mean(np.absolute(residuals_layer1))
                self.two_layer_hertz['residuals']['layer1']['data'] = residuals_layer1


        else:

            self.two_layer_hertz['best_fit']['layer1']['line_found'] = False
            self.two_layer_hertz['residuals']['layer1'] = dict()



            e_modul_layer1 = np.nan


        if line_found_layer2:

            fit_length_final_layer2 = fit_end_layer2 - fit_start_layer2
            fit_end_mod_layer2 = fit_end_layer2
            # the issued for layer 2 seems to be rather the end points
            fit_start_mod_layer2 = fit_end_layer2 - int(layer2_parameters['final_fit_fraction'] * fit_length_final_layer2)
            #fit_start_mod_layer2 = fit_start_layer2 + int(0.5*(1 - layer2_parameters['final_fit_fraction'])  * fit_length_final_layer2)
            #fit_end_mod_layer2 = fit_start_layer2 + int(0.5 *(1 + layer2_parameters['final_fit_fraction']) * fit_length_final_layer2)

            fit_trim_layer2 = np.polyfit(x_data[fit_start_mod_layer2:fit_end_mod_layer2], y_data_scaled_layer2[fit_start_mod_layer2:fit_end_mod_layer2],1)

            # calculate the residuals

            residuals_linear_layer2 = x_data[fit_start_mod_layer2:fit_end_mod_layer2] *fit_trim_layer2[0] + fit_trim_layer2[1] - y_data_scaled_layer2[fit_start_mod_layer2:fit_end_mod_layer2]

            self.two_layer_hertz['best_fit']['layer2']['line_found'] = True
            self.two_layer_hertz['best_fit']['layer2']['index'] = (fit_start_mod_layer2,fit_end_mod_layer2)
            self.two_layer_hertz['best_fit']['layer2']['interval'] = (self.data['extend'][self.keys['ts_key']][fit_start_mod_layer2],self.data['extend'][self.keys['ts_key']][fit_end_mod_layer2-1])
            self.two_layer_hertz['best_fit']['layer2']['fit_parameter'] = - fit_trim_layer2[0]
            self.two_layer_hertz['best_fit']['layer2']['contact_point'] = dict()
            #contact point index as first point with value smaller than the calculated contact point
            self.two_layer_hertz['best_fit']['layer2']['contact_point']['index'] = np.argmax(self.data['extend'][self.keys['ts_key']] < -fit_trim_layer2[1]/fit_trim_layer2[0])
            self.two_layer_hertz['best_fit']['layer2']['contact_point']['value'] = -fit_trim_layer2[1]/fit_trim_layer2[0]

            self.two_layer_hertz['best_fit']['layer2']['specifics'] = dict()
            self.two_layer_hertz['best_fit']['layer2']['specifics']['start_index'] = start_index_layer2
            self.two_layer_hertz['best_fit']['layer2']['specifics']['full_index'] = (fit_start_layer2,fit_end_layer2-1)

            self.two_layer_hertz['residuals']['layer2']['unit'] = 'nN'

            self.two_layer_hertz['residuals']['layer2']['mean_linear_fit'] = np.mean(np.absolute(residuals_linear_layer2))
            self.two_layer_hertz['residuals']['layer2']['data_linear_fit'] = residuals_linear_layer2


            if indenter_characteristics['geometry'] == 'parabolic':


                e_modul_layer2 = np.power(abs(fit_trim_layer2[0]),3/2) * (1 - poisson_ratio**2) * 3 / (4 * math.sqrt(indenter_characteristics['radius [nm]']))

                x_fit = copy.deepcopy(x_data)
                ind = -(x_fit - self.two_layer_hertz['best_fit']['layer2']['contact_point']['value'])
                ind[ind<0] = 0
                y_fit_layer2 = np.power(abs(fit_trim_layer2[0]),3/2) * np.power(ind,3/2)

                residuals_layer2 = y_fit_layer2[fit_start_mod_layer2:fit_end_mod_layer2] - y_data[fit_start_mod_layer2:fit_end_mod_layer2]

                self.two_layer_hertz['best_fit']['layer2']['mean'] = np.mean(np.absolute(residuals_layer2))
                self.two_layer_hertz['best_fit']['layer2']['data'] = residuals_layer2


            elif indenter_characteristics['geometry'] == 'conical':

                e_modul_layer2 = fit_trim_layer2[0]**2 * (1 - poisson_ratio**2) * np.pi / (2 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                x_fit = copy.deepcopy(x_data)
                ind = -(x_fit - self.two_layer_hertz['best_fit']['layer2']['contact_point']['value'])
                ind[ind<0] = 0
                y_fit_layer2 = fit_trim_layer2[0]**2 * ind**2

                residuals_layer2 = y_fit_layer2[fit_start_mod_layer2:fit_end_mod_layer2] - y_data[fit_start_mod_layer2:fit_end_mod_layer2]

                self.two_layer_hertz['residuals']['layer2']['mean'] = np.mean(np.absolute(residuals_layer2))
                self.two_layer_hertz['residuals']['layer2']['data'] = residuals_layer2


            elif indenter_characteristics['geometry'] == 'four-sided pyramid':

                e_modul_layer2 = fit_trim_layer2[0]**2 * (1 - poisson_ratio**2) / (0.7453 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                x_fit = copy.deepcopy(x_data)
                ind = -(x_fit - self.two_layer_hertz['best_fit']['layer2']['contact_point']['value'])
                ind[ind<0] = 0
                y_fit_layer2 = fit_trim_layer2[0]**2 * ind**2

                residuals_layer2 = y_fit_layer2[fit_start_mod_layer2:fit_end_mod_layer2] - y_data[fit_start_mod_layer2:fit_end_mod_layer2]

                self.two_layer_hertz['residuals']['layer2']['mean'] = np.mean(np.absolute(residuals_layer2))
                self.two_layer_hertz['residuals']['layer2']['data'] = residuals_layer2

        else:

            self.two_layer_hertz['best_fit']['layer2']['line_found'] = False
            self.two_layer_hertz['residuals']['layer2'] = dict()

            e_modul_layer2 = np.nan


        self.two_layer_hertz['poisson_ratio'] = poisson_ratio
        self.two_layer_hertz['units'] = copy.deepcopy(self.units)

        e_modul_layer1 = e_modul_layer1 * 10**9
        e_modul_layer2 = e_modul_layer2 * 10**9
        e_modul_unit = 'Pa'
        e_modul_factor = 1

        self.two_layer_hertz['young_modulus']['layer1'] = {'value': e_modul_layer1, 'unit': e_modul_unit, 'factor': e_modul_factor}
        self.two_layer_hertz['young_modulus']['layer2'] = {'value': e_modul_layer2, 'unit': e_modul_unit, 'factor': e_modul_factor}




    def fit_multi_layer_segments(self,
                                 segments,
                                 poisson_ratio = 0.5,
                                 indenter_characteristics = {'geometry': 'parabolic', 'radius [nm]': 10},
                                 transition_sensitivity = 1):


        transition_fac = 5 - math.log10(transition_sensitivity)
        segments = segments
#        segments = dict()
#        segments[1] = dict()
        segments[1]['index'] = dict()
#        segments[2] = dict()
        segments[2]['index'] = dict()
#        segments[3] = dict()
        segments[3]['index'] = dict()
#
#        segments[1]['parameter'] = dict()
#        segments[1]['parameter']['limit [Pa]'] = 5000
#        segments[1]['parameter']['filter'] = dict()
#        segments[1]['parameter']['filter']['applied'] = True
#        segments[1]['parameter']['filter']['type'] = 'savitzky-golay'
#        segments[1]['parameter']['filter']['parameter'] = {'length': 51, 'order': 1, 'deriv': 0, 'delta': 1.0, 'axis': -1, 'mode': 'interp', 'cval': 0.0}
#        segments[1]['parameter']['transition_fac'] = transition_fac
#        segments[1]['parameter']['fit_length'] = 100
#        segments[1]['parameter']['final_fit_fraction'] = 0.9
#        segments[1]['parameter']['r_squared_limit'] = 0.98
#        segments[1]['parameter']['residual_sensitivity'] = 1 #residual fac 5
#        segments[1]['parameter']['with_residuals'] = True
#        segments[1]['parameter']['reverse_search'] = False
#
#        segments[2]['parameter'] = dict()
#        segments[2]['parameter']['limit [Pa]'] = 100000
#        segments[2]['parameter']['filter'] = dict()
#        segments[2]['parameter']['filter']['applied'] = False
#        segments[2]['parameter']['transition_fac'] = transition_fac
#        segments[2]['parameter']['fit_length'] = 100
#        segments[2]['parameter']['final_fit_fraction'] = 0.9
#        segments[2]['parameter']['r_squared_limit'] = 0.95
#        segments[2]['parameter']['residual_sensitivity'] = 0.00001 #residual fac 10
#        segments[2]['parameter']['with_residuals'] = True
#        segments[1]['parameter']['reverse_search'] = False
#
#        segments[3]['parameter'] = dict()
#        segments[3]['parameter']['limit [Pa]'] = np.nan
#        segments[3]['parameter']['filter'] = dict()
#        segments[3]['parameter']['filter']['applied'] = False
#        segments[3]['parameter']['transition_fac'] = transition_fac
#        segments[3]['parameter']['fit_length'] = 10
#        segments[3]['parameter']['final_fit_fraction'] = 0.9
#        segments[3]['parameter']['r_squared_limit'] = 0.9
#        segments[3]['parameter']['residual_sensitivity'] = 0.00001
#        segments[3]['parameter']['with_residuals'] = True
#        segments[1]['parameter']['reverse_search'] = True
#
        x_data = self.data['extend'][self.keys['ts_key']] / (1e-09 / self.units['distance']['factor'])
        y_data = self.data['extend'][self.keys['y_key']] / (1e-09 / self.units['force']['factor'])
        #noise_lvl_adapted = self.noise_level['value'] / (1e-09 / self.units['force']['factor']) #changed in self._find_layer()

        # 1. make data sets according to segment properties:

        y_data_savgol = dict()
        y_data_scaled = dict()

        for seg in segments.keys():

            if segments[seg]['parameter']['filter']['applied']:

                y_data_savgol[seg] = savgol_filter(y_data, segments[seg]['parameter']['filter']['parameter']['length'],
                             segments[seg]['parameter']['filter']['parameter']['order'],
                             deriv = segments[seg]['parameter']['filter']['parameter']['deriv'],
                             delta = segments[seg]['parameter']['filter']['parameter']['delta'],
                             axis = segments[seg]['parameter']['filter']['parameter']['axis'],
                             mode = segments[seg]['parameter']['filter']['parameter']['mode'],
                             cval = segments[seg]['parameter']['filter']['parameter']['cval'],)

            else:

                y_data_savgol[seg] = y_data


            if indenter_characteristics['geometry'] == 'parabolic':

                y_data_scaled[seg] = np.power(y_data_savgol[seg],2/3)
                segments[seg]['index']['start'] = np.amax(np.where(np.isnan(y_data_scaled[seg]))) + 1

            elif indenter_characteristics['geometry'] == 'conical' or indenter_characteristics['geometry'] == 'four-sided pyramid':

                y_data_scaled[seg] = np.sqrt(y_data_savgol[seg])
                segments[seg]['index']['start'] = np.amax(np.where(np.isnan(y_data_scaled[seg]))) + 1

        # create three individual segments roughly based on the local elasticity during the indentation
        self._create_segments(segments, x_data, y_data, y_data_savgol, indenter_characteristics, poisson_ratio)

        layers = dict()
        # in each segment do a linearized hertz model fit
        y_fit, fit_trim = self._find_layer(layers, segments, x_data, y_data, y_data_scaled, indenter_characteristics, poisson_ratio)


        self.multi_layer_hertz['indenter'] = indenter_characteristics
        self.multi_layer_hertz['method'] = 'linear'
        self.multi_layer_hertz['parameter'] = dict()
        self.multi_layer_hertz['parameter']['transition_sensitivity'] = transition_sensitivity
        self.multi_layer_hertz['parameter']['transition_factor'] = transition_fac
        self.multi_layer_hertz['segments'] = segments
        self.multi_layer_hertz['layers'] = layers
        self.multi_layer_hertz['poisson_ratio'] = poisson_ratio
        self.multi_layer_hertz['units'] = copy.deepcopy(self.units)
        self.multi_layer_hertz['young_modulus'] = dict()

        for seg in segments.keys():

            self.multi_layer_hertz['young_modulus'][seg] = layers[seg]['young_modulus']['value']


        self.multi_layer_hertz['young_modulus']['unit'] = layers[1]['young_modulus']['unit']
        self.multi_layer_hertz['young_modulus']['factor'] = layers[1]['young_modulus']['factor']




#%% further data manipulation




    def calibrated_cantilever(self, sensitivity, spring_constant):

        if self.control_variables['cantilever_calibrated']:

            sys.stdout.write('Cantilever is already calibrated. Change calibration via set_sensitivity() and set_spring_constant()\n')

        else:

            self.settings['sensitivity'] = sensitivity
            self.settings['spring_constant'] = spring_constant

            for seg in self.data.keys():

                self.data[seg][self.keys['y_key']] = self.data[seg][self.keys['y_key']] * self.settings['sensitivity'] * self.settings['spring_constant']


            self.channel_units[self.keys['x_key']] = 'N'


            self.calibrations['spring_constant_calibrated'] = True
            self.calibrations['sensitivity_calibrated'] = True
            self.control_variables['cantilever_calibrated'] = True






    def set_spring_constant(self, value):

        self.calibrations['spring_constant'] = value

        fac = self.calibrations['spring_constant'] / self.jpk_force_data.calibrations['spring_constant']

        for seg in self.data.keys():

            self.data[seg][self.keys['y_key']] = self.data[seg][self.keys['y_key']] * fac

        #if ... was performed repeat it
        if self.control_variables['tip_sample_separation_correction_performed']:

            self.get_tip_sample_separation()

        #do not change adhesion force etc...because tip sample separation stuff has also influence e.g. on the adhesion energy and location of rupture events



    def reset_spring_constant(self):



        fac = self.jpk_force_data.calibrations['spring_constant'] / self.calibrations['spring_constant']

        self.calibrations['spring_constant'] = self.jpk_force_data.calibrations['spring_constant']

        for seg in self.data.keys():

            self.data[seg][self.keys['y_key']] = self.data[seg][self.keys['y_key']] * fac

        #if ... was performed repeat it
        if self.control_variables['tip_sample_separation_correction_performed']:

            self.get_tip_sample_separation()



    def set_sensitivity(self, value):

        self.calibrations['sensitivity'] = value

        fac = self.calibrations['sensitivity'] / self.jpk_force_data.calibrations['sensitivity']

        for seg in self.data.keys():

            self.data[seg][self.keys['y_key']] = self.data[seg][self.keys['y_key']] * fac

        #if ... was performed repeat it
        if self.control_variables['tip_sample_separation_correction_performed']:

            self.get_tip_sample_separation()




    def reset_sensitivity(self):

        fac = self.jpk_force_data.calibrations['sensitivity'] / self.calibrations['sensitivity']

        self.calibrations['sensitivity'] = self.jpk_force_data.calibrations['sensitivity']

        for seg in self.data.keys():

            self.data[seg][self.keys['y_key']] = self.data[seg][self.keys['y_key']] * fac

        #if ... was performed repeat it
        if self.control_variables['tip_sample_separation_correction_performed']:

            self.get_tip_sample_separation()



#%% accessing data stuff
    def get_jpk_x_key(self):

        if 'measuredHeight' in self.jpk_force_data.channels:

            x_key = 'measuredHeight'

        elif 'capacitiveSensorHeight' in self.jpk_force_data.channels:

            x_key = 'capacitiveSensorHeight'

        elif 'strainGaugeHeight' in self.jpk_force_data.channels:

            x_key = 'strainGaugeHeight'

        elif 'smoothedMeasuredHeight' in self.jpk_force_data.channels:

            x_key = 'smoothedMeasuredHeight'

        elif 'head-height' in self.jpk_force_data.channels:

            x_key = 'head-height'

        elif 'smoothedCapacitiveSensorHeight' in self.jpk_force_data.channels:

            x_key = 'smoothedCapacitiveSensorHeight'

        elif 'smoothedStrainGaugeHeight' in self.jpk_force_data.channels:

            x_key = 'smoothedStrainGaugeHeight'

        elif 'height' in self.jpk_force_data.channels:

            x_key = 'height'

        return x_key




    def get_x_key(self):

        return self.keys['x_key']


    def get_y_key(self):

        return self.keys['y_key']


    def get_ts_key(self):

        return self.keys['ts_key']


    def get_keys(self):

        return self.keys




    def set_x_key(self, channel = str()):

        if channel == str():

            self.keys['x_key'] = self.get_jpk_x_key()

        elif channel in self.channels and channel is not 'vDeflection':

            self.keys['x_key'] = channel

        else:

            self.keys['x_key'] = self.get_jpk_x_key()




    def set_keys(self, x_key):

        self.set_x_key(x_key)
        self.keys['y_key'] = 'vDeflection'
        self.keys['ts_key'] = 'separation'





#%% data visualization

    # def data_plot(self, col1 = '', col2 = '', ax = 0, **kwargs):
    #
    #     if len(col1) == 0 or len(col2) == 0:
    #
    #
    #         #if self.control_variables['tip_sample_separation_correction_performed']:
    #
    #         x_key = self.keys['ts_key']
    #         y_key = self.keys['y_key']
    #
    #         #else:
    #
    #             #x_key = self.keys['x_key']
    #            # y_key = self.keys['y_key']
    #
    #     elif len(col1) > 0 and len(col2) > 0 and col1 in self.channels and col2 in self.channels:
    #
    #         x_key = col1
    #         y_key = col2
    #
    #
    #     x_unit_key = self.keys['x_key']
    #
    #
    #     if isinstance(ax, matplotlib.axes._axes.Axes):   # check whether ax is from the correct type (axes)
    #
    #         line_extend = ax.plot(self.data['extend'][x_key], self.data['extend'][y_key], label = 'extend', **kwargs)
    #         line_retract = ax.plot(self.data['retract'][x_key], self.data['retract'][y_key], label = 'retract', **kwargs)
    #
    #         ax.set_xlabel(x_key + ' / ' + self.channel_units[x_unit_key])
    #         ax.set_ylabel(y_key + ' / ' + self.channel_units[y_key])
    #         ax.legend()
    #         ax.tick_params(direction = 'in', top = True, right = True)
    #
    #         return (ax, line_extend, line_retract)
    #
    #
    #     elif ax == 0:
    #
    #         fig = plt.figure()
    #         ax = fig.add_axes([0.15, 0.15, 0.75, 0.75])
    #
    #         line_extend = plt.plot(self.data['extend'][x_key], self.data['extend'][y_key], label = 'extend', **kwargs)
    #         line_retract = plt.plot(self.data['retract'][x_key], self.data['retract'][y_key], label = 'retract', **kwargs)
    #
    #         plt.xlabel(x_key + ' / ' + self.channel_units[x_unit_key])
    #         plt.ylabel(y_key + ' / ' + self.channel_units[y_key])
    #         ax.legend()
    #         ax.tick_params(direction = 'in', top = True, right = True)
    #
    #         return (ax, line_extend, line_retract)
    #
    #
    #     else:
    #
    #         fig = plt.figure()
    #         ax = fig.add_axes([0.15, 0.15, 0.75, 0.75])
    #
    #         line_extend = plt.plot(self.data['extend'][x_key], self.data['extend'][y_key], label = 'extend', **kwargs)
    #         line_retract = plt.plot(self.data['retract'][x_key], self.data['retract'][y_key], label = 'retract', **kwargs)
    #
    #         plt.xlabel(x_key + ' / ' + self.channel_units[x_unit_key])
    #         plt.ylabel(y_key + ' / ' + self.channel_units[y_key])
    #         ax.legend()
    #         ax.tick_params(direction = 'in', top = True, right = True)
    #
    #         return (ax, line_extend, line_retract)
    #


#    def raw_data_plot(self, col1 = '', col2 = '', ax = 0, **kwargs):
#
#        if len(col1) == 0 or len(col2) == 0:
#
#            x_key = self.keys['x_key']
#            y_key = self.keys['y_key']
#
#        elif len(col1) > 0 and len(col2) > 0 and col1 in self.channels and col2 in self.channels:
#
#            x_key = col1
#            y_key = col2
#
#
#        if isinstance(ax, matplotlib.axes._axes.Axes):   # check whether ax is from the correct type (axes)
#
#            line_extend = ax.plot(self.jpk_force_data.data['extend'][x_key], self.data['extend'][y_key], **kwargs)
#            line_retract = ax.plot(self.jpk_force_data.data['retract'][x_key], self.data['retract'][y_key], **kwargs)
#
#            ax.set_xlabel(x_key + ' / ' + self.channel_units[x_key])
#            ax.set_ylabel(y_key + ' / ' + self.channel_units[y_key])
#
#            return (ax, line_extend, line_retract)
#
#
#        elif ax == 0:
#
#            fig = plt.figure()
#            ax = fig.add_axes([0.15, 0.15, 0.75, 0.75])
#
#            line_extend = plt.plot(self.jpk_force_data.data['extend'][x_key], self.data['extend'][y_key], **kwargs)
#            line_retract = plt.plot(self.jpk_force_data.data['retract'][x_key], self.data['retract'][y_key], **kwargs)
#
#            plt.xlabel(x_key + ' / ' + self.jpk_force_data.channel_units[x_key])
#            plt.ylabel(y_key + ' / ' + self.jpk_force_data.channel_units[y_key])
#
#            return (ax, line_extend, line_retract)
#
#
#        else:
#
#            fig = plt.figure()
#            ax = fig.add_axes([0.15, 0.15, 0.75, 0.75])
#
#            line_extend = plt.plot(self.jpk_force_data.data['extend'][x_key], self.data['extend'][y_key], **kwargs)
#            line_retract = plt.plot(self.jpk_force_data.data['retract'][x_key], self.data['retract'][y_key], **kwargs)
#
#            plt.xlabel(x_key + ' / ' + self.channel_units[x_key])
#            plt.ylabel(y_key + ' / ' + self.channel_units[y_key])
#
#            return (ax, line_extend, line_retract)


#%% additional methods data analysis


    def get_last_adhesion_signature(self, sensitivity = 1):
        # determines the index when the last adhesion signature was observed
        ret_dict = dict()

        fac = 5 - math.log10(sensitivity)

        if fac < 2:

            fac = 2

        adh_event_found = False
        i = 1
        index = 0

        while not adh_event_found and i < self.settings['samples']['retract']:

            if self.data['retract'][self.keys['y_key']][-i] < - fac * self.noise_level['value']: # check whether point a bit before ref level is significantly smaller
                # if that is the case, confirm that it is not a single outlier

                adh_event_found = True
                index = self.settings['samples']['retract'] - i

                for j in range(0,5): #short check whether the point found was just an outlier

                   if self.data['retract'][self.keys['y_key']][-i-j] > - self.noise_level['value']:

                        adh_event_found = False
                        index = 0


            i += 1

        ret_dict['index'] = index
        #print(adh_event_found, ref_level)
        if adh_event_found: #finds the last point that is smaller than the reference level

            i = 1
            add = 0

            while i < 20 and self.data['retract'][self.keys['y_key']][index+i] < 0:

                add = i
                i += 1

            index = index + add + 1


        ret_dict['end_adh_event_index'] = index

        return ret_dict











#%% other stuff
    def set_save_directory(self, directory):

         self.file_info['save_directory'] = directory

         if not os.path.isdir(self.file_info['save_directory']):

              try:

                 os.makedirs(self.file_info['save_directory'])

              except:

                 self.file_info['save_directory'] = os.getcwd()





#%% additional methods - data correction

    def distance_correction_constant(self, reference = 'extend'):


        ret_dict = {'corr_ext': self.data['extend'][self.keys['x_key']][-1], 'corr_ret': self.data['retract'][self.keys['x_key']][0]}

        if reference == 'individual':

            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - self.data['extend'][self.keys['x_key']][-1]
            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - self.data['retract'][self.keys['x_key']][0]

        elif reference == 'mean':

            corr_mean = 0.5 * (self.data['extend'][self.keys['x_key']][-1] + self.data['retract'][self.keys['x_key']][0])

            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - corr_mean
            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - corr_mean

        elif reference == 'extend':

            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - self.data['extend'][self.keys['x_key']][-1]
            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - self.data['extend'][self.keys['x_key']][-1]

        elif reference == 'retract':

            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - self.data['retract'][self.keys['x_key']][0]
            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - self.data['retract'][self.keys['x_key']][0]

        return ret_dict



    def distance_correction_zero_force_intersect(self, reference = 'extend', smooth_applied = False, smooth_length = 51):

        ext_0_int = self.get_zero_force_intersect_extend(smooth_applied, smooth_length)
        ret_0_int = self.get_zero_force_intersect_retract(smooth_applied, smooth_length)

        corr_ext = ext_0_int['value_h']
        corr_ret = ret_0_int['value_h']
        corr_mean = 0.5 * (corr_ext + corr_ret)


        if reference == 'individual':

            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - corr_ext
            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - corr_ret

        elif reference == 'mean':

            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - corr_mean
            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - corr_mean

        elif reference == 'extend':

            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - corr_ext
            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - corr_ext


        elif reference == 'retract':

            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - corr_ret
            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - corr_ret


        ret_dict = dict()
        #{'smooth_applied': smooth_applied, 'smooth_length': smooth_length}

        ret_dict['corr_ext'] = corr_ext
        ret_dict['corr_ret'] = corr_ret


        return ret_dict



    def distance_correction_fit(self, reference = 'extend', length_fit = 20):
# this function fits a straight line to the data at contact. the intersection between this line and the zero line is shifted to zero

        ret_dict = dict()

        ext_fit_int = self.get_distance_correction_fit_extend(length_fit)
        ret_fit_int = self.get_distance_correction_fit_retract(length_fit)

        corr_ext = ext_fit_int['value_h']
        corr_ret = ret_fit_int['value_h']
        corr_mean = 0.5 * (corr_ext + corr_ret)

        if reference == 'individual':

            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - corr_ext
            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - corr_ret


        elif reference == 'mean':

            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - corr_mean
            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - corr_mean

        elif reference == 'extend':

            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - corr_ext
            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - corr_ext


        elif reference == 'retract':

            self.data['extend'][self.keys['x_key']] = self.data['extend'][self.keys['x_key']] - corr_ret
            self.data['retract'][self.keys['x_key']] = self.data['retract'][self.keys['x_key']] - corr_ret


        ret_dict['length_fit'] = length_fit

        ret_dict['corr_ext'] = corr_ext
        ret_dict['corr_ret'] = corr_ret



        return ret_dict




    def get_zero_force_intersect_extend(self, smooth_applied = False, smooth_length = 51):

        return_dict = dict()
        return_dict['smooth_applied'] = smooth_applied


        if not smooth_applied:

            index = self.settings['samples']['extend'] - np.argmax(np.flip(self.data['extend'][self.keys['y_key']], axis = 0)<0) - 1


        elif smooth_applied:

            index = self.settings['samples']['extend'] - np.argmax(np.flip(savgol_filter(copy.deepcopy(self.data['extend'][self.keys['y_key']]),smooth_length,1), axis = 0)<0) - 1

        return_dict['index'] = index
        return_dict['value_h'] = self.data['extend'][self.keys['x_key']][index]
        #return_dict['value_ts'] = self.data['extend'][self.keys['x_key']][index]


        return return_dict


    def get_zero_force_intersect_retract(self, smooth_applied = False, smooth_length = 51):

        return_dict = dict()
        return_dict['smooth_applied'] = smooth_applied


        if not smooth_applied:

            index = np.argmax(self.data['retract'][self.keys['y_key']]<0)

        elif smooth_applied:

            index = np.argmax(savgol_filter(copy.deepcopy(self.data['retract'][self.keys['y_key']]),smooth_length,1)<0)



        return_dict['index'] = index
        return_dict['value_h'] = self.data['retract'][self.keys['x_key']][index]
        #return_dict['value_ts'] = self.data['retract'][self.keys['x_key']][index]

        return return_dict



    def get_distance_correction_fit_extend(self, length_fit = 20):
# fit a straight line to the line at contact. determine intersection of this line with the baseline

        return_dict = dict()

        slope_h, y_intersect_h = np.polyfit(self.data['extend'][self.keys['x_key']][-1-length_fit:-1], self.data['extend'][self.keys['y_key']][-1-length_fit:-1]  ,1)
        x_intersect_h = (0 - y_intersect_h) / slope_h

        return_dict['value_h'] = x_intersect_h


        return return_dict




    def get_distance_correction_fit_retract(self, length_fit = 20):


        return_dict = dict()

        slope_h, y_intersect_h = np.polyfit(self.data['retract'][self.keys['x_key']][0:length_fit], self.data['retract'][self.keys['y_key']][0:length_fit],1)
        x_intersect_h = (0 - y_intersect_h) / slope_h
        return_dict['value_h'] = x_intersect_h

        return return_dict



#%% helper functions

    def _create_segments(self, segments, x_data, y_data, y_data_savgol, indenter_characteristics, poisson_ratio):

        y_data_scaled_abs = dict()

        for seg in segments.keys():

            y_data_scaled_abs[seg] = self._get_scaled_data(y_data_savgol[seg], indenter_characteristics)


        # 1. segment

        #smooth_length = segments[1]['parameter']['filter']['parameter']['length']
        fit_length = int(segments[1]['parameter']['fit_length'] * 0.5)

        diff_data = y_data - y_data_savgol[1]
        diff_data_std = np.std(diff_data[0:int(self.settings['samples']['extend']*0.2)])

        transition_found = bool(np.argmax(abs(diff_data)>diff_data_std * segments[1]['parameter']['transition_fac']))
        vec_size = self.settings['samples']['extend'] - fit_length
        local_elasticity = np.full((vec_size,1),np.nan)

        for i in range(vec_size):

            x_fit_data = x_data[0+i:fit_length+i]
            y_fit_data = y_data_scaled_abs[1][0+i:fit_length+i]
            fit_extend = np.polyfit(x_fit_data,y_fit_data,1)
            local_elasticity[i] = 10**9 * self._get_elasticity_from_linear_hertz_fit(fit_extend, poisson_ratio, indenter_characteristics)


        critical_elasticity_found = bool(np.argmax(np.flip(local_elasticity,0)<segments[1]['parameter']['limit [Pa]']))

        if critical_elasticity_found:

            #find the first point after which all following are larger than the critical elasticity
            index_critical_elasticity = vec_size - np.argmax(np.flip(local_elasticity,0)<segments[1]['parameter']['limit [Pa]']) + 1 + int(0.5 * fit_length)


        if critical_elasticity_found:

            if transition_found:

                index_transition = np.argmax(abs(diff_data)>diff_data_std * segments[1]['parameter']['transition_fac']) - int(0.5*fit_length)

                segments[1]['index']['end'] = min(index_transition,index_critical_elasticity)

            else:

                segments[1]['index']['end'] = index_critical_elasticity


            segments[1]['exist'] = True

            if (segments[1]['index']['end'] - segments[1]['index']['start']) > segments[1]['parameter']['fit_length']:

                segments[1]['find_layer'] = True

            else:

                segments[1]['find_layer'] = False


            # 2. segment

            fit_length = int(segments[2]['parameter']['fit_length'] * 0.25)
            vec_size = self.settings['samples']['extend'] - fit_length
            local_elasticity = np.full((vec_size,1),np.nan)

            for i in range(vec_size):

                x_fit_data = x_data[0+i:fit_length+i]
                y_fit_data = y_data_scaled_abs[2][0+i:fit_length+i]
                fit_extend = np.polyfit(x_fit_data,y_fit_data,1)
                local_elasticity[i] = 10**9 * self._get_elasticity_from_linear_hertz_fit(fit_extend, poisson_ratio, indenter_characteristics)


            critical_elasticity_found = bool(np.argmax(np.flip(local_elasticity,0)<segments[2]['parameter']['limit [Pa]']))

            if critical_elasticity_found:

               index_critical_elasticity = vec_size - np.argmax(np.flip(local_elasticity,0)<segments[2]['parameter']['limit [Pa]']) + 1

               segments[2]['index']['start'] = segments[1]['index']['end'] + 1
               segments[2]['index']['end'] = index_critical_elasticity
               segments[2]['exist'] = True

               if (segments[2]['index']['end'] - segments[2]['index']['start']) > segments[2]['parameter']['fit_length']:

                   segments[2]['find_layer'] = True

               else:

                   segments[2]['find_layer'] = False


               segments[3]['index']['start'] = index_critical_elasticity + 1
               segments[3]['index']['end'] = self.settings['samples']['extend']
               segments[3]['exist'] = True

               if (segments[3]['index']['end'] - segments[3]['index']['start']) > segments[3]['parameter']['fit_length']:

                   segments[3]['find_layer'] = True

               else:

                   segments[3]['find_layer'] = False

            else:

               segments[2]['index']['start'] = segments[1]['index']['end'] + 1
               segments[2]['index']['end'] = self.settings['samples']['extend']
               segments[2]['exist'] = True

               if (segments[2]['index']['end'] - segments[2]['index']['start']) > segments[2]['parameter']['fit_length']:

                   segments[2]['find_layer'] = True

               else:

                   segments[2]['find_layer'] = False

               segments[3]['exist'] = False
               segments[3]['find_layer'] = False
               segments[3]['index'] = {}


        else:

            if transition_found:

                index_transition = np.argmax(abs(diff_data)>diff_data_std * segments[1]['parameter']['transition_fac']) - int(0.5*fit_length)
                segments[1]['index']['end'] = index_transition

            else:

                segments[1]['index']['end'] = self.settings['samples']['extend']


            segments[1]['exist'] = True

            if (segments[1]['index']['end'] - segments[1]['index']['start']) > segments[1]['parameter']['fit_length']:

                segments[1]['find_layer'] = True

            else:

                segments[1]['find_layer'] = False


            segments[2]['exist'] = False
            segments[2]['find_layer'] = False
            segments[2]['index'] = {}
            segments[3]['exist'] = False
            segments[3]['find_layer'] = False
            segments[3]['index'] = {}



    def _find_layer(self, layers, segments, x_data, y_data, y_data_scaled, indenter_characteristics, poisson_ratio):

        y_fit = dict() # can be used later to plot stuff
        fit_trim = dict()
        noise_lvl_adapted = self.noise_level['value'] / (1e-09 / self.units['force']['factor'])

        for seg in segments.keys():

            if segments[seg]['parameter']['reverse_search']:

                residual_fac = 5 - math.log10(segments[seg]['parameter']['residual_sensitivity'])

                layers[seg] = dict()

                if segments[seg]['find_layer']:

                    line_found = False
                    loop_run = True

                    start_index = segments[seg]['index']['end'] - 1
                    #reversed as search moves in oposite direction
                    fit_end = start_index + 1
                    fit_start = fit_end - segments[seg]['parameter']['fit_length']


                    if fit_end > segments[seg]['index']['end']:

                        loop_run = False


                    else:

                        # fit and determine quality of fit
                        fit = np.polyfit(x_data[fit_start:fit_end], y_data_scaled[seg][fit_start:fit_end],1)

                        total_sum_of_squares = np.sum((y_data_scaled[seg][fit_start:fit_end] - np.mean(y_data_scaled[seg][fit_start:fit_end]))**2 )
                        residuals = x_data[fit_start:fit_end] *fit[0] + fit[1] - y_data_scaled[seg][fit_start:fit_end]
                        squared_sum_residuals = np.sum(residuals**2)
                        r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                        if segments[seg]['parameter']['with_residuals']:

                            if r_squared > segments[seg]['parameter']['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac * noise_lvl_adapted:

                                straight_line = True
                                line_found = True

                            else:

                                straight_line = False


                            while fit_start > segments[seg]['index']['start'] and loop_run:

                                if straight_line:

                                    fit_start -= 1

                                    fit = np.polyfit(x_data[fit_start:fit_end], y_data_scaled[seg][fit_start:fit_end],1)

                                    total_sum_of_squares = np.sum((y_data_scaled[seg][fit_start:fit_end] - np.mean(y_data_scaled[seg][fit_start:fit_end]))**2 )
                                    residuals = x_data[fit_start:fit_end] *fit[0] + fit[1] - y_data_scaled[seg][fit_start:fit_end]
                                    squared_sum_residuals = np.sum(residuals**2)
                                    r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                                    if r_squared > segments[seg]['parameter']['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac * noise_lvl_adapted:

                                        straight_line = True

                                    else:

                                        straight_line = False
                                        loop_run = False


                                else:

                                    fit_end = fit_end - 1
                                    fit_start = fit_end - segments[seg]['parameter']['fit_length']

                                    fit = np.polyfit(x_data[fit_start:fit_end], y_data_scaled[seg][fit_start:fit_end],1)

                                    total_sum_of_squares = np.sum((y_data_scaled[seg][fit_start:fit_end] - np.mean(y_data_scaled[seg][fit_start:fit_end]))**2 )
                                    residuals = x_data[fit_start:fit_end] *fit[0] + fit[1] - y_data_scaled[seg][fit_start:fit_end]
                                    squared_sum_residuals = np.sum(residuals**2)
                                    r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                                    if r_squared > segments[seg]['parameter']['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac * noise_lvl_adapted:

                                        straight_line = True
                                        line_found = True


                        else:

                            if r_squared > segments[seg]['parameter']['r_squared_limit']:

                                straight_line = True
                                line_found = True

                            else:

                                straight_line = False


                            while fit_start > segments[seg]['index']['start'] and loop_run:

                                if straight_line:

                                    fit_start -= 1

                                    fit = np.polyfit(x_data[fit_start:fit_end], y_data_scaled[seg][fit_start:fit_end],1)

                                    total_sum_of_squares = np.sum((y_data_scaled[seg][fit_start:fit_end] - np.mean(y_data_scaled[seg][fit_start:fit_end]))**2 )
                                    residuals = x_data[fit_start:fit_end] *fit[0] + fit[1] - y_data_scaled[seg][fit_start:fit_end]
                                    squared_sum_residuals = np.sum(residuals**2)
                                    r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                                    if r_squared > segments[seg]['parameter']['r_squared_limit']:

                                        straight_line = True

                                    else:

                                        straight_line = False
                                        loop_run = False


                                else:

                                    fit_end = fit_end - 1
                                    fit_start = fit_end - segments[seg]['parameter']['fit_length']

                                    fit = np.polyfit(x_data[fit_start:fit_end], y_data_scaled[seg][fit_start:fit_end],1)

                                    total_sum_of_squares = np.sum((y_data_scaled[seg][fit_start:fit_end] - np.mean(y_data_scaled[seg][fit_start:fit_end]))**2 )
                                    residuals = x_data[fit_start:fit_end] *fit[0] + fit[1] - y_data_scaled[seg][fit_start:fit_end]
                                    squared_sum_residuals = np.sum(residuals**2)
                                    r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                                    if r_squared > segments[seg]['parameter']['r_squared_limit']:

                                        straight_line = True
                                        line_found = True


                    layers[seg]['segment'] = seg
                    layers[seg]['find_layer'] = True
                    layers[seg]['fit'] = dict()

                    if line_found:

                        fit_length_final = fit_end - fit_start
                        fit_end_mod = fit_end
                        fit_start_mod = fit_end - int(segments[seg]['parameter']['final_fit_fraction'] * fit_length_final)

                        fit_trim[seg] = np.polyfit(x_data[fit_start_mod:fit_end_mod], y_data_scaled[seg][fit_start_mod:fit_end_mod],1)

                        # calculate the residuals
                        residuals_linear = x_data[fit_start_mod:fit_end_mod] * fit_trim[seg][0] + fit_trim[seg][1] - y_data_scaled[seg][fit_start_mod:fit_end_mod]

                        layers[seg]['fit']['line_found'] = True
                        layers[seg]['fit']['index'] = (fit_start_mod,fit_end_mod-1)
                        layers[seg]['fit']['interval'] = (self.data['extend'][self.keys['ts_key']][fit_start_mod],self.data['extend'][self.keys['ts_key']][fit_end_mod-1])
                        layers[seg]['fit']['fit_parameter'] = - fit_trim[seg][0]
                        layers[seg]['fit']['contact_point'] = dict()
                        layers[seg]['fit']['contact_point']['index'] = np.argmax(self.data['extend'][self.keys['ts_key']] < -fit_trim[seg][1]/fit_trim[seg][0])
                        layers[seg]['fit']['contact_point']['value'] = -fit_trim[seg][1]/fit_trim[seg][0]
                        layers[seg]['fit']['specifics'] = dict()
                        layers[seg]['fit']['specifics']['start_index'] = segments[seg]['index']['start']
                        layers[seg]['fit']['specifics']['full_index'] = (fit_start,fit_end-1)

                        layers[seg]['residuals'] = dict()
                        layers[seg]['residuals']['unit'] = 'nN'
                        layers[seg]['residuals']['mean_linear_fit'] = np.mean(np.absolute(residuals_linear))
                        #layers[seg]['residuals']['data_linear_fit'] = residuals_linear


                        ##part dependend on indenter
                        if indenter_characteristics['geometry'] == 'parabolic':

                            e_modul = np.power(abs(fit_trim[seg][0]),3/2) * (1 - poisson_ratio**2) * 3 / (4 * math.sqrt(indenter_characteristics['radius [nm]']))

                            x_fit = copy.deepcopy(x_data)
                            ind = -(x_fit - layers[seg]['fit']['contact_point']['value'])
                            ind[ind<0] = 0
                            y_fit[seg] = np.power(abs(fit_trim[seg][0]),3/2) * np.power(ind,3/2)

                            residuals = y_fit[seg][fit_start:fit_end] - y_data[fit_start:fit_end]

                            layers[seg]['residuals']['mean'] = np.mean(np.absolute(residuals))
                            #layers[seg]['residuals']['data'] = residuals



                        elif indenter_characteristics['geometry'] == 'conical':

                            e_modul = fit_trim[seg][0]**2 * (1 - poisson_ratio**2) * np.pi / (2 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                            x_fit = copy.deepcopy(x_data)
                            ind = -(x_fit - layers[seg]['fit']['contact_point']['value'])
                            ind[ind<0] = 0
                            y_fit[seg] = fit_trim[seg][0]**2 * ind**2

                            residuals = y_fit[seg][fit_start:fit_end] - y_data[fit_start:fit_end]

                            layers[seg]['residuals']['mean'] = np.mean(np.absolute(residuals))
                            #layers[seg]['residuals']['data'] = residuals


                        elif indenter_characteristics['geometry'] == 'four-sided pyramid':

                            e_modul = fit_trim[seg][0]**2 * (1 - poisson_ratio**2) / (0.7453 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                            x_fit = copy.deepcopy(x_data)
                            ind = -(x_fit - layers[seg]['fit']['contact_point']['value'])
                            ind[ind<0] = 0
                            y_fit[seg] = fit_trim[seg][0]**2 * ind**2

                            residuals = y_fit[seg][fit_start:fit_end] - y_data[fit_start:fit_end]

                            layers[seg]['residuals']['mean'] = np.mean(np.absolute(residuals))
                            #layers[seg]['residuals']['data'] = residuals



                    else:

                        layers[seg]['fit']['line_found'] = False
                        layers[seg]['residuals'] = dict()

                        e_modul = np.nan


                else:

                    layers[seg]['segment'] = seg
                    layers[seg]['find_layer'] = False
                    layers[seg]['fit'] = {'line_found': False}
                    layers[seg]['residuals'] = dict()

                    e_modul = np.nan


            else:

                residual_fac = 5 - math.log10(segments[seg]['parameter']['residual_sensitivity'])

                layers[seg] = dict()

                if segments[seg]['find_layer']:

                    line_found = False
                    loop_run = True

                    fit_start = segments[seg]['index']['start']
                    fit_end = fit_start + segments[seg]['parameter']['fit_length']

                    if fit_end > segments[seg]['index']['end']:

                        loop_run = False

                    else:

                        # fit and determine quality of fit
                        fit = np.polyfit(x_data[fit_start:fit_end], y_data_scaled[seg][fit_start:fit_end],1)

                        total_sum_of_squares = np.sum((y_data_scaled[seg][fit_start:fit_end] - np.mean(y_data_scaled[seg][fit_start:fit_end]))**2 )
                        residuals = x_data[fit_start:fit_end] *fit[0] + fit[1] - y_data_scaled[seg][fit_start:fit_end]
                        squared_sum_residuals = np.sum(residuals**2)
                        r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                        if segments[seg]['parameter']['with_residuals']:

                            if r_squared > segments[seg]['parameter']['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac * noise_lvl_adapted:

                                straight_line = True
                                line_found = True

                            else:

                                straight_line = False


                            while fit_end < segments[seg]['index']['end'] and loop_run:

                                if straight_line:

                                    fit_end += 1

                                    fit = np.polyfit(x_data[fit_start:fit_end], y_data_scaled[seg][fit_start:fit_end],1)

                                    total_sum_of_squares = np.sum((y_data_scaled[seg][fit_start:fit_end] - np.mean(y_data_scaled[seg][fit_start:fit_end]))**2 )
                                    residuals = x_data[fit_start:fit_end] *fit[0] + fit[1] - y_data_scaled[seg][fit_start:fit_end]
                                    squared_sum_residuals = np.sum(residuals**2)
                                    r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                                    if r_squared > segments[seg]['parameter']['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac * noise_lvl_adapted:

                                        straight_line = True

                                    else:

                                        straight_line = False
                                        loop_run = False


                                else:

                                    fit_start = fit_start + 1
                                    fit_end = fit_start + segments[seg]['parameter']['fit_length']

                                    fit = np.polyfit(x_data[fit_start:fit_end], y_data_scaled[seg][fit_start:fit_end],1)

                                    total_sum_of_squares = np.sum((y_data_scaled[seg][fit_start:fit_end] - np.mean(y_data_scaled[seg][fit_start:fit_end]))**2 )
                                    residuals = x_data[fit_start:fit_end] *fit[0] + fit[1] - y_data_scaled[seg][fit_start:fit_end]
                                    squared_sum_residuals = np.sum(residuals**2)
                                    r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                                    if r_squared > segments[seg]['parameter']['r_squared_limit'] and np.sqrt(squared_sum_residuals) < residual_fac * noise_lvl_adapted:

                                        straight_line = True
                                        line_found = True



                        else:

                            if r_squared > segments[seg]['parameter']['r_squared_limit']:

                                straight_line = True
                                line_found = True

                            else:

                                straight_line = False


                            while fit_end < segments[seg]['index']['end'] and loop_run:

                                if straight_line:

                                    fit_end += 1

                                    fit = np.polyfit(x_data[fit_start:fit_end], y_data_scaled[seg][fit_start:fit_end],1)

                                    total_sum_of_squares = np.sum((y_data_scaled[seg][fit_start:fit_end] - np.mean(y_data_scaled[seg][fit_start:fit_end]))**2 )
                                    residuals = x_data[fit_start:fit_end] *fit[0] + fit[1] - y_data_scaled[seg][fit_start:fit_end]
                                    squared_sum_residuals = np.sum(residuals**2)
                                    r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                                    if r_squared > segments[seg]['parameter']['r_squared_limit']:

                                        straight_line = True

                                    else:

                                        straight_line = False
                                        loop_run = False


                                else:

                                    fit_start = fit_start + 1
                                    fit_end = fit_start + segments[seg]['parameter']['fit_length']

                                    fit = np.polyfit(x_data[fit_start:fit_end], y_data_scaled[seg][fit_start:fit_end],1)

                                    total_sum_of_squares = np.sum((y_data_scaled[seg][fit_start:fit_end] - np.mean(y_data_scaled[seg][fit_start:fit_end]))**2 )
                                    residuals = x_data[fit_start:fit_end] *fit[0] + fit[1] - y_data_scaled[seg][fit_start:fit_end]
                                    squared_sum_residuals = np.sum(residuals**2)
                                    r_squared = 1 - (squared_sum_residuals/total_sum_of_squares)


                                    if r_squared > segments[seg]['parameter']['r_squared_limit']:

                                        straight_line = True
                                        line_found = True


                    layers[seg]['segment'] = seg
                    layers[seg]['find_layer'] = True
                    layers[seg]['fit'] = dict()



                    if line_found:

                        fit_length_final = fit_end - fit_start
                        fit_start_mod = fit_start + int(0.5*(1 - segments[seg]['parameter']['final_fit_fraction'])  * fit_length_final)
                        fit_end_mod = fit_start + int(0.5 *(1 + segments[seg]['parameter']['final_fit_fraction']) * fit_length_final)

                        fit_trim[seg] = np.polyfit(x_data[fit_start_mod:fit_end_mod], y_data_scaled[seg][fit_start_mod:fit_end_mod],1)

                        # calculate the residuals
                        residuals_linear = x_data[fit_start_mod:fit_end_mod] * fit_trim[seg][0] + fit_trim[seg][1] - y_data_scaled[seg][fit_start_mod:fit_end_mod]

                        layers[seg]['fit']['line_found'] = True
                        layers[seg]['fit']['index'] = (fit_start_mod,fit_end_mod-1)
                        layers[seg]['fit']['interval'] = (self.data['extend'][self.keys['ts_key']][fit_start_mod],self.data['extend'][self.keys['ts_key']][fit_end_mod-1])
                        layers[seg]['fit']['fit_parameter'] = - fit_trim[seg][0]
                        layers[seg]['fit']['contact_point'] = dict()
                        layers[seg]['fit']['contact_point']['index'] = np.argmax(self.data['extend'][self.keys['ts_key']] < -fit_trim[seg][1]/fit_trim[seg][0])
                        layers[seg]['fit']['contact_point']['value'] = -fit_trim[seg][1]/fit_trim[seg][0]
                        layers[seg]['fit']['specifics'] = dict()
                        layers[seg]['fit']['specifics']['start_index'] = segments[seg]['index']['start']
                        layers[seg]['fit']['specifics']['full_index'] = (fit_start,fit_end-1)

                        layers[seg]['residuals'] = dict()
                        layers[seg]['residuals']['unit'] = 'nN'
                        layers[seg]['residuals']['mean_linear_fit'] = np.mean(np.absolute(residuals_linear))
                        #layers[seg]['residuals']['data_linear_fit'] = residuals_linear


                        ##part dependend on indenter
                        if indenter_characteristics['geometry'] == 'parabolic':

                            e_modul = np.power(abs(fit_trim[seg][0]),3/2) * (1 - poisson_ratio**2) * 3 / (4 * math.sqrt(indenter_characteristics['radius [nm]']))

                            x_fit = copy.deepcopy(x_data)
                            ind = -(x_fit - layers[seg]['fit']['contact_point']['value'])
                            ind[ind<0] = 0
                            y_fit[seg] = np.power(abs(fit_trim[seg][0]),3/2) * np.power(ind,3/2)

                            residuals = y_fit[seg][fit_start:fit_end] - y_data[fit_start:fit_end]

                            layers[seg]['residuals']['mean'] = np.mean(np.absolute(residuals))
                            #layers[seg]['residuals']['data'] = residuals



                        elif indenter_characteristics['geometry'] == 'conical':

                            e_modul = fit_trim[seg][0]**2 * (1 - poisson_ratio**2) * np.pi / (2 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                            x_fit = copy.deepcopy(x_data)
                            ind = -(x_fit - layers[seg]['fit']['contact_point']['value'])
                            ind[ind<0] = 0
                            y_fit[seg] = fit_trim[seg][0]**2 * ind**2

                            residuals = y_fit[seg][fit_start:fit_end] - y_data[fit_start:fit_end]

                            layers[seg]['residuals']['mean'] = np.mean(np.absolute(residuals))
                            #layers[seg]['residuals']['data'] = residuals


                        elif indenter_characteristics['geometry'] == 'four-sided pyramid':

                            e_modul = fit_trim[seg][0]**2 * (1 - poisson_ratio**2) / (0.7453 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

                            x_fit = copy.deepcopy(x_data)
                            ind = -(x_fit - layers[seg]['fit']['contact_point']['value'])
                            ind[ind<0] = 0
                            y_fit[seg] = fit_trim[seg][0]**2 * ind**2

                            residuals = y_fit[seg][fit_start:fit_end] - y_data[fit_start:fit_end]

                            layers[seg]['residuals']['mean'] = np.mean(np.absolute(residuals))
                            #layers[seg]['residuals']['data'] = residuals



                    else:

                        layers[seg]['fit']['line_found'] = False
                        layers[seg]['residuals'] = dict()

                        e_modul = np.nan


                else:

                    layers[seg]['segment'] = seg
                    layers[seg]['find_layer'] = False
                    layers[seg]['fit'] = {'line_found': False}
                    layers[seg]['residuals'] = dict()

                    e_modul = np.nan


            e_modul = e_modul * 10**9
            e_modul_unit = 'Pa'
            e_modul_factor = 1

            layers[seg]['young_modulus'] = {'value': e_modul, 'unit': e_modul_unit, 'factor': e_modul_factor}


        return y_fit, fit_trim



    def _get_elasticity_from_linear_hertz_fit(self, fit, poisson_ratio, indenter_characteristics):

        if indenter_characteristics['geometry'] == 'parabolic':

            E = np.power(abs(fit[0]),3/2) * (1 - poisson_ratio**2) * 3 / (4 * math.sqrt(indenter_characteristics['radius [nm]']))

        elif indenter_characteristics['geometry'] == 'conical':

            E = fit[0]**2 * (1 - poisson_ratio**2) * np.pi / (2 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

        elif indenter_characteristics['geometry'] == 'four-sided pyramid':

            E = fit[0]**2 * (1 - poisson_ratio**2) / (0.7453 * math.tan(indenter_characteristics['angle [grad]'] * np.pi / 180))

        return E




    def _get_scaled_data(self, data, indenter_characteristics):

        if indenter_characteristics['geometry'] == 'parabolic':

            data_scaled = np.power(np.abs(data),2/3)

        elif indenter_characteristics['geometry'] == 'conical':

            data_scaled = np.sqrt(np.abs(data))

        elif indenter_characteristics['geometry'] == 'four-sided pyramid':

            data_scaled = np.sqrt(np.abs(data))


        return data_scaled


class JPK_ForceFile():

    _distance_channel = ['head-height', 'height', 'capacitiveSensorHeight', 'measuredHeight', 'strainGaugeHeight', 'separation', 'smoothedCapacitiveSensorHeight', 'smoothedStrainGaugeHeight']

    def __init__(self):

        self.file_info = dict()

        self.dict_sort_files = dict()

        self.headers = dict()
        self.channels_info = dict()

        self.data = dict()

        self.segment_info = dict()
        self.channels = list()
        self.channel_units = dict()

        self.calibrations = dict()
        self.settings = dict()


        self.line_sep = str()




    def open_force_file(self, filename):

        self.import_data(filename)
        self.extract_general_information()
        self.extract_additional_properties()
        self.extract_decode_convert_data()



    def import_data(self, filename):
        """ Imports a .jpk-force file and unzips it """

        if filename.find('jpk-force') == -1:

            raise ValueError('ERROR! Given file is not a valid JPK force file!')


        else:

            self.file_info['filename'] = filename
            self.file_info['file_org'] = filename[filename.rfind(os.path.sep)+1:filename.rfind('.')]

            file = open(filename, 'rb')  # opens the file in binary mode
            binary_data = file.read()   # reads the binary data
            file.close()

            f = io.BytesIO(binary_data) # makes an BytesIO object
            zfp = zipfile.ZipFile(f, 'r')
            file_objects = zfp.infolist()

            #self.contents = list()
            #for fo in self.file_objects:
            #    self.contents.append(zfp.read(fo))
            # short and quicker version of the loop
            self.contents = [zfp.read(fo) for fo in file_objects]

            ret_dict = dict()
            file_list = [fo.filename.split('/') for fo in file_objects]

            # file_list = list()
            #for i in range(0, len(file_objects)):
            #    filename = file_objects[i].filename
            #    file_list.append(filename.split('/'))

            for i in range(0, len(file_list)):

                temp_dict = dict()
                temp_dict[file_list[i][-1]] = i

                for j in range(0, len(file_list[i])-1):

                    temp_dict = {file_list[i][-2-j]: temp_dict}


                ret_dict = JPK_ForceFile._merge_dict(ret_dict,temp_dict)


            self.dict_sort_files = ret_dict




    def extract_general_information(self):

        general_head = self.contents[self.dict_sort_files['header.properties']].decode()

        if general_head.find('\r\n') > 0:

            self.line_sep = '\r\n'

        else:

            self.line_sep = '\n'

        general_head = general_head.split(self.line_sep)
        shared_head = self.contents[self.dict_sort_files['shared-data']['header.properties']].decode().split(self.line_sep)
        #example_segment_head = self.contents[self.dict_sort_files['segments']['0']['segment-header.properties']].decode().split(self.line_sep)

        #self.dict_general_head = JPK_ForceFile._generate_dict(general_head)
        #self.dict_shared_head = JPK_ForceFile._generate_dict(shared_head)

        self.headers['general_properties'] = JPK_ForceFile._generate_dict(general_head)
        self.headers['shared_properties'] = JPK_ForceFile._generate_dict(shared_head)

        #self.pos_x = float(self.dict_general_head['force-scan-series']['header']['position']['x'])
        #self.pos_y = float(self.dict_general_head['force-scan-series']['header']['position']['y'])
        #self.pos_index = int(self.dict_general_head['force-scan-series']['header']['position-index'])

        # extract segments

        for i in range(0, int(self.headers['general_properties']['force-scan-series']['force-segments']['count'])):

            head_file = self.contents[self.dict_sort_files['segments'][str(i)]['segment-header.properties']].decode().split(self.line_sep)
            #dict_head_file = JPK_ForceFile._generate_dict(head_file)
            #self.dict_seg_header[i] = dict_head_file
            self.headers[i] = JPK_ForceFile._generate_dict(head_file)
            seg = self.headers[i]['force-segment-header']['name']['name']
            self.segment_info[i] = seg[0:seg.find('-spm')]


        self.channels = self.headers[0]['channels']['list'].split(' ')

        for i in range(0, int(self.headers['shared_properties']['lcd-infos']['count'])):

            self.channels_info[self.channels[i]] = dict()
            self.channels_info[self.channels[i]]['file'] = dict()

            if 'file' in self.headers[0]['channel'][self.channels[i]]['data']:

                has_file = True
                self.channels_info[self.channels[i]]['file']['has_file'] = has_file
                self.channels_info[self.channels[i]]['file']['filename'] = self.headers[0]['channel'][self.channels[i]]['data']['file']['name']

            else:

                has_file = False
                self.channels_info[self.channels[i]]['file']['has_file'] = has_file


            #self.channels_info[self.channels[i]]['channel'] = self.headers['shared_properties']['lcd-info'][str(i)]['channel']['name']
            self.channels_info[self.channels[i]]['unit'] = self.headers['shared_properties']['lcd-info'][str(i)]['unit']['unit']
            self.channels_info[self.channels[i]]['data_type'] = self.headers['shared_properties']['lcd-info'][str(i)]['type']

            self.channels_info[self.channels[i]]['conversions'] = dict()

            conversions = self.headers['shared_properties']['lcd-info'][str(i)]['conversion-set']['conversions']['list'].split(' ')

            if conversions[0] == '': # in case of an empty string make it to an empty list

                conversions = list()

            self.channels_info[self.channels[i]]['conversions_list'] = conversions

            unit = self.channels_info[self.channels[i]]['unit']

            for conv in conversions:

                self.channels_info[self.channels[i]]['conversions'][conv] = dict()
                defined = self.headers['shared_properties']['lcd-info'][str(i)]['conversion-set']['conversion'][conv]['defined']

                if defined == 'true':

                    self.channels_info[self.channels[i]]['conversions'][conv]['defined'] = True
                    self.channels_info[self.channels[i]]['conversions'][conv]['unit'] = self.headers['shared_properties']['lcd-info'][str(i)]['conversion-set']['conversion'][conv]['scaling']['unit']['unit']
                    self.channels_info[self.channels[i]]['conversions'][conv]['offset'] = float(self.headers['shared_properties']['lcd-info'][str(i)]['conversion-set']['conversion'][conv]['scaling']['offset'])
                    self.channels_info[self.channels[i]]['conversions'][conv]['multiplier'] = float(self.headers['shared_properties']['lcd-info'][str(i)]['conversion-set']['conversion'][conv]['scaling']['multiplier'])

                    unit = self.channels_info[self.channels[i]]['conversions'][conv]['unit']

                else:

                    self.channels_info[self.channels[i]]['conversions'][conv]['defined'] = False


            self.channels_info[self.channels[i]]['final_unit_after_conversions'] = unit

            if not self.channels_info[self.channels[i]]['conversions_list']: # when no conversions

                self.channels_info[self.channels[i]]['final_unit_after_conversions'] = self.channels_info[self.channels[i]]['unit']


            self.channels_info[self.channels[i]]['encoder'] = dict()

            if 'encoder' in self.headers['shared_properties']['lcd-info'][str(i)]:

                self.channels_info[self.channels[i]]['encoder']['defined'] = True
                self.channels_info[self.channels[i]]['encoder']['data_type'] = self.headers['shared_properties']['lcd-info'][str(i)]['encoder']['type']
                self.channels_info[self.channels[i]]['encoder']['offset'] = float(self.headers['shared_properties']['lcd-info'][str(i)]['encoder']['scaling']['offset'])
                self.channels_info[self.channels[i]]['encoder']['multiplier'] = float(self.headers['shared_properties']['lcd-info'][str(i)]['encoder']['scaling']['multiplier'])

            else:

                self.channels_info[self.channels[i]]['encoder']['defined'] = False




    def extract_additional_properties(self):

        if self.headers['shared_properties']['lcd-info'][str(self.channels.index('vDeflection'))]['conversion-set']['conversion']['force']['defined'] == 'true':

            self.calibrations['spring_constant_calibrated'] = True
            self.calibrations['spring_constant'] = float(self.headers['shared_properties']['lcd-info'][str(self.channels.index('vDeflection'))]['conversion-set']['conversion']['force']['scaling']['multiplier'])

        else:

            self.calibrations['spring_constant_calibrated'] = False
            self.calibrations['spring_constant'] = None

        if self.headers['shared_properties']['lcd-info'][str(self.channels.index('vDeflection'))]['conversion-set']['conversion']['distance']['defined'] == 'true':

            self.calibrations['sensitivity_calibrated'] = True
            self.calibrations['sensitivity'] = float(self.headers['shared_properties']['lcd-info'][str(self.channels.index('vDeflection'))]['conversion-set']['conversion']['distance']['scaling']['multiplier'])

        else:

            self.calibrations['sensitivity_calibrated'] = False
            self.calibrations['sensitivity'] = None


        self.calibrations['height_multiplier'] = float(self.headers['shared_properties']['lcd-info'][str(self.channels.index('height'))]['conversion-set']['conversion']['calibrated']['scaling']['multiplier'])
        self.calibrations['height_offset'] = float(self.headers['shared_properties']['lcd-info'][str(self.channels.index('height'))]['conversion-set']['conversion']['calibrated']['scaling']['offset'])

        setpoint = float(self.headers['general_properties']['force-scan-series']['header']['force-settings']['relative-setpoint'])
        self.settings['setpoint'] = dict()
        self.settings['setpoint']['relative (V)'] = setpoint

        for conv in self.channels_info['vDeflection']['conversions_list']:

            if self.channels_info['vDeflection']['conversions'][conv]['defined']:

                conv_off = self.channels_info['vDeflection']['conversions'][conv]['offset']
                conv_mult = self.channels_info['vDeflection']['conversions'][conv]['multiplier']

                setpoint = setpoint * conv_mult + conv_off

        self.settings['setpoint']['force (N)'] = setpoint

        self.settings['duration'] = dict()
        self.settings['duration']['extend'] = float(self.headers['general_properties']['force-scan-series']['header']['force-settings']['extend-scan-time'])
        self.settings['duration']['retract'] = float(self.headers['general_properties']['force-scan-series']['header']['force-settings']['retract-scan-time'])

        self.settings['samples'] = dict()
        #self.settings['samples']['extend'] = int(self.headers['general_properties']['force-scan-series']['header']['force-settings']['extend-k-length'])
        #self.settings['samples']['retract'] = int(self.headers['general_properties']['force-scan-series']['header']['force-settings']['retract-k-length'])

        self.settings['samples_set'] = dict()
        self.settings['samples_set']['extend'] = int(self.headers['general_properties']['force-scan-series']['header']['force-settings']['extend-k-length'])
        self.settings['samples_set']['retract'] = int(self.headers['general_properties']['force-scan-series']['header']['force-settings']['retract-k-length'])


        self.settings['sample_rate'] = dict()
        self.settings['sample_rate']['extend'] = int(self.headers['general_properties']['force-scan-series']['header']['force-settings']['extend-k-length']) / self.settings['duration']['extend']
        self.settings['sample_rate']['retract'] = int(self.headers['general_properties']['force-scan-series']['header']['force-settings']['retract-k-length']) / self.settings['duration']['retract']

        self.settings['z_pos'] = dict()
        self.settings['z_pos']['relative_z_start'] = float(self.headers['general_properties']['force-scan-series']['header']['force-settings']['relative-z-start'])
        self.settings['z_pos']['relative_z_end'] = float(self.headers['general_properties']['force-scan-series']['header']['force-settings']['relative-z-end'])

        self.settings['position'] = dict()
        self.settings['position']['index'] = int(self.headers['general_properties']['force-scan-series']['header']['position-index'])
        self.settings['position']['x'] = float(self.headers['general_properties']['force-scan-series']['header']['position']['x'])
        self.settings['position']['y'] = float(self.headers['general_properties']['force-scan-series']['header']['position']['y'])

#        self.settings['start_option'] = dict() #remove for batch "light version"
#        self.settings['start_option']['type'] = self.headers['general_properties']['force-scan-series']['header']['force-settings']['start-option']['type']
#        self.settings['start_option']['height'] = float(self.headers['general_properties']['force-scan-series']['header']['force-settings']['start-option']['height'])
#        self.settings['start_option']['velocity'] = float(self.headers['general_properties']['force-scan-series']['header']['force-settings']['start-option']['velocity'])

        self.settings['closed-loop'] = self.headers['general_properties']['force-scan-series']['header']['force-settings']['closed-loop']

        time_stamp = self.headers[0]['force-segment-header']['time-stamp']

        self.file_info['date'] = time_stamp[0:10]
        self.file_info['time'] = time_stamp[11:13] + time_stamp[14:17] + time_stamp[18:25]





    def extract_decode_convert_data(self):


        for seg_ind in self.segment_info.keys():

            self.data[self.segment_info[seg_ind]] = dict()

            for channel in self.channels:

                self.channel_units[channel] = self.channels_info[channel]['final_unit_after_conversions']

                if self.channels_info[channel]['file']['has_file']:

                    #self.data[seg][channel] = np.empty(self.settings['samples'][seg], dtype = np.float64)

                    point_length, type_code = DATA_TYPES[self.channels_info[channel]['data_type']]
                    raw_data = self.contents[self.dict_sort_files['segments'][str(seg_ind)]['channels'][channel + '.dat']]

                    data = np.zeros(int(len(raw_data)/point_length)) #number of samples is not reliable

                    for n in range(int(len(raw_data)/point_length)):

                        data[n] = unpack('!'+type_code, raw_data[n * point_length:(n+1) * point_length])[0]

                    #print(int(len(raw_data)/point_length))
                    #enc_off = self.channels_info[channel]['encoder']['offset']
                    #enc_mult = self.channels_info[channel]['encoder']['multiplier']
                    # 1. apply encoder
                    if self.channels_info[channel]['encoder']['defined']:

                        data = data * self.channels_info[channel]['encoder']['multiplier'] + self.channels_info[channel]['encoder']['offset']
                        #data = np.add(np.multiply(data,self.channels_info[channel]['encoder']['multiplier']),self.channels_info[channel]['encoder']['offset'])
                    # 2. apply conversions

                    for conv in self.channels_info[channel]['conversions_list']:

                        if self.channels_info[channel]['conversions'][conv]['defined']:

                            #conv_off = self.channels_info[channel]['conversions'][conv]['offset']
                            #conv_mult = self.channels_info[channel]['conversions'][conv]['multiplier']
                            data = data * self.channels_info[channel]['conversions'][conv]['multiplier'] + self.channels_info[channel]['conversions'][conv]['offset']
                            #data = np.add(np.multiply(data,self.channels_info[channel]['conversions'][conv]['multiplier']),self.channels_info[channel]['conversions'][conv]['offset'])


                    self.data[self.segment_info[seg_ind]][channel] = data


                self.settings['samples'][self.segment_info[seg_ind]] = int(len(raw_data)/point_length)







    def _merge_dict(dict1,dict2):

        out1 = dict()
        out2 = dict()
        out1 = dict1.copy()
        out2 = dict2.copy()

        for key, value in dict1.items():

            if key in dict2:

               if type(dict2[key]) is dict:

                   out2[key] = JPK_ForceFile._merge_dict(value, dict2[key])

        out1.update(out2)

        return out1




    def _generate_dict(data):

        ret_dict = dict()
        data_mod = [data[i].split('=') for i in range(0, len(data))]
#        data_mod = list()
#        for i in range(0, len(data)):
#            data_mod.append(data[i].split('='))


        for i in range(0, len(data)):

            data_mod[i][0] = data_mod[i][0].split('.')


        for i in range(0, len(data)):

            temp_dict = dict()

            if len(data_mod[i]) == 2:

                temp_dict[data_mod[i][0][-1]] = data_mod[i][1]

            else:

                temp_dict[data_mod[i][0][-1]] = str()


            for j in range(0, len(data_mod[i][0])-1):

                temp_dict = {data_mod[i][0][-2-j]: temp_dict}



            ret_dict = JPK_ForceFile._merge_dict(ret_dict,temp_dict)


        return ret_dict






class JPK_QIFile():

    _distance_channel = ['head-height', 'height', 'capacitiveSensorHeight', 'measuredHeight', 'strainGaugeHeight', 'separation', 'smoothedCapacitiveSensorHeight', 'smoothedStrainGaugeHeight']

    def __init__(self):

        self.file_info = dict()

        self.dict_sort_files = dict()
        self.contents = list()
        self.headers = dict()
        self.channels_info = dict()

#        self.data = dict()

        self.segment_info = dict()
        self.channels = list()
        self.channel_units = dict()

        self.calibrations = dict()
        self.settings = dict()


        self.line_sep = str()









    def open_qi_file(self, filename):

        self.import_data(filename)
        self.extract_general_information()
        self.extract_additional_properties()


        print('\nSuccessfully loaded jpk-qi-data: ', self.file_info['filename'])
















#    def import_data_old(self, filename):
#        """ Imports a .jpk-force-map file and unzips it """
#
#        if filename.find('jpk-qi-data') == -1:
#
#            raise ValueError('ERROR! Given file is not a JPK QI file!')
#
#        else:
#
#            self.file_info['filename'] = filename
#            self.file_info['file_org'] = filename[filename.rfind('\\')+1:filename.rfind('.')]
#
#            print('Import jpk-force-map file: ' + self.file_info['filename'])
#            print('Opening file...')
#
#            file = open(filename, 'rb') # opens the file in binary mode
#            binary_data = file.read() # reads the data into the variable data
#            file.close()
#
#            print('Binary data read!')
#            f = io.BytesIO(binary_data) # makes an BytesIO object
#
#            zfp = zipfile.ZipFile(f, 'r')
#
#            file_objects = zfp.infolist()
#            self.contents = [zfp.read(fo) for fo in file_objects]

#            start = time.time()
#            ret_dict = dict()
#            file_list = [fo.filename.split('/') for fo in file_objects]
#
#            sys.stdout.write('\rUnpack Individual Force-Distance Curves: %.2f%% <%d/%d>' %(0, 0, len(file_list)))
#
#            for i in range(0, len(file_list)):
#
#                temp_dict = dict()
#                temp_dict[file_list[i][-1]] = i
#
#                for j in range(0, len(file_list[i])-1):
#
#                    temp_dict = {file_list[i][-2-j]: temp_dict}
#
#
#                ret_dict = JPK_QIFile._merge_dict(ret_dict,temp_dict)
#
#                sys.stdout.write('\rUnpack Individual Force-Distance Curves: %.2f%% <%d/%d>' %((i+1)/len(file_list)*100, i+1, len(file_list)))
#
#
#            self.dict_sort_files = ret_dict
#            print('\nTime elapsed - OLD:',time.time() - start, 's\n')




    def import_data(self, filename):
        """ Imports a .jpk-force-map file and unzips it """

        if filename.find('jpk-qi-data') == -1:

            raise ValueError('ERROR! Given file is not a JPK QI file!')

        else:

            self.file_info['filename'] = os.path.normpath(filename)
            self.file_info['file_org'] = self.file_info['filename'][self.file_info['filename'].rfind(os.path.sep)+1:self.file_info['filename'].rfind('.')]

            print('Import jpk-force-map file: ' + self.file_info['filename'])
            print('Opening file...')

            file = open(filename, 'rb') # opens the file in binary mode
            binary_data = file.read() # reads the data into the variable data
            file.close()

            print('Binary data read!')
            f = io.BytesIO(binary_data) # makes an BytesIO object

            zfp = zipfile.ZipFile(f, 'r')

            file_objects = zfp.infolist()
            self.contents = [zfp.read(fo) for fo in file_objects]

            ret_dict = dict()

            file_list = [fo.filename.split('/') for fo in file_objects]
            #self.file_list = file_list


            sys.stdout.write('\rUnpack Individual Files: %.2f%% <%d/%d>' %(0, 0, len(file_list)))

            for i in range(0, len(file_list)):

                pt_ret_dict = ret_dict     # pointer to the dictonary, will be reassigned to current nested dictonary level

                for j in range(len(file_list[i])):

                    if file_list[i][j] in pt_ret_dict.keys():

                        pt_ret_dict = pt_ret_dict[file_list[i][j]]

                    elif j + 1 == len(file_list[i]):

                        pt_ret_dict[file_list[i][j]] = i

                    else:

                        pt_ret_dict[file_list[i][j]] = dict()
                        pt_ret_dict = pt_ret_dict[file_list[i][j]]



                sys.stdout.write('\rUnpack Individual Files: %.2f%% <%d/%d>' %((i+1)/len(file_list)*100, i+1, len(file_list)))

            self.dict_sort_files = ret_dict
            print('\n---Done---')




    def extract_general_information(self):

        general_head = self.contents[self.dict_sort_files['header.properties']].decode()

        if general_head.find('\r\n') > 0:

            self.line_sep = '\r\n'

        else:

            self.line_sep = '\n'


        general_head = general_head.split(self.line_sep)
        shared_head = self.contents[self.dict_sort_files['shared-data']['header.properties']].decode().split(self.line_sep)
        #self.example_segment_head = self.contents[self.dict_sort_files['index']['0']['segments']['0']['segment-header.properties']].decode().split(self.line_sep)
        #self.dict_example_segment_head = self.generate_dict(self.example_segment_head)
        self.headers['general_properties'] = JPK_QIFile._generate_dict(general_head)
        self.headers['shared_properties'] = JPK_QIFile._generate_dict(shared_head)

        self.settings['fd_indices'] = dict()
        self.settings['fd_indices']['min'] = int(self.headers['general_properties']['quantitative-imaging-map']['indexes']['min'])
        self.settings['fd_indices']['max'] = int(self.headers['general_properties']['quantitative-imaging-map']['indexes']['max'])
        self.settings['fd_indices']['total'] = self.settings['fd_indices']['max'] - self.settings['fd_indices']['min'] + 1
        self.settings['fd_indices']['list'] = np.array([i for i in range(self.settings['fd_indices']['min'], self.settings['fd_indices']['max'] +1)], dtype = np.int32)

        if self.headers['general_properties']['quantitative-imaging-map']['position-pattern']['back-and-forth'] == 'true':

            self.settings['fd_indices']['back-and-forth'] = True

        else:

            self.settings['fd_indices']['back-and-forth'] = False

        self.settings['grid'] = dict()
        self.settings['grid']['x'] = int(self.headers['general_properties']['quantitative-imaging-map']['position-pattern']['grid']['ilength'])
        self.settings['grid']['y'] = int(self.headers['general_properties']['quantitative-imaging-map']['position-pattern']['grid']['ilength'])
        self.settings['grid']['u-length'] = float(self.headers['general_properties']['quantitative-imaging-map']['position-pattern']['grid']['ulength'])
        self.settings['grid']['v-length'] = float(self.headers['general_properties']['quantitative-imaging-map']['position-pattern']['grid']['vlength'])
        self.settings['grid']['x-center'] = float(self.headers['general_properties']['quantitative-imaging-map']['position-pattern']['grid']['xcenter'])
        self.settings['grid']['y-center'] = float(self.headers['general_properties']['quantitative-imaging-map']['position-pattern']['grid']['ycenter'])
        self.settings['grid']['unit'] = self.headers['general_properties']['quantitative-imaging-map']['position-pattern']['grid']['unit']['unit']


        fd_ind = list(self.dict_sort_files['index'].keys())
        fd_ind.remove('')
        sys.stdout.write('\rCreate Header: %.2f%% <%d/%d>' %(0, 0, len(fd_ind)))

        # extract headers for all the individual fd-curves
        for ind in fd_ind:

            self.headers[ind] = dict()

            head_file = self.contents[self.dict_sort_files['index'][str(ind)]['header.properties']].decode().split(self.line_sep)
            self.headers[ind]['header.properties'] = JPK_QIFile._generate_dict(head_file)

            self.headers[ind]['segments'] = dict()

            for seg in self.dict_sort_files['index'][ind]['segments'].keys():

                if bool(seg):

                    head_file = self.contents[self.dict_sort_files['index'][ind]['segments'][seg]['segment-header.properties']].decode().split(self.line_sep)
                    self.headers[ind]['segments'][seg] = JPK_QIFile._generate_dict(head_file)

            sys.stdout.write('\rCreate Header: %.2f%% <%d/%d>' %((int(ind)+1)/len(fd_ind)*100, int(ind)+1, len(fd_ind)))



        for i in range(int(self.headers['shared_properties']['force-segment-header-infos']['count'])):

#            ind = 0
#            found_segment = False
#
#            while not found_segment:
#
#                if str(i) in self.dict_sort_files['index'][str(ind)]['segments'].keys():
#
#                    found_segment = True
#
#                else:
#
#                    ind += 1


#            head_file = self.contents[self.dict_sort_files['index'][str(ind)]['segments'][str(i)]['segment-header.properties']].decode().split(self.line_sep)
#            self.headers[i] = JPK_QIFile._generate_dict(head_file)
            self.segment_info[i] = self.headers['shared_properties']['force-segment-header-info'][str(i)]['settings']['style']


        # extract channels
        self.channels = self.headers['0']['segments']['0']['channels']['list'].split(' ')


        for i in range(0, int(self.headers['shared_properties']['lcd-infos']['count'])):

            self.channels_info[self.channels[i]] = dict()
            self.channels_info[self.channels[i]]['file'] = dict()

            if 'file' in self.headers['0']['segments']['0']['channel'][self.channels[i]]['data']:

                has_file = True
                self.channels_info[self.channels[i]]['file']['has_file'] = has_file
                self.channels_info[self.channels[i]]['file']['filename'] = self.headers['0']['segments']['0']['channel'][self.channels[i]]['data']['file']['name']

            else:

                has_file = False
                self.channels_info[self.channels[i]]['file']['has_file'] = has_file


            #self.channels_info[self.channels[i]]['channel'] = self.headers['shared_properties']['lcd-info'][str(i)]['channel']['name']
            self.channels_info[self.channels[i]]['unit'] = self.headers['shared_properties']['lcd-info'][str(i)]['unit']['unit']
            self.channels_info[self.channels[i]]['data_type'] = self.headers['shared_properties']['lcd-info'][str(i)]['type']

            self.channels_info[self.channels[i]]['conversions'] = dict()

            conversions = self.headers['shared_properties']['lcd-info'][str(i)]['conversion-set']['conversions']['list'].split(' ')

            if conversions[0] == '': # in case of an empty string make it to an empty list

                conversions = list()

            self.channels_info[self.channels[i]]['conversions_list'] = conversions

            unit = self.channels_info[self.channels[i]]['unit']

            for conv in conversions:

                self.channels_info[self.channels[i]]['conversions'][conv] = dict()
                defined = self.headers['shared_properties']['lcd-info'][str(i)]['conversion-set']['conversion'][conv]['defined']

                if defined == 'true':

                    self.channels_info[self.channels[i]]['conversions'][conv]['defined'] = True
                    self.channels_info[self.channels[i]]['conversions'][conv]['unit'] = self.headers['shared_properties']['lcd-info'][str(i)]['conversion-set']['conversion'][conv]['scaling']['unit']['unit']
                    self.channels_info[self.channels[i]]['conversions'][conv]['offset'] = float(self.headers['shared_properties']['lcd-info'][str(i)]['conversion-set']['conversion'][conv]['scaling']['offset'])
                    self.channels_info[self.channels[i]]['conversions'][conv]['multiplier'] = float(self.headers['shared_properties']['lcd-info'][str(i)]['conversion-set']['conversion'][conv]['scaling']['multiplier'])

                    unit = self.channels_info[self.channels[i]]['conversions'][conv]['unit']

                else:

                    self.channels_info[self.channels[i]]['conversions'][conv]['defined'] = False


            self.channels_info[self.channels[i]]['final_unit_after_conversions'] = unit

            if not self.channels_info[self.channels[i]]['conversions_list']: # when no conversions

                self.channels_info[self.channels[i]]['final_unit_after_conversions'] = self.channels_info[self.channels[i]]['unit']


            self.channels_info[self.channels[i]]['encoder'] = dict()

            if 'encoder' in self.headers['shared_properties']['lcd-info'][str(i)]:

                self.channels_info[self.channels[i]]['encoder']['defined'] = True
                self.channels_info[self.channels[i]]['encoder']['data_type'] = self.headers['shared_properties']['lcd-info'][str(i)]['encoder']['type']
                self.channels_info[self.channels[i]]['encoder']['offset'] = float(self.headers['shared_properties']['lcd-info'][str(i)]['encoder']['scaling']['offset'])
                self.channels_info[self.channels[i]]['encoder']['multiplier'] = float(self.headers['shared_properties']['lcd-info'][str(i)]['encoder']['scaling']['multiplier'])

            else:

                self.channels_info[self.channels[i]]['encoder']['defined'] = False




    def extract_additional_properties(self):

        for channel in self.channels:

            self.channel_units[channel] = self.channels_info[channel]['final_unit_after_conversions']



        if self.headers['shared_properties']['lcd-info'][str(self.channels.index('vDeflection'))]['conversion-set']['conversion']['force']['defined'] == 'true':

            self.calibrations['spring_constant_calibrated'] = True
            self.calibrations['spring_constant'] = float(self.headers['shared_properties']['lcd-info'][str(self.channels.index('vDeflection'))]['conversion-set']['conversion']['force']['scaling']['multiplier'])

        else:

            self.calibrations['spring_constant_calibrated'] = False
            self.calibrations['spring_constant'] = 1

        if self.headers['shared_properties']['lcd-info'][str(self.channels.index('vDeflection'))]['conversion-set']['conversion']['distance']['defined'] == 'true':

            self.calibrations['sensitivity_calibrated'] = True
            self.calibrations['sensitivity'] = float(self.headers['shared_properties']['lcd-info'][str(self.channels.index('vDeflection'))]['conversion-set']['conversion']['distance']['scaling']['multiplier'])

        else:

            self.calibrations['sensitivity_calibrated'] = False
            self.calibrations['sensitivity'] = 1


        self.calibrations['height_multiplier'] = float(self.headers['shared_properties']['lcd-info'][str(self.channels.index('height'))]['conversion-set']['conversion']['calibrated']['scaling']['multiplier'])
        self.calibrations['height_offset'] = float(self.headers['shared_properties']['lcd-info'][str(self.channels.index('height'))]['conversion-set']['conversion']['calibrated']['scaling']['offset'])

        setpoint = float(self.headers['general_properties']['quantitative-imaging-map']['settings']['force-settings']['relative-setpoint'])
        self.settings['setpoint'] = dict()
        self.settings['setpoint']['relative (V)'] = setpoint

        for conv in self.channels_info['vDeflection']['conversions_list']:

            if self.channels_info['vDeflection']['conversions'][conv]['defined']:

                conv_off = self.channels_info['vDeflection']['conversions'][conv]['offset']
                conv_mult = self.channels_info['vDeflection']['conversions'][conv]['multiplier']

                setpoint = setpoint * conv_mult + conv_off

        self.settings['setpoint']['force (N)'] = setpoint


        self.settings['samples'] = dict()
        self.settings['samples']['extend'] = int(self.headers['general_properties']['quantitative-imaging-map']['settings']['force-settings']['extend']['num-points'])
        self.settings['samples']['retract'] = int(self.headers['general_properties']['quantitative-imaging-map']['settings']['force-settings']['retract']['num-points'])

        self.settings['z-length'] = dict()
        self.settings['z-length']['extend'] = float(self.headers['general_properties']['quantitative-imaging-map']['settings']['force-settings']['extend']['z-start']) - float(self.headers['general_properties']['quantitative-imaging-map']['settings']['force-settings']['extend']['z-end'])
        self.settings['z-length']['retract'] = float(self.headers['general_properties']['quantitative-imaging-map']['settings']['force-settings']['retract']['z-start']) - float(self.headers['general_properties']['quantitative-imaging-map']['settings']['force-settings']['retract']['z-end'])


        time_stamp = self.headers['general_properties']['quantitative-imaging-map']['start-time']

        self.file_info['date'] = time_stamp[0:10]
        self.file_info['time'] = time_stamp[11:13] + time_stamp[14:17] + time_stamp[18:25]




    def _merge_dict(dict1,dict2):

        out1 = dict()
        out2 = dict()
        out1 = dict1.copy()
        out2 = dict2.copy()

        for key, value in dict1.items():

            if key in dict2:

               if type(dict2[key]) is dict:

                   out2[key] = JPK_QIFile._merge_dict(value, dict2[key])

        out1.update(out2)

        return out1




    def _generate_dict(data):

        ret_dict = dict()
        data_mod = [data[i].split('=') for i in range(0, len(data))]

        for i in range(0, len(data)):

            data_mod[i][0] = data_mod[i][0].split('.')


        for i in range(0, len(data)):

            temp_dict = dict()

            if len(data_mod[i]) == 2:

                temp_dict[data_mod[i][0][-1]] = data_mod[i][1]

            else:

                temp_dict[data_mod[i][0][-1]] = str()


            for j in range(0, len(data_mod[i][0])-1):

                temp_dict = {data_mod[i][0][-2-j]: temp_dict}



            ret_dict = JPK_QIFile._merge_dict(ret_dict,temp_dict)


        return ret_dict




















class JPKChannelConversion():

    _internal = ['height',
                 'vDeflection',
                 'capacitiveSensorHeight',
                 'strainGaugeHeight',
                 'time',
                 'seriesTime',
                 'verticalTipPosition',
                 'smoothedCapacitiveSensorHeight',
                 'smoothedStrainGaugeHeight',
                 'separation']

    _external = ['Height',
                 'Vertical Deflection',
                 'Height (measured)',
                 'Head Height (measured)',
                 'Segment Time',
                 'Series Time',
                 'Vertical Tip Position',
                 'Height (measured & smoothed)',
                 'Head Height (measured & smoothed)',
                 'Tip-Sample Separation']

    _internal_to_external = {'height':'Height',
                             'vDeflection':'Vertical Deflection',
                             'capacitiveSensorHeight':'Height (measured)',
                             'strainGaugeHeight':'Head Height (measured)',
                             'time':'Segment Time',
                             'seriesTime':'Series Time',
                             'verticalTipPosition':'Vertical Tip Position',
                             'smoothedCapacitiveSensorHeight':'Height (measured & smoothed)',
                             'smoothedStrainGaugeHeight':'Head Height (measured & smoothed)',
                             'separation':'Tip-Sample Separation'}

    _external_to_internal = {'Height':'height',
                             'Vertical Deflection':'vDeflection',
                             'Height (measured)':'capacitiveSensorHeight',
                             'Head Height (measured)':'strainGaugeHeight',
                             'Segment Time':'time',
                             'Series Time':'seriesTime',
                             'Vertical Tip Position':'verticalTipPosition',
                             'Height (measured & smoothed)':'smoothedCapacitiveSensorHeight',
                             'Head Height (measured & smoothed)':'smoothedStrainGaugeHeight',
                             'Tip-Sample Separation':'separation'}


    def get_external(self, internal):

        if internal in JPKChannelConversion._internal:

            return JPKChannelConversion._internal_to_external[internal]

        else:

            raise ValueError ('ERROR: Given name is not a valid raw data channel.')



    def get_internal(self, external):

        if external in JPKChannelConversion._external:

            return JPKChannelConversion._external_to_internal[external]

        else:

            raise ValueError ('ERROR: Given name has no corresponding raw data channel.')




class Conversion_List_Spherical_Indenter_Hertz():

    def __init__(self, radius, decimals, max_indentation):

        self.radius = radius
        self.decimals = decimals
        self.max_indentation = max_indentation

        self.end_indentation_change = float()

        self.conversion_dict = dict()

        for i in range(-10 * 10**self.decimals, self.max_indentation * 10**self.decimals + 1):

            self.conversion_dict[i/(10**self.decimals)] = fsolve(Conversion_List_Spherical_Indenter_Hertz._radius_contact_circle, x0 = 0.1, args = (self.radius, i/(10**self.decimals)), factor = 100)[0]

        max_ind = np.argmax(list(self.conversion_dict.values()))

        for i in range(max_ind+1,self.max_indentation * 10 ** self.decimals + 1):

            self.conversion_dict[i/(self.decimals*10)] = self.conversion_dict[max_ind/(10**self.decimals)]

        self.conversion_dict[0] = 0
        self.end_indentation_change = max_ind/(self.decimals*10)
        self.end_indentation_change_index = max_ind

    def convert(self, indentation):

        return self.conversion_dict[np.round(indentation, decimals = self.decimals)]


    def convert_np_array(self, indentation):

        ret = np.array(indentation)
        ret[ret<0] = 0

        for i in range(len(ret)):

            ret[i] = self.convert(ret[i])

        return ret



    def _radius_contact_circle(x, R, ind):

        return x/2 * np.log((R+x)/(R-x)) - ind






class QI_GUI(tkinter.Tk):

    def __init__(self):

        self.qi_object = QIMap()
        tkinter.Tk.__init__(self)
        self.title('Force-Distance Curve Preview')
        self.safe_closing = True
        #self.root = tkinter.Tk.__init__(self)
        #self.root: When using class inheritance that is NoneType, so passing self.root in that case to another class won't allow to use it.
        #QI_FD_Preview is an instance of the tkinter.Tk class
        #self.root = tkinter.Tk() # use if i want it to be a member and not inheritance

        self.settings = dict()
        #self.settings['directory'] = {'open': 'D:\\Christian\\Data\\2020-02-11\\sample3_tip7_SNL-C_AR3110', 'save': 'C:\\'}
        self.settings['directory'] = {'open': 'C:\\', 'save': 'C:\\'}

        self.dimensions = dict()
        self.frames = dict()
        self.menu = dict()

        self.graphs = {'qi_map': {'figure': None, 'axes': None, 'image': None, 'colorbar': None, 'axes_colorbar': None, 'marker': None}, 'fd_curve': {'figure': None, 'axes': None}}

        self.backend = dict()
        self.toolbar = dict()
        self.mpl_canvas = dict()
        self.select = None

        self.color_scheme = _Helper_Functions_GUI._set_color_options()

        self.entry_var = {'qi_map': {'colormap': tkinter.StringVar(None), 'limits': {'vmin': tkinter.StringVar(None), 'vmax': tkinter.StringVar(None)}}, 'fd_curve':{'retract_plot': tkinter.BooleanVar(None, True)}}
        self.additional_settings_graphs = dict()


        self._create_frames()
        self._create_canvas()
        self._create_frame_content()



        self.control_parameter = dict()
        self.control_parameter['file_imported'] = False
        self.control_parameter['directory_set'] = {'open': False, 'save': False}

        self.control_parameter['apply_corrections'] = tkinter.BooleanVar(None, False)
        self.control_parameter['correction_window'] = False
        self.control_parameter['baseline_correction_lines'] = False
        self.control_parameter['modify_cantilever_calibration'] = {'sensitivity': tkinter.BooleanVar(None, False), 'spring_constant': tkinter.BooleanVar(None, False)}

        self.control_parameter['selection_tool_window'] = False

        self.control_parameter['apparent_layer_thickness_window'] = False
        self.control_parameter['multi_layer_segments_window'] = False
        self.control_parameter['standard_hertz_window'] = False
        self.control_parameter['breakthrough_events_window'] = False


        self.corrections_window = SetCorrectionsWindow(self) #or the complete object and split it up later
        self.cantilever_calibration_window = ModifyCantileverCalibrationWindow(self)

        self.selection_tool_window = SelectionToolWindow(self)

        self.apparent_layer_thickness_window = ApparentLayerThicknessWindow(self)
        self.standard_hertz_window = StandardHertzWindow(self)
        self.multi_layer_segments_window = MultiLayerLinearizedHertzWindow(self)
        self.breakthrough_events_window = BreakthroughEventsWindow(self)

        self._create_menues()


        self.keys_pressed = dict()
        self.keys_pressed['Control_L'] = False
        self.keys_pressed['Shift_L'] = False


        self.bind('<Control_L>', self._control_press)
        self.bind('<Shift_L>', self._shift_press)
        self.bind('<KeyRelease>', self._key_released)
        # bound in _create_plot_qi_canvas
        # self.bind('<Shift-Left>', self._left_press)
        # self.bind('<Shift-Right>', self._right_press)
        # self.bind('<Shift-Up>', self._up_press)
        # self.bind('<Shift-Down>', self._down_press)


        self.protocol("WM_DELETE_WINDOW", self.on_closing)





        self.mainloop()




    def on_closing(self):

        if self.safe_closing:

            #print(self.winfo_reqwidth(),self.winfo_reqheight())
            #print(self.frames['master'].winfo_width(),self.frames['master'].winfo_height())
            self.destroy()

        else:

            self.bell()
            tkinter.messagebox.showinfo(title = 'Why so impatient! Let me finish first!', message = 'Cannot close Window. Something is still running!')




    def onclick(self,event):

        if self.keys_pressed['Shift_L'] and event.button == 1:
        #if event.button == 1:
            if event.xdata is not None:

                x = int(event.xdata/(self.qi_object.settings['grid']['u-length']*10**6) * self.qi_object.settings['grid']['x'])
                y = int(event.ydata/(self.qi_object.settings['grid']['v-length']*10**6) * self.qi_object.settings['grid']['y'])

                self.graphs['qi_map']['marker'].pop(0).remove()
                self.graphs['qi_map']['marker'] = self.graphs['qi_map']['axes'].plot((x+0.5)/self.qi_object.settings['grid']['x']*self.qi_object.settings['grid']['u-length']*10**6,(y+0.5)/self.qi_object.settings['grid']['y']*self.qi_object.settings['grid']['v-length']*10**6, marker = 'x', markeredgecolor = 'black', markersize = 7)
                self.backend['qi_map'].draw()

                self.qi_object.open_sample_fd_curve(x + self.qi_object.settings['grid']['y']*y)
                #self.create_fd_plot()
                self.create_fd_plot()



    def create_fd_plot(self):

        self.graphs['fd_curve']['axes'].clear()

        if isinstance(self.cantilever_calibration_window.enter_window_app, tkinter.Toplevel): #checks whether cantilever calibration window is open

            self.qi_object.sample_fd_curve['object'].reset_data()

            self.qi_object.sample_fd_curve['object'].set_sensitivity(self.cantilever_calibration_window.sensitivity['new_tentative'].get()/1e9)
            self.qi_object.sample_fd_curve['object'].set_spring_constant(self.cantilever_calibration_window.spring_constant['new_tentative'].get())

        self._plot_data()




    def update_plot(self):

        self.graphs['fd_curve']['axes'].clear()
        self.qi_object.sample_fd_curve['object'].reset_data()

        if isinstance(self.cantilever_calibration_window.enter_window_app, tkinter.Toplevel): #checks whether cantilever calibration window is open

            self.qi_object.sample_fd_curve['object'].set_sensitivity(self.cantilever_calibration_window.sensitivity['new_tentative'].get()/1e9)
            self.qi_object.sample_fd_curve['object'].set_spring_constant(self.cantilever_calibration_window.spring_constant['new_tentative'].get())

        else:

            if self.control_parameter['modify_cantilever_calibration']['sensitivity'].get():
                self.qi_object.sample_fd_curve['object'].set_sensitivity(self.cantilever_calibration_window.sensitivity['new_final'].get()/1e9)
            if self.control_parameter['modify_cantilever_calibration']['spring_constant'].get():
                self.qi_object.sample_fd_curve['object'].set_spring_constant(self.cantilever_calibration_window.spring_constant['new_final'].get())

            #print(self.qi_object.sample_fd_curve['object'].calibrations['sensitivity'])

        self._plot_data()




    def _plot_data(self):

        x_key = 'x_key'

        if self.control_parameter['apply_corrections'].get():

            self.qi_object.sample_fd_curve['object'].correct_data(
                    force_unit = self.corrections_window.corrections['force_unit'].get(),
                    distance_unit = self.corrections_window.corrections['distance_unit'].get(),
                    baseline_correction = {'method': self.corrections_window.corrections['baseline_correction']['method'].get(), 'reference': self.corrections_window.corrections['baseline_correction']['reference'].get(),'frac_data': (self.corrections_window.corrections['baseline_correction']['frac_data']['min'].get()/100, self.corrections_window.corrections['baseline_correction']['frac_data']['max'].get()/100)},
                    distance_correction = {'method': self.corrections_window.corrections['distance_correction']['method'].get(), 'reference': self.corrections_window.corrections['distance_correction']['reference'].get(), 'smooth_applied': self.corrections_window.corrections['distance_correction']['smooth_applied'].get(), 'smooth_length': self.corrections_window.corrections['distance_correction']['smooth_length'].get(), 'fit_length': self.corrections_window.corrections['distance_correction']['length_fit'].get()},
                    get_tip_sample_separation = self.corrections_window.corrections['get_tip_sample_separation'].get(),
                    )


            if self.corrections_window.corrections['get_tip_sample_separation'].get():

                x_key = 'ts_key'



        if self.qi_object.sample_fd_curve['object'].control_variables['allow_analysis'] and self.multi_layer_segments_window.settings['visualization']['show_preview'].get():
            try:
                self.qi_object.sample_fd_curve['object'].fit_multi_layer_segments(indenter_characteristics = self.multi_layer_segments_window.indenter_characteristics, poisson_ratio = self.multi_layer_segments_window.poisson_ratio, plot_result = True, retract_plot = self.entry_var['fd_curve']['retract_plot'].get(), ax = self.graphs['fd_curve']['axes'])
                for child in self.graphs['fd_curve']['axes'].get_children():
                    if isinstance(child,matplotlib.text.Annotation):
                        #child.set_backgroundcolor(self.color_scheme['figure_background'])
                        child.set_bbox({'edgecolor':self.color_scheme['text_disabled'], 'facecolor':self.color_scheme['figure_background']})
                        child.set_color(self.color_scheme['text_standard'])
                    if isinstance(child, matplotlib.legend.Legend):
                        frame = child.get_frame()
                        frame.set_facecolor(self.color_scheme['figure_background'])
                        frame.set_edgecolor(self.color_scheme['text_disabled'])
                        for text in child.get_texts():
                            text.set_color(self.color_scheme['text_standard'])
            except:
                self.qi_object.sample_fd_curve['object'].data_plot(col1 = self.qi_object.sample_fd_curve['object'].keys[x_key], col2 = self.qi_object.sample_fd_curve['object'].keys['y_key'], retract_plot = self.entry_var['fd_curve']['retract_plot'].get(), ax = self.graphs['fd_curve']['axes'])
                an1 = self.graphs['fd_curve']['axes'].annotate('ERROR while running multi-layer linearized hertz algorithm!\n    ==> No result shown.', xy=(.23, .7), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox= dict(boxstyle="round", fc= (1,1,1)))
                an1.draggable() #allows to drag the box arround
                an1.set_bbox({'edgecolor':self.color_scheme['text_disabled'], 'facecolor':self.color_scheme['figure_background']})
                an1.set_color(self.color_scheme['text_error'])
                for child in self.graphs['fd_curve']['axes'].get_children():
                    if isinstance(child, matplotlib.legend.Legend):
                        frame = child.get_frame()
                        frame.set_facecolor(self.color_scheme['figure_background'])
                        frame.set_edgecolor(self.color_scheme['text_disabled'])
                        for text in child.get_texts():
                            text.set_color(self.color_scheme['text_standard'])

        elif self.qi_object.sample_fd_curve['object'].control_variables['allow_analysis'] and self.standard_hertz_window.settings['visualization']['show_preview'].get():
            try:
                self.qi_object.sample_fd_curve['object'].fit_hertz_model(indenter_characteristics = self.standard_hertz_window.indenter_characteristics, poisson_ratio = self.standard_hertz_window.poisson_ratio, mode = self.standard_hertz_window.fit_settings_values['mode'], y_offset = self.standard_hertz_window.fit_settings_values['y_offset'], max_indentation = self.standard_hertz_window.fit_settings_values['max_indentation'], force_limit = self.standard_hertz_window.fit_settings_values['force_limit'], residuals_baseline_weight = self.standard_hertz_window.fit_settings_values['residuals_baseline_weight'], distance_to_contact = self.standard_hertz_window.fit_settings_values['distance_to_contact'] , min_fit_length = self.standard_hertz_window.fit_settings_values['min_fit_length'], plot_result = True, retract_plot = self.entry_var['fd_curve']['retract_plot'].get(), ax = self.graphs['fd_curve']['axes'])
                for child in self.graphs['fd_curve']['axes'].get_children():
                    if isinstance(child,matplotlib.text.Annotation):
                        #child.set_backgroundcolor(self.color_scheme['figure_background'])
                        child.set_bbox({'edgecolor':self.color_scheme['text_disabled'], 'facecolor':self.color_scheme['figure_background']})
                        child.set_color(self.color_scheme['text_standard'])
                    if isinstance(child, matplotlib.legend.Legend):
                        frame = child.get_frame()
                        frame.set_facecolor(self.color_scheme['figure_background'])
                        frame.set_edgecolor(self.color_scheme['text_disabled'])
                        for text in child.get_texts():
                            text.set_color(self.color_scheme['text_standard'])
            except:
                self.qi_object.sample_fd_curve['object'].data_plot(col1 = self.qi_object.sample_fd_curve['object'].keys[x_key], col2 = self.qi_object.sample_fd_curve['object'].keys['y_key'], retract_plot = self.entry_var['fd_curve']['retract_plot'].get(), ax = self.graphs['fd_curve']['axes'])
                an1 = self.graphs['fd_curve']['axes'].annotate('ERROR while fitting to standard Hertz model!\n    ==> No result shown.', xy=(.23, .7), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox= dict(boxstyle="round", fc= (1,1,1)))
                an1.draggable() #allows to drag the box arround
                an1.set_bbox({'edgecolor':self.color_scheme['text_disabled'], 'facecolor':self.color_scheme['figure_background']})
                an1.set_color(self.color_scheme['text_error'])
                for child in self.graphs['fd_curve']['axes'].get_children():
                    if isinstance(child, matplotlib.legend.Legend):
                        frame = child.get_frame()
                        frame.set_facecolor(self.color_scheme['figure_background'])
                        frame.set_edgecolor(self.color_scheme['text_disabled'])
                        for text in child.get_texts():
                            text.set_color(self.color_scheme['text_standard'])


        elif self.qi_object.sample_fd_curve['object'].control_variables['allow_analysis'] and self.breakthrough_events_window.settings['visualization']['show_preview'].get():
            try:
                self.qi_object.sample_fd_curve['object'].get_breakthrough_events(sensitivity = self.breakthrough_events_window.sensitivity, event_sep = self.breakthrough_events_window.event_sep, plot_result = True, retract_plot = self.entry_var['fd_curve']['retract_plot'].get(), ax = self.graphs['fd_curve']['axes'])
                for child in self.graphs['fd_curve']['axes'].get_children():
                    if isinstance(child,matplotlib.text.Annotation):
                        #child.set_backgroundcolor(self.color_scheme['figure_background'])
                        child.set_bbox({'edgecolor':self.color_scheme['text_disabled'], 'facecolor':self.color_scheme['figure_background']})
                        child.set_color(self.color_scheme['text_standard'])
                    if isinstance(child, matplotlib.legend.Legend):
                        frame = child.get_frame()
                        frame.set_facecolor(self.color_scheme['figure_background'])
                        frame.set_edgecolor(self.color_scheme['text_disabled'])
                        for text in child.get_texts():
                            text.set_color(self.color_scheme['text_standard'])
            except:
                self.qi_object.sample_fd_curve['object'].data_plot(col1 = self.qi_object.sample_fd_curve['object'].keys[x_key], col2 = self.qi_object.sample_fd_curve['object'].keys['y_key'], retract_plot = self.entry_var['fd_curve']['retract_plot'].get(), ax = self.graphs['fd_curve']['axes'])
                an1 = self.graphs['fd_curve']['axes'].annotate('ERROR while running breakthrough detection algorithm!\n    ==> No result shown.', xy=(.23, .7), xycoords='axes fraction', fontsize = 'x-small', linespacing = 2, bbox= dict(boxstyle="round", fc= (1,1,1)))
                an1.draggable() #allows to drag the box arround
                an1.set_bbox({'edgecolor':self.color_scheme['text_disabled'], 'facecolor':self.color_scheme['figure_background']})
                an1.set_color(self.color_scheme['text_error'])
                for child in self.graphs['fd_curve']['axes'].get_children():
                    if isinstance(child, matplotlib.legend.Legend):
                        frame = child.get_frame()
                        frame.set_facecolor(self.color_scheme['figure_background'])
                        frame.set_edgecolor(self.color_scheme['text_disabled'])
                        for text in child.get_texts():
                            text.set_color(self.color_scheme['text_standard'])
        else:
            self.qi_object.sample_fd_curve['object'].data_plot(col1 = self.qi_object.sample_fd_curve['object'].keys[x_key], col2 = self.qi_object.sample_fd_curve['object'].keys['y_key'], retract_plot = self.entry_var['fd_curve']['retract_plot'].get(), ax = self.graphs['fd_curve']['axes'])
            for child in self.graphs['fd_curve']['axes'].get_children():
                if isinstance(child, matplotlib.legend.Legend):
                    frame = child.get_frame()
                    frame.set_facecolor(self.color_scheme['figure_background'])
                    frame.set_edgecolor(self.color_scheme['text_disabled'])
                    for text in child.get_texts():
                        text.set_color(self.color_scheme['text_standard'])


        self.graphs['fd_curve']['figure'].suptitle('Index: %d -- (X,Y): (%d,%d)' % (self.qi_object.sample_fd_curve['index'],self.qi_object.sample_fd_curve['grid_index'][0],self.qi_object.sample_fd_curve['grid_index'][1]), x = 0.95, fontsize = 'small', horizontalalignment = 'right', color = self.color_scheme['text_standard'])

#            if isinstance(self.corrections_window.enter_window_app,tkinter.Toplevel): #checks whether settings window is open
        if self.control_parameter['baseline_correction_lines']:


            y_lim = self.graphs['fd_curve']['axes'].get_ylim()

            self.graphs['fd_curve']['axes'].vlines(self.qi_object.sample_fd_curve['object'].data['extend'][self.qi_object.sample_fd_curve['object'].keys[x_key]][int((self.qi_object.sample_fd_curve['object'].settings['samples']['extend']-1)*self.corrections_window.corrections['baseline_correction']['frac_data']['min'].get()/100)],y_lim[0], y_lim[1])
            self.graphs['fd_curve']['axes'].vlines(self.qi_object.sample_fd_curve['object'].data['extend'][self.qi_object.sample_fd_curve['object'].keys[x_key]][int((self.qi_object.sample_fd_curve['object'].settings['samples']['extend']-1)*self.corrections_window.corrections['baseline_correction']['frac_data']['max'].get()/100)],y_lim[0], y_lim[1])


        self.backend['fd_curve'].draw()




    def _create_frames(self):

        self.frames['master'] = tkinter.Frame(self, bg = self.color_scheme['background'])
        self.frames['master'].grid(row = 0, column = 0, sticky = 'nsew')
        #self.frames['master'].columnconfigure(2, weight = 1)

        self.frames['tools_top'] = tkinter.Frame(self.frames['master'], bg = self.color_scheme['background'], height = 30)
        self.frames['tools_left'] = tkinter.Frame(self.frames['master'], bg = self.color_scheme['background'], width = 200)
        self.frames['qi_map_master'] = tkinter.Frame(self.frames['master'], bg = self.color_scheme['figure_background'], relief = 'ridge', borderwidth = 2)
        self.frames['fd_curve_master'] = tkinter.Frame(self.frames['master'], bg = self.color_scheme['figure_background'], relief = 'ridge', borderwidth = 2)
        self.frames['statusbar'] = tkinter.Frame(self.frames['master'], bg = self.color_scheme['background'], relief = 'ridge', borderwidth = 2, height = 30)

        self.frames['tools_top'].grid(row = 0, column = 0, columnspan = 3, sticky = 'nsew')
        self.frames['tools_left'].grid(row = 1, column = 0, sticky = 'nsew', padx = (10,10))
        self.frames['qi_map_master'].grid(row = 1, column = 1, sticky = 'nsew')
        self.frames['fd_curve_master'].grid(row = 1, column = 2, sticky = 'nsew', padx = (0, 20))
        self.frames['statusbar'].grid(row = 2, column = 0, columnspan = 3, sticky = 'nsew')


        self.frames['qi_map'] = dict()
        self.frames['qi_map']['toolbar'] = tkinter.Frame(self.frames['qi_map_master'])
        self.frames['qi_map']['additional_settings'] = tkinter.Frame(self.frames['qi_map_master'], bg = self.color_scheme['figure_background'], height = 30, padx = 10)
        self.frames['qi_map']['canvas'] = tkinter.Frame(self.frames['qi_map_master'])
        #self.frames['qi_map']['canvas'] = tkinter.Frame(self.frames['qi_map_master'], width = 640, height = 480)

        self.frames['qi_map']['toolbar'].grid(row = 0, column = 0, sticky = 'nsew')
        self.frames['qi_map']['additional_settings'].grid(row = 1, column = 0, sticky = 'nsw')
        self.frames['qi_map']['canvas'].grid(row = 2, column = 0, sticky = 'nsew')


        self.frames['fd_curve'] = dict()
        self.frames['fd_curve']['toolbar'] = tkinter.Frame(self.frames['fd_curve_master'])
        self.frames['fd_curve']['additional_settings'] = tkinter.Frame(self.frames['fd_curve_master'], bg = self.color_scheme['figure_background'], height = 30, padx = 10)
        self.frames['fd_curve']['canvas'] = tkinter.Frame(self.frames['fd_curve_master'])
        #self.frames['fd_curve']['canvas'] = tkinter.Frame(self.frames['fd_curve_master'], width = 640, height = 480)
        #self.frames['fd_curve']['canvas'] .grid_propagate(False)
        self.frames['fd_curve']['toolbar'].grid(row = 0, column = 0, sticky = 'nsew')
        self.frames['fd_curve']['additional_settings'].grid(row = 1, column = 0, sticky = 'nsw')
        self.frames['fd_curve']['canvas'].grid(row = 2, column = 0, sticky = 'nsew')

        self.resizable(False, False)




    def _create_frame_content(self):

        self.additional_settings_graphs['qi_map'] = dict()
        self.additional_settings_graphs['qi_map']['colormap'] = dict()
        self.additional_settings_graphs['qi_map']['colormap']['label'] = tkinter.Label(self.frames['qi_map']['additional_settings'], text = 'Colormap:', bg = self.color_scheme['figure_background'], fg = self.color_scheme['text_standard'])
        self.additional_settings_graphs['qi_map']['colormap']['entry'] = tkinter.Entry(self.frames['qi_map']['additional_settings'], textvariable = self.entry_var['qi_map']['colormap'], width = 12 , justify = 'right', bd = 0, bg = self.color_scheme['background_input_dark'], fg = self.color_scheme['text_standard'], disabledbackground = self.color_scheme['background_input_disabled'], insertbackground = self.color_scheme['text_standard'], highlightthickness = 1, highlightcolor =  self.color_scheme['border_active'], highlightbackground = self.color_scheme['border'], selectbackground = self.color_scheme['text_selectbackground'])

        self.additional_settings_graphs['qi_map']['limits'] = dict()
        self.additional_settings_graphs['qi_map']['limits']['label_vmin'] = tkinter.Label(self.frames['qi_map']['additional_settings'], text = 'Vmin:', bg = self.color_scheme['figure_background'], fg = self.color_scheme['text_standard'])
        self.additional_settings_graphs['qi_map']['limits']['label_vmax'] = tkinter.Label(self.frames['qi_map']['additional_settings'], text = 'Vmax:', bg = self.color_scheme['figure_background'], fg = self.color_scheme['text_standard'])
        self.additional_settings_graphs['qi_map']['limits']['entry_vmin'] = tkinter.Entry(self.frames['qi_map']['additional_settings'], textvariable = self.entry_var['qi_map']['limits']['vmin'], width = 7, justify = 'right', bd = 0, bg = self.color_scheme['background_input_dark'], fg = self.color_scheme['text_standard'], disabledbackground = self.color_scheme['background_input_disabled'], insertbackground = self.color_scheme['text_standard'], highlightthickness = 1, highlightcolor =  self.color_scheme['border_active'], highlightbackground = self.color_scheme['border'], selectbackground = self.color_scheme['text_selectbackground'])
        self.additional_settings_graphs['qi_map']['limits']['entry_vmax'] = tkinter.Entry(self.frames['qi_map']['additional_settings'], textvariable = self.entry_var['qi_map']['limits']['vmax'], width = 7, justify = 'right', bd = 0, bg = self.color_scheme['background_input_dark'], fg = self.color_scheme['text_standard'], disabledbackground = self.color_scheme['background_input_disabled'], insertbackground = self.color_scheme['text_standard'], highlightthickness = 1, highlightcolor =  self.color_scheme['border_active'], highlightbackground = self.color_scheme['border'], selectbackground = self.color_scheme['text_selectbackground'])

        self.additional_settings_graphs['fd_curve'] = dict()

        self.additional_settings_graphs['fd_curve']['retract_plot'] = tkinter.Checkbutton(self.frames['fd_curve']['additional_settings'], text = 'Show \"retract\" curve', variable = self.entry_var['fd_curve']['retract_plot'], onvalue = True, offvalue = False, command = self.update_plot, bg = self.color_scheme['figure_background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['figure_background'], activebackground = self.color_scheme['figure_background'], activeforeground = self.color_scheme['text_standard'])


        self.additional_settings_graphs['qi_map']['colormap']['label'].grid(row = 0, column = 0, pady = (10,5), padx = (0,0), sticky = 'nsw')
        self.additional_settings_graphs['qi_map']['colormap']['entry'].grid(row = 0, column = 1, pady = (10,5), padx = (5,10), sticky = 'nsw')
        self.additional_settings_graphs['qi_map']['limits']['label_vmin'].grid(row = 0, column = 2, pady = (10,5), padx = (25,5), sticky = 'nsw')
        self.additional_settings_graphs['qi_map']['limits']['entry_vmin'].grid(row = 0, column = 3, pady = (10,5), padx = (0,10), sticky = 'nsw')
        self.additional_settings_graphs['qi_map']['limits']['label_vmax'].grid(row = 0, column = 4, pady = (10,5), padx = (5,5), sticky = 'nsw')
        self.additional_settings_graphs['qi_map']['limits']['entry_vmax'].grid(row = 0, column = 5, pady = (10,5), padx = (0,0), sticky = 'nsw')

        self.additional_settings_graphs['fd_curve']['retract_plot'].grid(row = 0, column = 0, sticky = 'nsw', pady = (10,5))


        self.additional_settings_graphs['qi_map']['colormap']['label'].configure(state = 'disabled')
        self.additional_settings_graphs['qi_map']['colormap']['entry'].configure(state = 'disabled')
        self.additional_settings_graphs['qi_map']['limits']['label_vmin'].configure(state = 'disabled')
        self.additional_settings_graphs['qi_map']['limits']['entry_vmin'].configure(state = 'disabled')
        self.additional_settings_graphs['qi_map']['limits']['label_vmax'].configure(state = 'disabled')
        self.additional_settings_graphs['qi_map']['limits']['entry_vmax'].configure(state = 'disabled')

        self.additional_settings_graphs['fd_curve']['retract_plot'].configure(state = 'disabled')


        self.additional_settings_graphs['qi_map']['colormap']['entry'].bind('<Return>', self._update_colormap)
        self.additional_settings_graphs['qi_map']['limits']['entry_vmin'].bind('<Return>', self._update_clim)
        self.additional_settings_graphs['qi_map']['limits']['entry_vmax'].bind('<Return>', self._update_clim)

        info1 = CreateToolTip(self.additional_settings_graphs['qi_map']['colormap']['label'], 'Enter a valid color map - see matplitlib documentation for choices.')



    def _create_menues(self):

        self.menu['menu_bar'] = tkinter.Menu(self)
#        self.menu['menu_bar'] = tkinter.Menu(self.root)

        self.menu['file_menu'] = tkinter.Menu(self.menu['menu_bar'], tearoff = 0)
        #self.menu['file_menu'].add_command(label = 'Test Thing', command = lambda : popupmsg('Not supported just yet!'))
        self.menu['file_menu'].add_command(label = 'Open...', command = self.open_file)
        self.menu['file_menu'].add_command(label = 'Save directory', command = self.gui_set_save_directory, state = 'disabled')
        self.menu['file_menu'].add_separator()
        #self.menu['file_menu'].add_command(label = 'Set ', command = lambda : popupmsg('Not supported just yet!'))
        self.menu['file_menu'].add_command(label = 'Export QI snapshot', command = self.export_qi_snapshot, state = 'disabled')
        self.menu['file_menu'].add_command(label = 'Export force-distance curve', command = self.export_fd_curve, state = 'disabled')
        self.menu['file_menu'].add_separator()
        self.menu['file_menu'].add_command(label = 'Import QI snapshot', command = self.import_qi_snapshot, state = 'normal')
        self.menu['file_menu'].add_separator()
#        self.menu['file_menu'].add_command(label = 'Exit', command = self.root.destroy)
        self.menu['file_menu'].add_command(label = 'Exit', command = self.destroy)

        self.menu['corrections'] = tkinter.Menu(self.menu['menu_bar'], tearoff = 0)
        self.menu['corrections'].add_command(label = 'Show Corrections', command = lambda : popupmsg('Not supported just yet!'), state = 'disabled')
        self.menu['corrections'].add_command(label = 'Set Corrections', command = self.corrections_window.set_corrections)
        self.menu['corrections'].add_checkbutton(label = 'Apply Corrections', onvalue = True, offvalue = False, variable = self.control_parameter['apply_corrections'], command = self._toggle_apply_corrections)
        self.menu['corrections'].add_separator()
        self.menu['corrections'].add_command(label = 'Modify Cantilever Calibration', command = self.cantilever_calibration_window.modify_calibration)
        self.menu['corrections'].add_checkbutton(label = 'Use Modified Sensitivity', onvalue = True, offvalue = False, variable = self.control_parameter['modify_cantilever_calibration']['sensitivity'], command = self.cantilever_calibration_window._reset_sensitivity_value, state = 'disabled')
        self.menu['corrections'].add_checkbutton(label = 'Use Modified Spring Constant', onvalue = True, offvalue = False, variable = self.control_parameter['modify_cantilever_calibration']['spring_constant'], command = self.cantilever_calibration_window._reset_spring_constant_value, state = 'disabled')
        self.menu['corrections'].add_command(label = 'Reset Cantilever Calibration', command = self.cantilever_calibration_window.reset)


        self.menu['data_analysis'] = tkinter.Menu(self.menu['menu_bar'], tearoff = 0)
        self.menu['data_analysis'].add_command(label = 'Set/run default analysis...', command = lambda : popupmsg('Not supported just yet!'), state = 'disabled')
        self.menu['data_analysis'].add_separator()
        self.menu['data_analysis'].add_command(label = 'Contact point topography', command = lambda : popupmsg('Not supported just yet!'), state = 'disabled')
        self.menu['data_analysis'].add_command(label = 'Apparent layer thickness', command = self.apparent_layer_thickness_window.setup_apparent_layer_thickness)
        self.menu['data_analysis'].add_separator()
        self.menu['data_analysis'].add_command(label = 'Standard Hertz Fit', command = self.standard_hertz_window.setup_standard_hertz)
        self.menu['data_analysis'].add_command(label = 'Two-Layer linearized Hertz algorithm', command = lambda : popupmsg('Not supported just yet!'), state = 'disabled')
        self.menu['data_analysis'].add_command(label = 'Three-Layer linearized Hertz algorithm', command = self.multi_layer_segments_window.setup_multi_layer_segments)
        self.menu['data_analysis'].add_separator()
        self.menu['data_analysis'].add_command(label = 'Breakthrough events', command = self.breakthrough_events_window.setup_breakthrough_events)

        self.menu['selection_tool'] = tkinter.Menu(self.menu['menu_bar'], tearoff = 0)
        self.menu['selection_tool'].add_command(label = 'Start selection tool', command = self.selection_tool_window.setup_selection_tool)


        self.menu['menu_bar'].add_cascade(label = 'File', menu = self.menu['file_menu'])
        self.menu['menu_bar'].add_cascade(label = 'Corrections', menu = self.menu['corrections'], state = 'disabled')
        self.menu['menu_bar'].add_cascade(label = 'Analysis', menu = self.menu['data_analysis'], state = 'disabled')
        self.menu['menu_bar'].add_cascade(label = 'Selection Tool', menu = self.menu['selection_tool'], state = 'disabled')

        #self.menu['dummy'] = tkinter.Menu(self.menu['menu_bar'], tearoff = 0)
        #self.menu['dummy'].add_command(label = 'Apparent layer thickness', command = self.apparent_layer_thickness_window.setup_apparent_layer_thickness)
        #self.menu['dummy'].add_command(label = 'Standard Hertz Fit', command = self.standard_hertz_window.setup_standard_hertz)
        #self.menu['dummy'].add_command(label = 'Three-Layer linearized Hertz algorithm', command = self.multi_layer_segments_window.setup_multi_layer_segments)
        #self.menu['dummy'].add_command(label = 'Start selection tool', command = self.selection_tool_window.setup_selection_tool)
        #self.menu['dummy'].add_command(label = 'Breakthrough events', command = self.breakthrough_events_window.setup_breakthrough_events)
        #self.menu['menu_bar'].add_cascade(label = 'Dummy', menu = self.menu['dummy'], state = 'normal')


        tkinter.Tk.config(self, menu = self.menu['menu_bar'])





    def _create_canvas(self):

        plt.ioff()
        self.graphs['qi_map']['figure'] = plt.figure(facecolor = self.color_scheme['figure_background'], figsize = (6.4,4.8), dpi = 100)
        self.graphs['fd_curve']['figure'] = plt.figure(facecolor = self.color_scheme['figure_background'], figsize = (6.4,4.8), dpi = 100)
        plt.ion()

        self.backend['qi_map'] = FigureCanvasTkAgg(self.graphs['qi_map']['figure'], self.frames['qi_map']['canvas'])
        self.backend['fd_curve'] = FigureCanvasTkAgg(self.graphs['fd_curve']['figure'], self.frames['fd_curve']['canvas'])

        self.mpl_canvas['qi_map'] = self.backend['qi_map'].get_tk_widget()
        self.mpl_canvas['qi_map'].grid(row = 0, column = 0)
        self.mpl_canvas['fd_curve'] = self.backend['fd_curve'].get_tk_widget()
        self.mpl_canvas['fd_curve'].grid(row = 0, column = 0)

        self.toolbar['qi_map'] = NavigationToolbar2Tk(self.backend['qi_map'], self.frames['qi_map']['toolbar'])
        self.toolbar['qi_map'].configure(background = self.color_scheme['figure_background'])
        self.toolbar['qi_map']._message_label.config(background = self.color_scheme['figure_background'], foreground = self.color_scheme['text_standard'])
        self.toolbar['qi_map'].update()
        self.toolbar['fd_curve'] = NavigationToolbar2Tk(self.backend['fd_curve'], self.frames['fd_curve']['toolbar'])
        self.toolbar['fd_curve'].configure(background = self.color_scheme['figure_background'])
        self.toolbar['fd_curve']._message_label.config(background = self.color_scheme['figure_background'], foreground = self.color_scheme['text_standard'])
        self.toolbar['fd_curve'].update()

        self.backend['qi_map'].mpl_connect('button_press_event', self.onclick)





    def open_file(self):

        if self.control_parameter['file_imported']:

            self.bell()
            proceed = tkinter.messagebox.askyesno(title=None, message= 'QI Map was already imported.\nOverwrite current QI Map? All progress will be lost!')

            if proceed:

                filename = tkinter.filedialog.askopenfilename(initialdir = self.settings['directory']['open'], filetypes = [("JPK QI Map","*.jpk-qi-data")])

                if filename:

                    self.qi_object = QIMap()
                    self.qi_object.import_data(filename)
                    self.control_parameter['file_imported'] = True

                    if self.control_parameter['directory_set']['save']:

                        #self.qi_object.set_save_directory(self.settings['directory']['save'])
                        self.qi_object.file_info['save_directory'] = os.path.normpath(os.path.join(self.settings['directory']['save'],self.qi_object.file_info['file_org']))

                    else:

                        save_dir = os.path.normpath(self.qi_object.file_info['filename'][:self.qi_object.file_info['filename'].rfind(os.path.sep)])
                        self.settings['directory']['save'] = os.path.normpath(save_dir)

                        #self.qi_object.set_save_directory(self.settings['directory']['save'])


                    open_dir = os.path.normpath(self.qi_object.file_info['filename'][:self.qi_object.file_info['filename'].rfind(os.path.sep)])
                    self.settings['directory']['open'] = open_dir

                    self.cantilever_calibration_window._on_open_new_qi_map() #needs to be called before anything is analyzed (in _activate_qi_map_processing), as otherwise, the modified cantilever calibration might influences the topography image


                    self._activate_qi_map_processing()
                    self.control_parameter['apply_corrections'].set(False)
                    self.control_parameter['modify_cantilever_calibration']['sensitivity'].set(False)
                    self.control_parameter['modify_cantilever_calibration']['spring_constant'].set(False)
                    self.menu['corrections'].entryconfig(5, state = 'disabled')
                    self.menu['corrections'].entryconfig(6, state = 'disabled')

                    self.menu['menu_bar'].entryconfig(3, state = 'disabled')


                    self.corrections_window.reset_corrections()
                    self.selection_tool_window._on_open_new_qi_map()

                    #disable all the analysis buttons
                    self.standard_hertz_window._on_open_new_qi_map()
                    self.multi_layer_segments_window._on_open_new_qi_map()
                    self.apparent_layer_thickness_window._on_open_new_qi_map()
                    self.breakthrough_events_window._on_open_new_qi_map()



        else:

            filename = tkinter.filedialog.askopenfilename(initialdir = self.settings['directory']['open'], filetypes = [("JPK QI Map","*.jpk-qi-data")])

            if filename:

                self.qi_object = QIMap()
                self.qi_object.import_data(filename)
                self.control_parameter['file_imported'] = True

                save_dir = os.path.normpath(self.qi_object.file_info['filename'][:self.qi_object.file_info['filename'].rfind(os.path.sep)])
                self.settings['directory']['save'] = os.path.normpath(save_dir)

                open_dir = os.path.normpath(self.qi_object.file_info['filename'][:self.qi_object.file_info['filename'].rfind(os.path.sep)])
                self.settings['directory']['open'] = open_dir
                self._activate_qi_map_processing()
                self.menu['file_menu'].entryconfig(1, state = 'normal')
                self.menu['file_menu'].entryconfig(3, state = 'normal')
                #self.menu['file_menu'].entryconfig(4, state = 'normal')





    def export_qi_snapshot(self):

        self.qi_object.save_snapshot()
        sys.stdout.write('Snapshot saved to directory: ' + self.qi_object.file_info['save_directory'])

        tkinter.messagebox.showinfo(title = 'Snapshot Exported', message = 'Snapshot exported to directory: ' + self.qi_object.file_info['save_directory'])




    def import_qi_snapshot(self):

        if self.control_parameter['file_imported']:

            self.bell()
            proceed = tkinter.messagebox.askyesno(title=None, message= 'QI Map was already imported.\nOverwrite current QI Map? All progress will be lost!')

        else:

            proceed = True

        if proceed:
            filename = tkinter.filedialog.askopenfilename(initialdir = self.settings['directory']['open'], filetypes = [("QI Snapshot","*.pkl")])

            if '.snap_shot' in filename:

                self.qi_object = QIMap()
                self.qi_object.load_snapshot(os.path.normpath(filename))

                if os.path.isfile(self.qi_object.file_info['filename']):

                    self.qi_object.re_import_jpk_raw_data()
                    continue_import = True

                else:
                    continue_import = False
                    tkinter.messagebox.showwarning(title='Missing Raw Data File', message = 'The original file location was altered!\nPlease identify the location of file: \"' + self.qi_object.file_info['file_org'] + '.jpk-qi-data' +'\"!')

                    new_filename = tkinter.filedialog.askopenfilename(initialdir = self.qi_object.file_info['save_directory'], filetypes = [("JPK QI Map","*.jpk-qi-data")])

                    print(new_filename)

                    if self.qi_object.file_info['file_org'] + '.jpk-qi-data' in new_filename:

                        self.qi_object.file_info['filename'] = os.path.normpath(new_filename)
#                        save_dir = os.path.normpath(self.qi_object.file_info['filename'][:self.qi_object.file_info['filename'].rfind(os.path.sep)])
#                        self.qi_object.file_info['save_directory'] = os.path.normpath(os.path.join(save_dir, self.qi_object.file_info['file_org']))

                        self.qi_object.re_import_jpk_raw_data()
                        continue_import = True

                    else:

                        self.qi_object = None
                        tkinter.messagebox.showerror(title='Missing Raw Data File', message = 'Correct file was not identified. Import aborted!')




                if continue_import:

                    self.qi_object.sample_fd_curve = dict()

                    save_dir = os.path.normpath(self.qi_object.file_info['save_directory'][:self.qi_object.file_info['save_directory'].rfind(os.path.sep)])
                    self.settings['directory']['save'] = os.path.normpath(save_dir)

                    self.control_parameter['directory_set']['save'] = True
                    self.control_parameter['file_imported'] = True

                    self.menu['file_menu'].entryconfig(1, state = 'normal')
                    self.menu['file_menu'].entryconfig(3, state = 'normal')



                    self._activate_qi_map_processing() #takes also care of opening a sample fd curve

                    #1. handle corrections + cantilever calibration
                    self.cantilever_calibration_window._on_loading_qi_snapshot()
                    self.corrections_window._on_loading_qi_snapshot() #also includes an update plot

                    #2. selection tool
                    if self.control_parameter['selection_tool_window']:
                        self.selection_tool_window._on_loading_qi_snapshot()
                    #3. multilayer Segments
                    self.multi_layer_segments_window._on_loading_qi_snapshot()
                    #4. standard hertz
                    self.standard_hertz_window._on_loading_qi_snapshot()
                    #5. apparent layer
                    self.apparent_layer_thickness_window._on_loading_qi_snapshot()
                    #6. breakthrough event
                    self.breakthrough_events_window._on_loading_qi_snapshot()








            else:
                #print(filename)
                print('Chosen file is not a valid QI snapshot!')
















    def export_fd_curve(self):

        print('\aTo Do: Create save_snapshot function for fd curve')
        #self.qi_object.sample_fd_curve['object'].save_snapshot()




    def _create_plot_qi_canvas(self):

        if 'topography_mod' not in self.qi_object.data.keys():

            self.qi_object.get_topography_no_log()
            self.qi_object.plane_fit_topography()


        if isinstance(self.graphs['qi_map']['axes'], matplotlib.axes.Axes):

            self.graphs['qi_map']['figure'].clear() #clear whole figure, as there are several subplots


        x_width = np.round(self.qi_object.settings['grid']['u-length']*10**6,3)
        y_width = np.round(self.qi_object.settings['grid']['u-length']*10**6,3)


        self.graphs['qi_map']['axes'] = self.graphs['qi_map']['figure'].add_subplot(111)
        self.graphs['qi_map']['axes'].spines['bottom'].set_color(self.color_scheme['text_standard'])
        self.graphs['qi_map']['axes'].spines['top'].set_color(self.color_scheme['text_standard'])
        self.graphs['qi_map']['axes'].spines['left'].set_color(self.color_scheme['text_standard'])
        self.graphs['qi_map']['axes'].spines['right'].set_color(self.color_scheme['text_standard'])

        self.graphs['qi_map']['axes'].xaxis.label.set_color(self.color_scheme['text_standard'])
        self.graphs['qi_map']['axes'].yaxis.label.set_color(self.color_scheme['text_standard'])
        self.graphs['qi_map']['axes'].tick_params(colors=self.color_scheme['text_standard'], top = True, right = True)

        self.entry_var['qi_map']['colormap'].set('afmhot')
        self.entry_var['qi_map']['limits']['vmin'].set(str(np.round(np.nanmin(self.qi_object.data['topography_mod'])*1.1,2)))
        self.entry_var['qi_map']['limits']['vmax'].set(str(np.round(np.nanmax(self.qi_object.data['topography_mod'])*1.1,2)))

        self.graphs['qi_map']['image'] = self.graphs['qi_map']['axes'].imshow(self.qi_object.data['topography_mod'], origin = 'lower', cmap = self.entry_var['qi_map']['colormap'].get(), extent = [0, x_width, 0, y_width], vmin = float(self.entry_var['qi_map']['limits']['vmin'].get()), vmax = float(self.entry_var['qi_map']['limits']['vmax'].get()))
        self.graphs['qi_map']['colorbar'] = self.graphs['qi_map']['figure'].colorbar(self.graphs['qi_map']['image'], ax = self.graphs['qi_map']['axes'])
        self.graphs['qi_map']['colorbar'].set_label('Measured height / \u03BCm', rotation = 270, labelpad = 20)
        self.graphs['qi_map']['axes_colorbar'] = self.graphs['qi_map']['colorbar'].ax
        self.graphs['qi_map']['axes'].set_xlabel('Position / \u03BCm')
        self.graphs['qi_map']['axes'].set_ylabel('Position / \u03BCm')

        self.graphs['qi_map']['colorbar'].outline.set_edgecolor(self.color_scheme['text_standard'])
        self.graphs['qi_map']['axes_colorbar'].xaxis.label.set_color(self.color_scheme['text_standard'])
        self.graphs['qi_map']['axes_colorbar'].yaxis.label.set_color(self.color_scheme['text_standard'])
        self.graphs['qi_map']['axes_colorbar'].tick_params(colors=self.color_scheme['text_standard'])


        self.graphs['qi_map']['marker'] = self.graphs['qi_map']['axes'].plot(0,0, marker = 'x', markeredgecolor = 'black', markersize = 7) #add marker for the sample fd curve

        self.backend['qi_map'].draw()

        self.additional_settings_graphs['qi_map']['colormap']['label'].configure(state = 'normal')
        self.additional_settings_graphs['qi_map']['colormap']['entry'].configure(state = 'normal')
        self.additional_settings_graphs['qi_map']['limits']['label_vmin'].configure(state = 'normal')
        self.additional_settings_graphs['qi_map']['limits']['entry_vmin'].configure(state = 'normal')
        self.additional_settings_graphs['qi_map']['limits']['label_vmax'].configure(state = 'normal')
        self.additional_settings_graphs['qi_map']['limits']['entry_vmax'].configure(state = 'normal')

        self.bind('<Shift-Left>', self._left_press)
        self.bind('<Shift-Right>', self._right_press)
        self.bind('<Shift-Up>', self._up_press)
        self.bind('<Shift-Down>', self._down_press)





    def _create_plot_fd_canvas(self):

        #x_key = 'x_key'

        if isinstance(self.graphs['fd_curve']['axes'], matplotlib.axes.Axes):

            self.graphs['fd_curve']['axes'].clear()

        else:

            self.graphs['fd_curve']['axes'] = self.graphs['fd_curve']['figure'].add_subplot(111)

        self.graphs['fd_curve']['axes'].set_facecolor(self.color_scheme['figure_background'])
        self.graphs['fd_curve']['axes'].spines['bottom'].set_color(self.color_scheme['text_standard'])
        self.graphs['fd_curve']['axes'].spines['top'].set_color(self.color_scheme['text_standard'])
        self.graphs['fd_curve']['axes'].spines['left'].set_color(self.color_scheme['text_standard'])
        self.graphs['fd_curve']['axes'].spines['right'].set_color(self.color_scheme['text_standard'])

        self.graphs['fd_curve']['axes'].xaxis.label.set_color(self.color_scheme['text_standard'])
        self.graphs['fd_curve']['axes'].yaxis.label.set_color(self.color_scheme['text_standard'])
        self.graphs['fd_curve']['axes'].tick_params(colors=self.color_scheme['text_standard'], top = True, right = True)




        self.qi_object.open_sample_fd_curve(0)
        #self.qi_object.sample_fd_curve['object'].data_plot(col1 = self.qi_object.sample_fd_curve['object'].keys[x_key], col2 = self.qi_object.sample_fd_curve['object'].keys['y_key'], ax = self.graphs['fd_curve']['axes'])
        self.qi_object.sample_fd_curve['object'].data_plot(ax = self.graphs['fd_curve']['axes'])
        #self.graphs['fd_curve']['axes'].set_title('Index: %d -- Grid Index: (%d,%d)' % (self.qi_object.sample_fd_curve['index'],self.qi_object.sample_fd_curve['grid_index'][0],self.qi_object.sample_fd_curve['grid_index'][0]))
        self.graphs['fd_curve']['figure'].suptitle('Index: %d -- (X,Y): (%d,%d)' % (self.qi_object.sample_fd_curve['index'],self.qi_object.sample_fd_curve['grid_index'][0],self.qi_object.sample_fd_curve['grid_index'][1]), x = 0.95, fontsize = 'small', horizontalalignment = 'right', color = self.color_scheme['text_standard'])
        for child in self.graphs['fd_curve']['axes'].get_children():
            if isinstance(child, matplotlib.legend.Legend):
                frame = child.get_frame()
                frame.set_facecolor(self.color_scheme['figure_background'])
                frame.set_edgecolor(self.color_scheme['text_disabled'])
                for text in child.get_texts():
                    text.set_color(self.color_scheme['text_standard'])

        self.backend['fd_curve'].draw()

        self.additional_settings_graphs['fd_curve']['retract_plot'].configure(state = 'normal')





    def gui_set_save_directory(self):

        save_dir = tkinter.filedialog.askdirectory(initialdir = self.settings['directory']['save'])

        if save_dir:

            self.settings['directory']['save'] = os.path.normpath(save_dir)
            #self.qi_object.file_info['save_directory'] = os.path.normpath(os.path.join(self.settings['directory']['save'],self.qi_object.file_info['file_org']))
            self.qi_object.set_save_directory(self.settings['directory']['save'])
            self.control_parameter['directory_set']['save'] = True




    def _activate_qi_map_processing(self):

        self.menu['menu_bar'].entryconfig(2, state = 'normal')
        #self.menu['menu_bar'].entryconfig(3, state = 'normal')
        self.menu['menu_bar'].entryconfig(4, state = 'normal')
        self._create_plot_qi_canvas()
        self._create_plot_fd_canvas()
        self._set_cantilever_calibration_window_values()




    def _set_cantilever_calibration_window_values(self):

        self.cantilever_calibration_window.entry_sensitivity['scale_label'].set(np.round(self.qi_object.jpk_qi_data.calibrations['sensitivity']*1e9, decimals = 2))
        self.cantilever_calibration_window.entry_spring_constant['scale_label'].set(np.round(self.qi_object.jpk_qi_data.calibrations['spring_constant'], decimals = 3))

        self.cantilever_calibration_window.sensitivity['new_start'].set(self.qi_object.jpk_qi_data.calibrations['sensitivity']*1e9)
        self.cantilever_calibration_window.sensitivity['new_tentative'].set(self.qi_object.jpk_qi_data.calibrations['sensitivity']*1e9)

        self.cantilever_calibration_window.spring_constant['new_start'].set(self.qi_object.jpk_qi_data.calibrations['spring_constant'])
        self.cantilever_calibration_window.spring_constant['new_tentative'].set(self.qi_object.jpk_qi_data.calibrations['spring_constant'])




    def _toggle_apply_corrections(self):

        if self.control_parameter['apply_corrections'].get() and self.qi_object.control_variables['allow_analysis']:
        #if self.qi_object.control_variables['allow_analysis']:

            if self.control_parameter['multi_layer_segments_window']:
                self.multi_layer_segments_window.analysis_control_panel['button']['run'].configure(state = 'normal')
                self.multi_layer_segments_window.selection_panel['run_analysis_selection'].configure(state = 'normal')

        else:

            if self.control_parameter['multi_layer_segments_window']:
                self.multi_layer_segments_window.analysis_control_panel['button']['run'].configure(state = 'disabled')
                self.multi_layer_segments_window.selection_panel['run_analysis_selection'].configure(state = 'disabled')


        self.update_plot()




    def _update_colormap(self, event = None):

        #if self.entry_var['colormap'].get() in _COLOR_MAPS:
        if self.entry_var['qi_map']['colormap'].get() in _Helper_Functions_GUI._get_colormaps_imshow():
            self.graphs['qi_map']['image'].set_cmap(self.entry_var['qi_map']['colormap'].get())
            self.backend['qi_map'].draw()

        else:

            self.bell()
            print('Invalid color map')




    def _update_clim(self, event = None):

        try:

            vmin_new = float(self.entry_var['qi_map']['limits']['vmin'].get())
            vmax_new = float(self.entry_var['qi_map']['limits']['vmax'].get())

            self.graphs['qi_map']['image'].set_clim(vmin = vmin_new, vmax = vmax_new)
            self.backend['qi_map'].draw()

        except:

            self.bell()
            print('Invalid climits!')



    # def _initialize_control_parameters(self):
    #
    #     self.control_parameter['file_imported'] = False
    #     self.control_parameter['directory_set'] = {'open': False, 'save': False}
    #
    #     self.control_parameter['apply_corrections'] = tkinter.BooleanVar(None, False)
    #     self.control_parameter['correction_window'] = False
    #     self.control_parameter['baseline_correction_lines'] = False
    #     self.control_parameter['modify_cantilever_calibration'] = {'sensitivity': tkinter.BooleanVar(None, False), 'spring_constant': tkinter.BooleanVar(None, False)}
    #
    #     self.control_parameter['selection_tool_window'] = False
    #
    #     self.control_parameter['apparent_layer_thickness_window'] = False
    #     self.control_parameter['multi_layer_segments_window'] = False
    #     self.control_parameter['breakthrough_events_window'] = False




    def _control_press(self, event = None):

        self.keys_pressed['Control_L'] = True
        self.unbind('<Control_L>')




    def _shift_press(self, event = None):

        self.keys_pressed['Shift_L'] = True
        self.unbind('<Shift_L>')




    def _key_released(self, event = None):

        if event.keycode == 17:
            self.keys_pressed['Control_L'] = False
            self.bind('<Control_L>', self._control_press)
            #print('Selection Window: control released')
        elif event.keycode == 16:
            self.keys_pressed['Shift_L'] = False
            self.bind('<Shift_L>', self._shift_press)
            #print('Selection Window: alt released')




    def _left_press(self, event = None):

        if self.qi_object.sample_fd_curve['grid_index'][0] % self.qi_object.settings['grid']['x']:
            new_ind = self.qi_object.sample_fd_curve['index'] - 1

            x = self.qi_object.sample_fd_curve['grid_index'][0]-1
            y = self.qi_object.sample_fd_curve['grid_index'][1]

            self.graphs['qi_map']['marker'].pop(0).remove()
            #self.graphs['qi_map']['marker'] = self.graphs['qi_map']['axes'].plot(self.qi_object.sample_fd_curve['grid_index'][0]-1,self.qi_object.sample_fd_curve['grid_index'][1], marker = 'x', markeredgecolor = 'black', markersize = 7)
            self.graphs['qi_map']['marker'] = self.graphs['qi_map']['axes'].plot((x+0.5)/self.qi_object.settings['grid']['x']*self.qi_object.settings['grid']['u-length']*10**6,(y+0.5)/self.qi_object.settings['grid']['y']*self.qi_object.settings['grid']['v-length']*10**6, marker = 'x', markeredgecolor = 'black', markersize = 7)
            self.backend['qi_map'].draw()

            self.qi_object.open_sample_fd_curve(new_ind)

            self.create_fd_plot()



    def _right_press(self, event = None):

        if not self.qi_object.sample_fd_curve['grid_index'][0] == self.qi_object.settings['grid']['x']-1:
            new_ind = self.qi_object.sample_fd_curve['index'] + 1

            x = self.qi_object.sample_fd_curve['grid_index'][0]+1
            y = self.qi_object.sample_fd_curve['grid_index'][1]

            self.graphs['qi_map']['marker'].pop(0).remove()
            #self.graphs['qi_map']['marker'] = self.graphs['qi_map']['axes'].plot(self.qi_object.sample_fd_curve['grid_index'][0]+1,self.qi_object.sample_fd_curve['grid_index'][1], marker = 'x', markeredgecolor = 'black', markersize = 7)
            self.graphs['qi_map']['marker'] = self.graphs['qi_map']['axes'].plot((x+0.5)/self.qi_object.settings['grid']['x']*self.qi_object.settings['grid']['u-length']*10**6,(y+0.5)/self.qi_object.settings['grid']['y']*self.qi_object.settings['grid']['v-length']*10**6, marker = 'x', markeredgecolor = 'black', markersize = 7)
            self.backend['qi_map'].draw()

            self.qi_object.open_sample_fd_curve(new_ind)

            self.create_fd_plot()




    def _down_press(self, event = None):

        if self.qi_object.sample_fd_curve['grid_index'][1] % self.qi_object.settings['grid']['y']:
            new_ind = self.qi_object.sample_fd_curve['index'] - self.qi_object.settings['grid']['y']

            x = self.qi_object.sample_fd_curve['grid_index'][0]
            y = self.qi_object.sample_fd_curve['grid_index'][1]-1

            self.graphs['qi_map']['marker'].pop(0).remove()
            #self.graphs['qi_map']['marker'] = self.graphs['qi_map']['axes'].plot(self.qi_object.sample_fd_curve['grid_index'][0],self.qi_object.sample_fd_curve['grid_index'][1]-1, marker = 'x', markeredgecolor = 'black', markersize = 7)
            self.graphs['qi_map']['marker'] = self.graphs['qi_map']['axes'].plot((x+0.5)/self.qi_object.settings['grid']['x']*self.qi_object.settings['grid']['u-length']*10**6,(y+0.5)/self.qi_object.settings['grid']['y']*self.qi_object.settings['grid']['v-length']*10**6, marker = 'x', markeredgecolor = 'black', markersize = 7)
            self.backend['qi_map'].draw()

            self.qi_object.open_sample_fd_curve(new_ind)

            self.create_fd_plot()




    def _up_press(self, event = None):

        if not self.qi_object.sample_fd_curve['grid_index'][1] == self.qi_object.settings['grid']['y'] - 1:
            new_ind = self.qi_object.sample_fd_curve['index'] + self.qi_object.settings['grid']['y']

            x = self.qi_object.sample_fd_curve['grid_index'][0]
            y = self.qi_object.sample_fd_curve['grid_index'][1]+1

            self.graphs['qi_map']['marker'].pop(0).remove()
            #self.graphs['qi_map']['marker'] = self.graphs['qi_map']['axes'].plot(self.qi_object.sample_fd_curve['grid_index'][0],self.qi_object.sample_fd_curve['grid_index'][1]+1, marker = 'x', markeredgecolor = 'black', markersize = 7)
            self.graphs['qi_map']['marker'] = self.graphs['qi_map']['axes'].plot((x+0.5)/self.qi_object.settings['grid']['x']*self.qi_object.settings['grid']['u-length']*10**6,(y+0.5)/self.qi_object.settings['grid']['y']*self.qi_object.settings['grid']['v-length']*10**6, marker = 'x', markeredgecolor = 'black', markersize = 7)
            self.backend['qi_map'].draw()

            self.qi_object.open_sample_fd_curve(new_ind)

            self.create_fd_plot()


#%% fit functions

#def herz_model_parabolic_indenter(x, e_module):#, poisson_ratio = 0.5):
# x is the tip sample seperation
# radius = radius of tip curvature
# e_module of the surface
    #return (e_module / (1 - 0.5**2)) * ( 4 / 3 * math.sqrt(10)) * x**(3/2)
    #return (e_module / (1 - poisson_ratio**2)) * ( 4 / 3 * math.sqrt(radius)) * x**(3/2)

#def contact_spherical(x, indenter_characteristics):

#    return fsolve(radius_contact_circle_hertz_sphere, x0 = 0.1, args = (indenter_characteristics['radius [nm]'],x))[0]


#
#
#def power3_2(x, a):
#
#      return a * abs(x)**(3/2)
#
#
#def power2(x, a):
#
#      return a * abs(x)**2
#
#
#def power1(x, a):
#
#      return a * abs(x)
# -*- coding: utf-8 -*-

class SetCorrectionsWindow():


    def __init__(self,QI_FD_Preview_object):

        self.parent = QI_FD_Preview_object
        #self.qi_object = QI_FD_Preview_object.qi_object #for some reason that creates a bew QI_Map_new object.... which is basically almost empty besides the control parameters. compare memory addresses of the QI_Map_new object passed to the SetCorrectionsWindow class (original object) and the object within the class itself

        self.enter_window_app = None
        self.distance_notebook = None

        self.corrections = dict()
        self.corrections['force_unit'] = tkinter.StringVar(None, 'nN')
        self.corrections['distance_unit'] = tkinter.StringVar(None, 'nm')
        self.corrections['baseline_correction'] = dict()
        self.corrections['baseline_correction']['method'] = tkinter.StringVar(None, 'linear')
        self.corrections['baseline_correction']['reference'] = tkinter.StringVar(None, 'individual')
        self.corrections['baseline_correction']['frac_data'] = {'min':tkinter.IntVar(None, 0),'max':tkinter.IntVar(None, 50)}
        self.corrections['distance_correction'] = dict()
        self.corrections['distance_correction']['method'] = tkinter.StringVar(None, 'zero_force')
        self.corrections['distance_correction']['reference'] = tkinter.StringVar(None, 'extend')
        self.corrections['distance_correction']['smooth_applied'] = tkinter.BooleanVar(None, False)
        self.corrections['distance_correction']['smooth_length'] = tkinter.IntVar(None, 51)
        self.corrections['distance_correction']['length_fit'] = tkinter.IntVar(None, 10)
        self.corrections['get_tip_sample_separation'] = tkinter.BooleanVar(None,True)

        self.baseline_corr_lines = tkinter.BooleanVar(None,True)

        self.entry_var = {'smooth_length': tkinter.StringVar(None, 51), 'fit_length':tkinter.StringVar(None, 10)}

        #self.get_tip_sample_sep = tkinter.BooleanVar(None,True)

        self.control_parameter = QI_FD_Preview_object.control_parameter #that seems to work

        self.update_plot = QI_FD_Preview_object.update_plot #that seems to work

        # self.confirmed_corrections = dict()
        # self.confirmed_corrections['force_unit'] = None
        # self.confirmed_corrections['distance_unit'] = None
        # self.confirmed_corrections['baseline_correction'] = dict()
        # self.confirmed_corrections['baseline_correction']['method'] = None
        # self.confirmed_corrections['baseline_correction']['reference'] = None
        # self.confirmed_corrections['baseline_correction']['frac_data'] = {'min':None,'max':None}
        # self.confirmed_corrections['distance_correction'] = dict()
        # self.confirmed_corrections['distance_correction']['method'] = None
        # self.confirmed_corrections['distance_correction']['reference'] = None
        # self.confirmed_corrections['distance_correction']['smooth_applied'] = None
        # self.confirmed_corrections['distance_correction']['smooth_length'] = None
        # self.confirmed_corrections['distance_correction']['length_fit'] = None
        # self.confirmed_corrections['get_tip_sample_separation'] = None

        self.confirmed_corrections = dict()
        self.confirmed_corrections['force_unit'] = tkinter.StringVar(None)
        self.confirmed_corrections['distance_unit'] = tkinter.StringVar(None)
        self.confirmed_corrections['baseline_correction'] = dict()
        self.confirmed_corrections['baseline_correction']['method'] = tkinter.StringVar(None)
        self.confirmed_corrections['baseline_correction']['reference'] = tkinter.StringVar(None)
        self.confirmed_corrections['baseline_correction']['frac_data'] = {'min':tkinter.IntVar(None),'max':tkinter.IntVar(None)}
        self.confirmed_corrections['baseline_correction']['frac_data_str'] = tkinter.StringVar(None)
        self.confirmed_corrections['distance_correction'] = dict()
        self.confirmed_corrections['distance_correction']['method'] = tkinter.StringVar(None)
        self.confirmed_corrections['distance_correction']['reference'] = tkinter.StringVar(None)
        self.confirmed_corrections['distance_correction']['smooth_applied'] = tkinter.StringVar(None) #tkinter.BooleanVar(None)
        self.confirmed_corrections['distance_correction']['smooth_length'] = tkinter.StringVar(None) #tkinter.IntVar(None)
        self.confirmed_corrections['distance_correction']['length_fit'] = tkinter.StringVar(None) #tkinter.IntVar(None)
        self.confirmed_corrections['get_tip_sample_separation'] = tkinter.StringVar(None) #tkinter.BooleanVar(None)





    def on_closing(self):

        #self.update_corrections()
        self.control_parameter['correction_window'] = False
        self.control_parameter['baseline_correction_lines'] = False
        self.enter_window_app.destroy()
        self.enter_window_app = None
        self.distance_notebook = None




    def set_corrections(self):

        #https://stackoverflow.com/questions/49966750/python-tkinter-radiobutton-widget-works-in-a-single-window-but-not-in-multiple
        #This is one of the many screwy things that happen when you call Tk() more than once (once implicitly in Myapp, once explicitly in tutorial). You have to use Toplevel() instead to create additional windows.  jasonharper Apr 22 '18 at 14:37
        #As told by @jasonharper, the main error is to call Tk() twice in your program. Calling Tk() initializes the tcl/tk engine running behind the scene when working with tkinter, and strange things happen with running two different engines.

        if isinstance(self.enter_window_app, tkinter.Toplevel):

            self.enter_window_app.lift()
            self.enter_window_app.focus_set()

        else:


            self.enter_window_app = tkinter.Toplevel() #use tkinter.Tk() only once in an application
            self.enter_window_app.title('Force Curve Corrections')
            self.enter_window_app.resizable(False, False)
            self.enter_window_app.focus_set()

            self.control_parameter['apply_corrections'].set(True)
            self.control_parameter['correction_window'] = True
            self.control_parameter['baseline_correction_lines'] = True
            self.update_plot()

            frames = dict()
            frames['master_frame'] = dict()
            frames['master_frame']['frame'] = tkinter.Frame(self.enter_window_app)
            frames['master_frame']['frame'].grid(row = 0, column = 0, sticky = 'nsew')
            #frames['master_frame']['frame'].grid_propagate(False)

            frames['master_frame']['children'] = dict()
            frames['master_frame']['children']['units'] = {'frame':tkinter.Frame(frames['master_frame']['frame'])}
            frames['master_frame']['children']['baseline_corr'] = {'frame':tkinter.Frame(frames['master_frame']['frame'])}
            frames['master_frame']['children']['distance_corr'] = {'frame':tkinter.Frame(frames['master_frame']['frame'])}
            frames['master_frame']['children']['get_tip_sample_sep'] = {'frame':tkinter.Frame(frames['master_frame']['frame'])}
            frames['master_frame']['children']['Last'] = {'frame':tkinter.Frame(frames['master_frame']['frame'])}


            frames['master_frame']['children']['units']['frame'].grid(row = 1, column = 0, sticky = '')

            header = dict()
            header['units'] = tkinter.Label(frames['master_frame']['frame'], text = "Units", relief = 'ridge')
            header['baseline_corr'] = tkinter.Label(frames['master_frame']['frame'], text = "Baseline Correction", relief = 'ridge')
            header['distance_corr'] = tkinter.Label(frames['master_frame']['frame'], text = "Distance Correction", relief = 'ridge')
            header['get_tip_sample_sep'] = tkinter.Label(frames['master_frame']['frame'], text = "Distance Axis\Height Axis", relief = 'ridge')


            header['units'].grid(row = 0, column = 0, sticky = 'ew')
            frames['master_frame']['children']['units']['frame'].grid(row = 1, column = 0, sticky = '', padx = 10, pady = 5)
            header['baseline_corr'].grid(row = 2, column = 0, sticky = "ew")
            frames['master_frame']['children']['baseline_corr']['frame'].grid(row = 3, column = 0, sticky = 'ew', padx = 10, pady = 5)
            header['distance_corr'].grid(row = 4, column = 0, sticky = "ew")
            frames['master_frame']['children']['distance_corr']['frame'].grid(row = 5, column = 0, sticky = 'ew', padx = 10, pady = 5)
            header['get_tip_sample_sep'].grid(row = 6, column = 0, sticky = "ew")
            frames['master_frame']['children']['get_tip_sample_sep']['frame'].grid(row = 7, column = 0, sticky = 'ew', padx = 10, pady = 5)
            frames['master_frame']['children']['Last']['frame'].grid(row = 8, column = 0, sticky = "ew", padx = 10, pady = 5)

            #tkinter.ttk.Separator(frames['master_frame']['frame'], orient = 'horizontal').grid(row = 1, column = 0, sticky = 'ew')


            labels = dict()
            labels['units'] = dict()
            labels['units']['force_unit'] = tkinter.Label(frames['master_frame']['children']['units']['frame'], text = "Force axis:").grid(row = 1, column = 0, sticky = 'w')
            labels['units']['distance_unit'] = tkinter.Label(frames['master_frame']['children']['units']['frame'], text = "Distance axis:").grid(row = 2, column = 0, sticky = 'w')
            labels['baseline_corr'] = dict()
            #labels['distance_corr']['header'] = tkinter.Label(frames['master_frame']['children']['distance_corr']['frame'], text = "Distance Correction", relief = 'ridge').grid(row = 0, columnspan = 5, sticky = 'ew')
            labels['baseline_corr']['method'] = tkinter.Label(frames['master_frame']['children']['baseline_corr']['frame'], text = "Method:").grid(row = 0, column = 0, sticky = 'w')
            labels['baseline_corr']['reference'] = tkinter.Label(frames['master_frame']['children']['baseline_corr']['frame'], text = "Reference:").grid(row = 1, column = 0, sticky = 'w')
            labels['baseline_corr']['frac_data'] = tkinter.Label(frames['master_frame']['children']['baseline_corr']['frame'], text = "=== Data range for baseline correction ===").grid(row = 2, column = 0, columnspan = 5, sticky = '')
            #labels['baseline_corr']['show_lines'] = tkinter.Label(frames['master_frame']['children']['baseline_corr']['frame'], text = "Show lines for baseline correction:").grid(row = 4, column = 0, columnspan = 5, sticky = 'w')
            labels['distance_corr'] = dict()
            labels['distance_corr']['method'] = tkinter.Label(frames['master_frame']['children']['distance_corr']['frame'], text = "Method:").grid(row = 0, column = 0, sticky = 'w')
            labels['distance_corr']['reference'] = tkinter.Label(frames['master_frame']['children']['distance_corr']['frame'], text = "Reference:").grid(row = 1, column = 0, sticky = 'w')



            unit_buttons = dict()
            unit_buttons['N'] = tkinter.Radiobutton(frames['master_frame']['children']['units']['frame'], text='N', variable=self.corrections['force_unit'], value='N', command = self.update_plot).grid(row=1,column=1)
            unit_buttons['nN'] = tkinter.Radiobutton(frames['master_frame']['children']['units']['frame'], text='nN', variable=self.corrections['force_unit'], value='nN', command = self.update_plot).grid(row=1,column=2)
            unit_buttons['pN'] = tkinter.Radiobutton(frames['master_frame']['children']['units']['frame'], text='pN', variable=self.corrections['force_unit'], value='pN', command = self.update_plot).grid(row=1,column=3)
            unit_buttons['m'] = tkinter.Radiobutton(frames['master_frame']['children']['units']['frame'], text='m', variable=self.corrections['distance_unit'], value='m', command = self.update_plot).grid(row=2,column=1)
            unit_buttons['um'] = tkinter.Radiobutton(frames['master_frame']['children']['units']['frame'], text='um', variable=self.corrections['distance_unit'], value='um', command = self.update_plot).grid(row=2,column=2)
            unit_buttons['nm'] = tkinter.Radiobutton(frames['master_frame']['children']['units']['frame'], text='nm', variable=self.corrections['distance_unit'], value='nm', command = self.update_plot).grid(row=2,column=3)

            baseline_buttons = dict()
            baseline_buttons['method'] = dict()
            baseline_buttons['method']['constant'] = tkinter.Radiobutton(frames['master_frame']['children']['baseline_corr']['frame'], text='Constant', variable=self.corrections['baseline_correction']['method'], value='constant', command = self.update_plot).grid(row=0,column=1)
            baseline_buttons['method']['linear'] = tkinter.Radiobutton(frames['master_frame']['children']['baseline_corr']['frame'], text='Linear', variable=self.corrections['baseline_correction']['method'], value='linear', command = self.update_plot).grid(row=0,column=2)
            baseline_buttons['method']['quadratic'] = tkinter.Radiobutton(frames['master_frame']['children']['baseline_corr']['frame'], text='Quadratic', variable=self.corrections['baseline_correction']['method'], value='quadratic', command = self.update_plot).grid(row=0,column=3)
            baseline_buttons['reference'] = dict()
            baseline_buttons['reference']['individual'] = tkinter.Radiobutton(frames['master_frame']['children']['baseline_corr']['frame'], text='Individual', variable=self.corrections['baseline_correction']['reference'], value='individual', command = self.update_plot).grid(row=1,column=1)
            baseline_buttons['reference']['extent'] = tkinter.Radiobutton(frames['master_frame']['children']['baseline_corr']['frame'], text='Extend', variable=self.corrections['baseline_correction']['reference'], value='extend', command = self.update_plot).grid(row=1,column=2)
            baseline_buttons['reference']['retract'] = tkinter.Radiobutton(frames['master_frame']['children']['baseline_corr']['frame'], text='Retract', variable=self.corrections['baseline_correction']['reference'], value='retract', command = self.update_plot).grid(row=1,column=3)
            baseline_buttons['reference']['mean'] = tkinter.Radiobutton(frames['master_frame']['children']['baseline_corr']['frame'], text='Mean', variable=self.corrections['baseline_correction']['reference'], value='mean', command = self.update_plot).grid(row=1,column=4)

            distance_buttons = dict()
            distance_buttons['method'] = dict()
            distance_buttons['method']['constant'] = tkinter.Radiobutton(frames['master_frame']['children']['distance_corr']['frame'], text='Constant', variable=self.corrections['distance_correction']['method'], value='constant', command = self.set_distance_method_parameters).grid(row=0,column=1)
            distance_buttons['method']['zero_force'] = tkinter.Radiobutton(frames['master_frame']['children']['distance_corr']['frame'], text='Zero-Force Intersection', variable=self.corrections['distance_correction']['method'], value='zero_force', command = self.set_distance_method_parameters).grid(row=0,column=2)
            distance_buttons['method']['fit'] = tkinter.Radiobutton(frames['master_frame']['children']['distance_corr']['frame'], text='Fit', variable=self.corrections['distance_correction']['method'], value='fit', command = self.set_distance_method_parameters).grid(row=0,column=3)
            distance_buttons['reference'] = dict()
            distance_buttons['reference']['individual'] = tkinter.Radiobutton(frames['master_frame']['children']['distance_corr']['frame'], text='Individual', variable=self.corrections['distance_correction']['reference'], value='individual', command = self.update_plot).grid(row=1,column=1)
            distance_buttons['reference']['extent'] = tkinter.Radiobutton(frames['master_frame']['children']['distance_corr']['frame'], text='Extend', variable=self.corrections['distance_correction']['reference'], value='extend', command = self.update_plot).grid(row=1,column=2)
            distance_buttons['reference']['retract'] = tkinter.Radiobutton(frames['master_frame']['children']['distance_corr']['frame'], text='Retract', variable=self.corrections['distance_correction']['reference'], value='retract', command = self.update_plot).grid(row=1,column=3)
            distance_buttons['reference']['mean'] = tkinter.Radiobutton(frames['master_frame']['children']['distance_corr']['frame'], text='Mean', variable=self.corrections['distance_correction']['reference'], value='mean', command = self.update_plot).grid(row=1,column=4)

            self.distance_notebook = dict()
            self.distance_notebook['master'] = tkinter.ttk.Notebook(frames['master_frame']['children']['distance_corr']['frame'])
            self.distance_notebook['master'].grid(row = 2, column = 0, columnspan = 5, sticky = 'ew')
            self.distance_notebook['tab1'] = {'frame':tkinter.Frame(self.distance_notebook['master'])}
            self.distance_notebook['tab2'] = {'frame':tkinter.Frame(self.distance_notebook['master'])}
            self.distance_notebook['tab3'] = {'frame':tkinter.Frame(self.distance_notebook['master'])}
            self.distance_notebook['master'].add(self.distance_notebook['tab1']['frame'], text = f"{' ': ^20s}", state = 'disabled')
            self.distance_notebook['master'].add(self.distance_notebook['tab2']['frame'], text = f"{'Zero-Force Intersection Parameter': ^36s}", state = 'disabled')
            self.distance_notebook['master'].add(self.distance_notebook['tab3']['frame'], text = f"{'Fit Parameter': ^15s}", state = 'disabled')

            if self.corrections['distance_correction']['method'].get() == 'constant': #to make sure that the correct tab is selected after closing and reopening
                self.distance_notebook['master'].tab(self.distance_notebook['tab1']['frame'], state = 'normal')
                self.distance_notebook['master'].select(self.distance_notebook['tab1']['frame'])
            elif self.corrections['distance_correction']['method'].get() == 'zero_force':
                self.distance_notebook['master'].tab(self.distance_notebook['tab2']['frame'], state = 'normal')
                self.distance_notebook['master'].select(self.distance_notebook['tab2']['frame'])
            elif self.corrections['distance_correction']['method'].get() == 'fit':
                self.distance_notebook['master'].tab(self.distance_notebook['tab3']['frame'], state = 'normal')
                self.distance_notebook['master'].select(self.distance_notebook['tab3']['frame'])

            #self.distance_notebook['tab1']['label'] = tkinter.Label(self.distance_notebook['tab1']['frame'], text = "Tab 1 Tab 1 Tab 1:").grid(row = 0, column = 0, sticky = 'w')
            self.distance_notebook['tab2']['label1'] = tkinter.Label(self.distance_notebook['tab2']['frame'], text = "Apply smooth:").grid(row = 0, column = 0, sticky = 'w')
            self.distance_notebook['tab2']['smooth_applied'] = tkinter.Checkbutton(self.distance_notebook['tab2']['frame'], text = '', variable = self.corrections['distance_correction']['smooth_applied'], onvalue = True, offvalue = False, command = self.update_plot)
            self.distance_notebook['tab2']['smooth_applied'].grid(row = 0, column = 1)
            self.distance_notebook['tab2']['label2'] = tkinter.Label(self.distance_notebook['tab2']['frame'], text = "Smooth length:").grid(row = 0, column = 2, sticky = 'w')
            self.distance_notebook['tab2']['smooth_length_entry'] = tkinter.Entry(self.distance_notebook['tab2']['frame'], textvariable = self.entry_var['smooth_length'], width = 4, justify = 'right', bd = 3)
            self.distance_notebook['tab2']['smooth_length_entry'].grid(row = 0, column = 3)
            self.distance_notebook['tab3']['label'] = tkinter.Label(self.distance_notebook['tab3']['frame'], text = "Enter fit length:").grid(row = 0, column = 0, sticky = 'w')
            self.distance_notebook['tab3']['fit_length_entry'] = tkinter.Entry(self.distance_notebook['tab3']['frame'], textvariable = self.entry_var['fit_length'], width = 4, justify = 'right', bd = 3)
            self.distance_notebook['tab3']['fit_length_entry'].grid(row = 0, column = 1)

            slidebar_frame = tkinter.Frame(frames['master_frame']['children']['baseline_corr']['frame'])
            slidebar_frame.grid(row = 3, column = 0, columnspan = 5) #if not a separate line, the slidebar is in the main window
            slidebar = SlideBar(slidebar_frame, 200, 10, 5, self.corrections['baseline_correction']['frac_data'], self.update_plot)

            check_button_frame = tkinter.Frame(frames['master_frame']['children']['baseline_corr']['frame'])
            check_button_frame.grid(row = 4, column = 0, columnspan = 5, sticky = 'w')

            labels['baseline_corr']['show_lines'] = tkinter.Label(check_button_frame, text = "Show lines for baseline correction:").grid(row = 0, column = 0, sticky = 'w')

            check_buttons = dict()
            check_buttons['baseline_corr'] = tkinter.Checkbutton(check_button_frame, text = '', variable = self.baseline_corr_lines, onvalue = True, offvalue = False, command = self.activate_lines)
            check_buttons['baseline_corr'].grid(row = 0, column = 1)
            check_buttons['get_tip_sample_sep'] = tkinter.Checkbutton(frames['master_frame']['children']['get_tip_sample_sep']['frame'], text = 'Use tip sample separation', variable = self.corrections['get_tip_sample_separation'], onvalue = True, offvalue = False, command = self.update_plot)
            check_buttons['get_tip_sample_sep'].grid(row = 0, column = 0, sticky = 'w')


            button_apply = tkinter.Button(frames['master_frame']['children']['Last']['frame'], text = 'Confirm corrections', command = self.update_corrections)
            button_apply.grid(row = 0, column = 0)

            button_end = tkinter.Button(frames['master_frame']['children']['Last']['frame'], text = 'Done', command = self.on_closing)
            button_end.grid(row = 0, column = 1)


            self.distance_notebook['tab2']['smooth_length_entry'].bind('<Return>', self.enter_smooth_length)
            self.distance_notebook['tab3']['fit_length_entry'].bind('<Return>', self.enter_fit_length)

            self.enter_window_app.protocol("WM_DELETE_WINDOW", self.on_closing)
        #self.enter_window_app.mainloop()




    def update_corrections(self):

        self.parent.qi_object.sample_fd_curve['object'].correct_data(
                force_unit = self.corrections['force_unit'].get(),
                distance_unit = self.corrections['distance_unit'].get(),
                baseline_correction = {'method': self.corrections['baseline_correction']['method'].get(), 'reference': self.corrections['baseline_correction']['reference'].get(),'frac_data': (self.corrections['baseline_correction']['frac_data']['min'].get()/100, self.corrections['baseline_correction']['frac_data']['max'].get()/100)},
                distance_correction = {'method': self.corrections['distance_correction']['method'].get(), 'reference': self.corrections['distance_correction']['reference'].get(), 'smooth_applied': self.corrections['distance_correction']['smooth_applied'].get(), 'smooth_length': self.corrections['distance_correction']['smooth_length'].get(), 'fit_length': self.corrections['distance_correction']['length_fit'].get()},
                get_tip_sample_separation = self.corrections['get_tip_sample_separation'].get(),
                )
        self.parent.qi_object.set_corrections()

        #self.confirmed_corrections = self.parent.qi_object.corrections_pass_to_function


        self.confirmed_corrections['force_unit'].set(self.parent.qi_object.corrections_pass_to_function['force_unit'])
        self.confirmed_corrections['distance_unit'].set(self.parent.qi_object.corrections_pass_to_function['distance_unit'])

        self.confirmed_corrections['baseline_correction']['method'].set(self.parent.qi_object.corrections_pass_to_function['baseline_correction']['method'])
        self.confirmed_corrections['baseline_correction']['reference'].set(self.parent.qi_object.corrections_pass_to_function['baseline_correction']['reference'])
        self.confirmed_corrections['baseline_correction']['frac_data']['min'].set(self.parent.qi_object.corrections_pass_to_function['baseline_correction']['frac_data'][0])
        self.confirmed_corrections['baseline_correction']['frac_data']['max'].set(self.parent.qi_object.corrections_pass_to_function['baseline_correction']['frac_data'][1])

        frac_str = '(' + str(self.parent.qi_object.corrections_pass_to_function['baseline_correction']['frac_data'][0]) + ',' + str(self.parent.qi_object.corrections_pass_to_function['baseline_correction']['frac_data'][1]) + ')'
        self.confirmed_corrections['baseline_correction']['frac_data_str'].set(frac_str)

        self.confirmed_corrections['distance_correction']['method'].set(self.parent.qi_object.corrections_pass_to_function['distance_correction']['method'])
        self.confirmed_corrections['distance_correction']['reference'].set(self.parent.qi_object.corrections_pass_to_function['distance_correction']['reference'])
        self.confirmed_corrections['distance_correction']['smooth_applied'].set(str(self.parent.qi_object.corrections_pass_to_function['distance_correction']['smooth_applied']))
        self.confirmed_corrections['distance_correction']['smooth_length'].set(str(self.parent.qi_object.corrections_pass_to_function['distance_correction']['smooth_length']))
        self.confirmed_corrections['distance_correction']['length_fit'].set(str(self.parent.qi_object.corrections_pass_to_function['distance_correction']['length_fit']))
        self.confirmed_corrections['get_tip_sample_separation'].set(str(self.parent.qi_object.corrections_pass_to_function['get_tip_sample_separation']))


        self.parent.menu['menu_bar'].entryconfig(3, state = 'normal')

        self.control_parameter['apply_corrections'].set(True)

        #if self.parent.qi_object.control_variables['allow_analysis']:
        if self.parent.qi_object.control_variables['allow_analysis']:

            if self.control_parameter['standard_hertz_window']:
                self.parent.standard_hertz_window.analysis_control_panel['button']['run'].configure(state = 'normal')
                self.parent.standard_hertz_window.selection_panel['run_analysis_selection'].configure(state = 'normal')
            if self.control_parameter['multi_layer_segments_window']:
                self.parent.multi_layer_segments_window.analysis_control_panel['button']['run'].configure(state = 'normal')
                self.parent.multi_layer_segments_window.selection_panel['run_analysis_selection'].configure(state = 'normal')
            if self.control_parameter['apparent_layer_thickness_window']:
                self.parent.apparent_layer_thickness_window.analysis_control_panel['button']['run'].configure(state = 'normal')
            if self.control_parameter['breakthrough_events_window']:
                self.parent.breakthrough_events_window.analysis_control_panel['button_run'].configure(state = 'normal')

        self.update_plot()




    def reset_corrections(self):

        self.confirmed_corrections['force_unit'].set('')
        self.confirmed_corrections['distance_unit'].set('')
        #self.confirmed_corrections['baseline_correction'] = dict()
        self.confirmed_corrections['baseline_correction']['method'].set('')
        self.confirmed_corrections['baseline_correction']['reference'].set('')
        #self.confirmed_corrections['baseline_correction']['frac_data']['min'].set(None)
        #self.confirmed_corrections['baseline_correction']['frac_data']['max'].set(None)
        self.confirmed_corrections['baseline_correction']['frac_data_str'].set('')
        #self.confirmed_corrections['distance_correction'] = dict()
        self.confirmed_corrections['distance_correction']['method'].set('')
        self.confirmed_corrections['distance_correction']['reference'].set('')
        self.confirmed_corrections['distance_correction']['smooth_applied'].set('') #tkinter.BooleanVar(None)
        self.confirmed_corrections['distance_correction']['smooth_length'].set('') #tkinter.IntVar(None)
        self.confirmed_corrections['distance_correction']['length_fit'].set('') #tkinter.IntVar(None)
        self.confirmed_corrections['get_tip_sample_separation'].set('') #tkinter.BooleanVar(None)


        self.control_parameter['apply_corrections'].set(False)
        self.parent.qi_object.control_variables['allow_analysis'] = False

        if self.control_parameter['multi_layer_segments_window']:
            self.parent.multi_layer_segments_window.analysis_control_panel['button']['run'].configure(state = 'disabled')
            self.parent.multi_layer_segments_window.selection_panel['run_analysis_selection'].configure(state = 'disabled')
        if self.control_parameter['apparent_layer_thickness_window']:
            self.parent.apparent_layer_thickness_window.analysis_control_panel['button']['run'].configure(state = 'disabled')





    def _on_loading_qi_snapshot(self):

        if len(self.parent.qi_object.corrections):

            self.corrections['force_unit'].set(self.parent.qi_object.corrections_pass_to_function['force_unit'])
            self.corrections['distance_unit'].set(self.parent.qi_object.corrections_pass_to_function['distance_unit'])

            self.corrections['baseline_correction']['method'].set(self.parent.qi_object.corrections_pass_to_function['baseline_correction']['method'])
            self.corrections['baseline_correction']['reference'].set(self.parent.qi_object.corrections_pass_to_function['baseline_correction']['reference'])
            self.corrections['baseline_correction']['frac_data']['min'].set(self.parent.qi_object.corrections_pass_to_function['baseline_correction']['frac_data'][0]*100)
            self.corrections['baseline_correction']['frac_data']['max'].set(self.parent.qi_object.corrections_pass_to_function['baseline_correction']['frac_data'][1]*100)

            self.corrections['distance_correction']['method'].set(self.parent.qi_object.corrections_pass_to_function['distance_correction']['method'])
            self.corrections['distance_correction']['reference'].set(self.parent.qi_object.corrections_pass_to_function['distance_correction']['reference'])
            self.corrections['distance_correction']['smooth_applied'].set(self.parent.qi_object.corrections_pass_to_function['distance_correction']['smooth_applied'])
            self.corrections['distance_correction']['smooth_length'].set(self.parent.qi_object.corrections_pass_to_function['distance_correction']['smooth_length'])
            self.corrections['distance_correction']['length_fit'].set(self.parent.qi_object.corrections_pass_to_function['distance_correction']['length_fit'])
            self.corrections['get_tip_sample_separation'].set(self.parent.qi_object.corrections_pass_to_function['get_tip_sample_separation'])


            self.confirmed_corrections['force_unit'].set(self.parent.qi_object.corrections_pass_to_function['force_unit'])
            self.confirmed_corrections['distance_unit'].set(self.parent.qi_object.corrections_pass_to_function['distance_unit'])

            self.confirmed_corrections['baseline_correction']['method'].set(self.parent.qi_object.corrections_pass_to_function['baseline_correction']['method'])
            self.confirmed_corrections['baseline_correction']['reference'].set(self.parent.qi_object.corrections_pass_to_function['baseline_correction']['reference'])
            self.confirmed_corrections['baseline_correction']['frac_data']['min'].set(self.parent.qi_object.corrections_pass_to_function['baseline_correction']['frac_data'][0])
            self.confirmed_corrections['baseline_correction']['frac_data']['max'].set(self.parent.qi_object.corrections_pass_to_function['baseline_correction']['frac_data'][1])

            frac_str = '(' + str(self.parent.qi_object.corrections_pass_to_function['baseline_correction']['frac_data'][0]) + ',' + str(self.parent.qi_object.corrections_pass_to_function['baseline_correction']['frac_data'][1]) + ')'
            self.confirmed_corrections['baseline_correction']['frac_data_str'].set(frac_str)

            self.confirmed_corrections['distance_correction']['method'].set(self.parent.qi_object.corrections_pass_to_function['distance_correction']['method'])
            self.confirmed_corrections['distance_correction']['reference'].set(self.parent.qi_object.corrections_pass_to_function['distance_correction']['reference'])
            self.confirmed_corrections['distance_correction']['smooth_applied'].set(str(self.parent.qi_object.corrections_pass_to_function['distance_correction']['smooth_applied']))
            self.confirmed_corrections['distance_correction']['smooth_length'].set(str(self.parent.qi_object.corrections_pass_to_function['distance_correction']['smooth_length']))
            self.confirmed_corrections['distance_correction']['length_fit'].set(str(self.parent.qi_object.corrections_pass_to_function['distance_correction']['length_fit']))
            self.confirmed_corrections['get_tip_sample_separation'].set(str(self.parent.qi_object.corrections_pass_to_function['get_tip_sample_separation']))


            self.parent.menu['menu_bar'].entryconfig(3, state = 'normal')

            self.control_parameter['apply_corrections'].set(True)

            if self.control_parameter['standard_hertz_window']:
                self.parent.standard_hertz_window.analysis_control_panel['button']['run'].configure(state = 'normal')
                self.parent.standard_hertz_window.selection_panel['run_analysis_selection'].configure(state = 'normal')
            if self.control_parameter['multi_layer_segments_window']:
                self.parent.multi_layer_segments_window.analysis_control_panel['button']['run'].configure(state = 'normal')
                self.parent.multi_layer_segments_window.selection_panel['run_analysis_selection'].configure(state = 'normal')
            if self.control_parameter['apparent_layer_thickness_window']:
                self.parent.apparent_layer_thickness_window.analysis_control_panel['button']['run'].configure(state = 'normal')
            if self.control_parameter['breakthrough_events_window']:
                self.parent.breakthrough_events_window.analysis_control_panel['button_run'].configure(state = 'normal')


            if self.control_parameter['correction_window']:

                self.set_distance_method_parameters() #also includes an update plot

            else:

                self.update_plot()




        else: #nothing corrected yet

            self.reset_corrections()




    def activate_lines(self):

        self.control_parameter['baseline_correction_lines'] = self.baseline_corr_lines.get()
        self.update_plot()



    def set_distance_method_parameters(self):

        self.update_plot()

        if self.corrections['distance_correction']['method'].get() == 'constant':

            self.distance_notebook['master'].tab(self.distance_notebook['tab1']['frame'], state = 'normal')
            self.distance_notebook['master'].tab(self.distance_notebook['tab2']['frame'], state = 'disabled')
            self.distance_notebook['master'].tab(self.distance_notebook['tab3']['frame'], state = 'disabled')

            self.distance_notebook['master'].select(self.distance_notebook['tab1']['frame'])


        elif self.corrections['distance_correction']['method'].get() == 'zero_force':

            self.distance_notebook['master'].tab(self.distance_notebook['tab1']['frame'], state = 'disabled')
            self.distance_notebook['master'].tab(self.distance_notebook['tab2']['frame'], state = 'normal')
            self.distance_notebook['master'].tab(self.distance_notebook['tab3']['frame'], state = 'disabled')

            self.distance_notebook['master'].select(self.distance_notebook['tab2']['frame'])


        elif self.corrections['distance_correction']['method'].get() == 'fit':

            self.distance_notebook['master'].tab(self.distance_notebook['tab1']['frame'], state = 'disabled')
            self.distance_notebook['master'].tab(self.distance_notebook['tab2']['frame'], state = 'disabled')
            self.distance_notebook['master'].tab(self.distance_notebook['tab3']['frame'], state = 'normal')

            self.distance_notebook['master'].select(self.distance_notebook['tab3']['frame'])





    def enter_smooth_length(self,event):

        conv = self.entry_var['smooth_length'].get()

        if conv.isdecimal():

            conv = int(self.entry_var['smooth_length'].get())

            if conv >= 0 and conv <= 0.5 * self.parent.qi_object.sample_fd_curve['object'].settings['samples']['extend']:

                self.corrections['distance_correction']['smooth_length'].set(conv)
                self.update_plot()

            elif conv > 0.5 * self.parent.qi_object.sample_fd_curve['object'].settings['samples']['extend']:

                self.corrections['distance_correction']['smooth_length'].set(0.5 * self.parent.qi_object.sample_fd_curve['object'].settings['samples']['extend'])
                self.entry_var['smooth_length'].set(int(0.5 * self.parent.qi_object.sample_fd_curve['object'].settings['samples']['extend']))
                self.update_plot()

        else:


            self.enter_window_app.bell()
#            self.bell() #does not work because self did not inherit tkinter.Tk
#            self.parent.bell() #a handle to the QI_FD_preview object would be necessary as QI_FD_preview is an instance of the tkinter.Tk
#            self.root.bell() # if tkinter.Tk is not a parent class but just an member of the QI_FD_preview, root would be the handle to that member


    def enter_fit_length(self,event):

        conv = self.entry_var['fit_length'].get()

        if conv.isdecimal():

            conv = int(self.entry_var['fit_length'].get())

            if conv >= 0 and conv <= 0.2 * self.parent.qi_object.sample_fd_curve['object'].settings['samples']['extend']:

                self.corrections['distance_correction']['length_fit'].set(conv)
                self.update_plot()

            elif conv > 0.2 * self.parent.qi_object.sample_fd_curve['object'].settings['samples']['extend']:

                self.corrections['distance_correction']['length_fit'].set(0.2 * self.parent.qi_object.sample_fd_curve['object'].settings['samples']['extend'])
                self.entry_var['fit_length'].set(int(0.2 * self.parent.qi_object.sample_fd_curve['object'].settings['samples']['extend']))
                self.update_plot()

        else:

            self.enter_window_app.bell()




class ModifyCantileverCalibrationWindow():


    def __init__(self,QI_FD_Preview_object):

        #self.root = QI_FD_Preview_object.root
        self.parent = QI_FD_Preview_object
        self.control_parameter = QI_FD_Preview_object.control_parameter
        self.update_plot = QI_FD_Preview_object.update_plot
        self.menu = QI_FD_Preview_object.menu

        self.enter_window_app = None

        self.entry_sensitivity = {'sensitivity': tkinter.StringVar(None), 'sensitivity_scale': tkinter.DoubleVar(None, 0), 'scale_label': tkinter.DoubleVar(None, 0)}
        self.entry_spring_constant = {'spring_constant': tkinter.StringVar(None), 'spring_constant_scale': tkinter.DoubleVar(None, 0), 'scale_label': tkinter.DoubleVar(None, 0)}

        self.entry_sensitivity = {'sensitivity': tkinter.StringVar(None), 'sensitivity_scale': tkinter.DoubleVar(None, 0), 'scale_label': tkinter.DoubleVar(None, 0)}
        self.entry_spring_constant = {'spring_constant': tkinter.StringVar(None), 'spring_constant_scale': tkinter.DoubleVar(None, 0), 'scale_label': tkinter.DoubleVar(None, 0)}

        self.sensitivity = dict()
        self.sensitivity['new_start'] = tkinter.DoubleVar(None, 0)
        self.sensitivity['new_tentative'] = tkinter.DoubleVar(None, 0)
        self.sensitivity['new_final'] = tkinter.DoubleVar(None)
        self.sensitivity['updated_label'] = tkinter.StringVar(None, str(np.round(0, decimals = 2)) + ' nm/V')
        self.sensitivity['status'] = tkinter.StringVar(None, 'original')

        self.spring_constant = dict()
        self.spring_constant['new_start'] = tkinter.DoubleVar(None, 0)
        self.spring_constant['new_tentative'] = tkinter.DoubleVar(None, 0)
        self.spring_constant['new_final'] = tkinter.DoubleVar(None)
        self.spring_constant['updated_label'] = tkinter.StringVar(None, str(np.round(0, decimals = 3)) + ' nN/nm')
        self.spring_constant['status'] = tkinter.StringVar(None, 'original')

        self.tag = {'sensitivity': None, 'spring_constant': None}










    def modify_calibration(self):

        if isinstance(self.enter_window_app, tkinter.Toplevel):

            self.enter_window_app.lift()
            self.enter_window_app.focus_set()

        else:

            self.enter_window_app = tkinter.Toplevel() #use tkinter.Tk() only once in an application
            self.enter_window_app.title('Cantilever Calibrations')
            self.enter_window_app.resizable(False, False)
            self.enter_window_app.focus_set()



            frames = dict()
            frames['master_frame'] = dict()
            frames['master_frame']['frame'] = tkinter.Frame(self.enter_window_app)
            frames['master_frame']['frame'].grid(row = 0, column = 0, sticky = 'nsew')
            frames['master_frame']['children'] = dict()
            frames['master_frame']['children']['sensitivity'] = {'frame':tkinter.Frame(frames['master_frame']['frame'])}
            frames['master_frame']['children']['spring_constant'] = {'frame':tkinter.Frame(frames['master_frame']['frame'])}
            frames['master_frame']['children']['last'] = {'frame':tkinter.Frame(frames['master_frame']['frame'])}


            header = dict()
            header['sensitivity'] = tkinter.Label(frames['master_frame']['frame'], text = "Sensitivity", relief = 'ridge')
            header['spring_constant'] = tkinter.Label(frames['master_frame']['frame'], text = "Spring constant", relief = 'ridge')

            header['sensitivity'].grid(row = 0, column = 0, sticky = 'ew')
            frames['master_frame']['children']['sensitivity']['frame'].grid(row = 1, column = 0, sticky = 'ew', padx = 10, pady = 5)
            header['spring_constant'].grid(row = 2, column = 0, sticky = 'ew')
            frames['master_frame']['children']['spring_constant']['frame'].grid(row = 3, column = 0, sticky = 'ew', padx = 10, pady = 5)
            frames['master_frame']['children']['last']['frame'].grid(row = 4, column = 0, sticky = 'ew', padx = 10, pady = 5)


            sensitivity_input = dict()
            sensitivity_input['label1'] = tkinter.Label(frames['master_frame']['children']['sensitivity']['frame'], text = 'Original Value:')
            sensitivity_input['label2'] = tkinter.Label(frames['master_frame']['children']['sensitivity']['frame'], text = 'Updated Value:')
            sensitivity_input['value_original'] = tkinter.Label(frames['master_frame']['children']['sensitivity']['frame'], text = str(np.round(self.parent.qi_object.jpk_qi_data.calibrations['sensitivity']*1e9, decimals = 2)) + ' nm/V', width = 15, anchor = 'e')
            sensitivity_input['value_updated'] = tkinter.Label(frames['master_frame']['children']['sensitivity']['frame'], textvariable = self.sensitivity['updated_label'], width = 15, anchor = 'e')
            sensitivity_input['spacer'] = tkinter.Frame(frames['master_frame']['children']['sensitivity']['frame'], width = 20)#, background = '#123456')
            sensitivity_input['label3'] = tkinter.Label(frames['master_frame']['children']['sensitivity']['frame'], text = 'Enter new senstivity value: ')
            sensitivity_input['entry'] = tkinter.Entry(frames['master_frame']['children']['sensitivity']['frame'], textvariable = self.entry_sensitivity['sensitivity'], width = 7, justify = 'right', bd = 3)
            sensitivity_input['scale'] = tkinter.Scale(frames['master_frame']['children']['sensitivity']['frame'], from_ = -1, to = 1, orient = 'horizontal', resolution = 0.01, showvalue = 0, variable = self.entry_sensitivity['sensitivity_scale'], command = self._sensitivity_slider_motion )
            sensitivity_input['scale_label'] = tkinter.Label(frames['master_frame']['children']['sensitivity']['frame'], textvariable = self.entry_sensitivity['scale_label'])
            sensitivity_input['status_label_1'] = tkinter.Label(frames['master_frame']['children']['sensitivity']['frame'], text = 'Sensitivity in analysis:     ')
            sensitivity_input['status_label_2'] = tkinter.Label(frames['master_frame']['children']['sensitivity']['frame'], textvariable = self.sensitivity['status'], width = 10, anchor = 'e', fg = '#ff0000')
            sensitivity_input['button1'] = tkinter.Button(frames['master_frame']['children']['sensitivity']['frame'], text = 'Confirm new sensitivity', command = self._confirm_sensitivity_value)
            sensitivity_input['button2'] = tkinter.Button(frames['master_frame']['children']['sensitivity']['frame'], text = 'Reset', command = self._reset_sensitivity_value)

            sensitivity_input['label1'].grid(row = 0, column = 0, sticky = 'w')
            sensitivity_input['value_original'].grid(row = 0, column = 1, sticky = 'e')
            sensitivity_input['label2'].grid(row = 1, column = 0, sticky = 'w')
            sensitivity_input['value_updated'].grid(row = 1, column = 1, sticky = 'e')
            sensitivity_input['spacer'].grid(row = 0, rowspan = 2, column = 2, sticky = 'nsew')
            sensitivity_input['label3'].grid(row = 0, column = 3, columnspan = 2, sticky = 'w')
            sensitivity_input['scale'].grid(row = 1, column = 3)
            sensitivity_input['entry'].grid(row = 1, column = 4, sticky = '', padx = 5)
            sensitivity_input['status_label_1'].grid(row = 2, rowspan = 2, column = 0, sticky = 'w')
            sensitivity_input['status_label_2'].grid(row = 2, rowspan = 2, column = 1, sticky = 'e')
            sensitivity_input['scale_label'].grid(row = 2, column = 3)
            sensitivity_input['button1'].grid(row = 3, column = 3, columnspan = 2)
            sensitivity_input['button2'].grid(row = 4, column = 3, columnspan = 2)

            spring_constant_input = dict()
            spring_constant_input['label1'] = tkinter.Label(frames['master_frame']['children']['spring_constant']['frame'], text = 'Original Value:')
            spring_constant_input['label2'] = tkinter.Label(frames['master_frame']['children']['spring_constant']['frame'], text = 'Updated Value:')
            spring_constant_input['value_original'] = tkinter.Label(frames['master_frame']['children']['spring_constant']['frame'], text = str(np.round(self.parent.qi_object.jpk_qi_data.calibrations['spring_constant'], decimals = 3)) + ' nN/nm', width = 15, anchor = 'e')
            spring_constant_input['value_updated'] = tkinter.Label(frames['master_frame']['children']['spring_constant']['frame'], textvariable = self.spring_constant['updated_label'], width = 15, anchor = 'e')
            spring_constant_input['spacer'] = tkinter.Frame(frames['master_frame']['children']['spring_constant']['frame'], width = 20)#, background = '#123456')
            spring_constant_input['label3'] = tkinter.Label(frames['master_frame']['children']['spring_constant']['frame'], text = 'Enter new spring constant value: ')
            spring_constant_input['entry'] = tkinter.Entry(frames['master_frame']['children']['spring_constant']['frame'], textvariable = self.entry_spring_constant['spring_constant'], width = 7, justify = 'right', bd = 3)
            spring_constant_input['scale'] = tkinter.Scale(frames['master_frame']['children']['spring_constant']['frame'], from_ = -0.3, to = 0.3, orient = 'horizontal', resolution = 0.01, showvalue = 0, variable = self.entry_spring_constant['spring_constant_scale'], command = self._spring_constant_slider_motion )
            spring_constant_input['scale_label'] = tkinter.Label(frames['master_frame']['children']['spring_constant']['frame'], textvariable = self.entry_spring_constant['scale_label'])
            spring_constant_input['status_label_1'] = tkinter.Label(frames['master_frame']['children']['spring_constant']['frame'], text = 'Spring_constant in analysis:     ')
            spring_constant_input['status_label_2'] = tkinter.Label(frames['master_frame']['children']['spring_constant']['frame'], textvariable = self.spring_constant['status'], width = 10, anchor = 'e', fg = '#ff0000')
            spring_constant_input['button1'] = tkinter.Button(frames['master_frame']['children']['spring_constant']['frame'], text = 'Confirm new spring constant', command = self._confirm_spring_constant_value)
            spring_constant_input['button2'] = tkinter.Button(frames['master_frame']['children']['spring_constant']['frame'], text = 'Reset', command = self._reset_spring_constant_value)

            spring_constant_input['label1'].grid(row = 0, column = 0, sticky = 'w')
            spring_constant_input['value_original'].grid(row = 0, column = 1, sticky = 'e')
            spring_constant_input['label2'].grid(row = 1, column = 0, sticky = 'w')
            spring_constant_input['value_updated'].grid(row = 1, column = 1, sticky = 'e')
            spring_constant_input['spacer'].grid(row = 0, rowspan = 2, column = 2, sticky = 'nsew')
            spring_constant_input['label3'].grid(row = 0, column = 3, columnspan = 2, sticky = 'w')
            spring_constant_input['scale'].grid(row = 1, column = 3)
            spring_constant_input['entry'].grid(row = 1, column = 4, sticky = '', padx = 5)
            spring_constant_input['status_label_1'].grid(row = 2, rowspan = 2, column = 0, sticky = 'w')
            spring_constant_input['status_label_2'].grid(row = 2, rowspan = 2, column = 1, sticky = 'e')
            spring_constant_input['scale_label'].grid(row = 2, column = 3)
            spring_constant_input['button1'].grid(row = 3, column = 3, columnspan = 2)
            spring_constant_input['button2'].grid(row = 4, column = 3, columnspan = 2)


            sensitivity_input['entry'].bind('<Return>', self._enter_sensitivity)
            sensitivity_input['entry'].bind('<KeyRelease>', self._entry_release_sensitivity)
            sensitivity_input['scale'].bind('<ButtonRelease-1>', self._slider_release_sensitivity)

            spring_constant_input['entry'].bind('<Return>', self._enter_spring_constant)
            spring_constant_input['entry'].bind('<KeyRelease>', self._entry_release_spring_constant)
            spring_constant_input['scale'].bind('<ButtonRelease-1>', self._slider_release_spring_constant)

            self.enter_window_app.protocol("WM_DELETE_WINDOW", self.on_closing)





    def on_closing(self):

        self.enter_window_app.destroy()
        self.enter_window_app = None




    def _on_open_new_qi_map(self):

        if self.control_parameter['modify_cantilever_calibration']['sensitivity'].get():

            self.entry_sensitivity['sensitivity_scale'].set(0)
            self.entry_sensitivity['sensitivity'].set('')
            self.entry_sensitivity['scale_label'].set(np.round(self.parent.qi_object.jpk_qi_data.calibrations['sensitivity']*1e9, decimals = 2))

            self.sensitivity['new_start'].set(self.parent.qi_object.jpk_qi_data.calibrations['sensitivity']*1e9)
            self.sensitivity['new_tentative'].set(self.parent.qi_object.jpk_qi_data.calibrations['sensitivity']*1e9)
            self.sensitivity['new_final'].set(0)
            self.sensitivity['updated_label'].set(str(np.round(self.sensitivity['new_final'].get(), decimals = 2)) + ' nm/V')

            self.control_parameter['modify_cantilever_calibration']['sensitivity'].set(False)
            self.sensitivity['status'].set('original')
            self.tag['sensitivity'] = None
            self.menu['corrections'].entryconfig(5, state = 'disabled')

        if self.control_parameter['modify_cantilever_calibration']['spring_constant'].get():

            self.entry_spring_constant['spring_constant_scale'].set(0)
            self.entry_spring_constant['spring_constant'].set('')
            self.entry_spring_constant['scale_label'].set(np.round(self.parent.qi_object.jpk_qi_data.calibrations['spring_constant'], decimals = 3))

            self.spring_constant['new_start'].set(self.parent.qi_object.jpk_qi_data.calibrations['spring_constant'])
            self.spring_constant['new_tentative'].set(self.parent.qi_object.jpk_qi_data.calibrations['spring_constant'])
            self.spring_constant['new_final'].set(0)
            self.spring_constant['updated_label'].set(str(np.round(self.spring_constant['new_final'].get(), decimals = 3)) + ' nN/nm')

            self.control_parameter['modify_cantilever_calibration']['spring_constant'].set(False)
            self.spring_constant['status'].set('original')
            self.tag['spring_constant'] = None
            self.menu['corrections'].entryconfig(6, state = 'disabled')

        # update plot does not work yet.
        #self.menu['corrections'].entryconfig(5, state = 'disabled')
        #self.menu['corrections'].entryconfig(6, state = 'disabled')




    def _on_loading_qi_snapshot(self):

        if self.parent.qi_object.calibrations['modified']['sensitivity']:

            self.entry_sensitivity['sensitivity_scale'].set(0)
            self.entry_sensitivity['sensitivity'].set('')
            self.entry_sensitivity['scale_label'].set(np.round(self.parent.qi_object.calibrations['sensitivity']*1e9, decimals = 2))

            self.sensitivity['new_start'].set(self.parent.qi_object.calibrations['sensitivity']*1e9)
            self.sensitivity['new_tentative'].set(self.parent.qi_object.calibrations['sensitivity']*1e9)
            self.sensitivity['new_final'].set(self.parent.qi_object.calibrations['sensitivity']*1e9)
            self.sensitivity['updated_label'].set(str(np.round(self.sensitivity['new_final'].get(), decimals = 2)) + ' nm/V')

            self.control_parameter['modify_cantilever_calibration']['sensitivity'].set(True)
            self.sensitivity['status'].set('updated')
            self.tag['sensitivity'] = None
            self.menu['corrections'].entryconfig(5, state = 'normal')

        else:

            self.entry_sensitivity['sensitivity_scale'].set(0)
            self.entry_sensitivity['sensitivity'].set('')
            self.entry_sensitivity['scale_label'].set(np.round(self.parent.qi_object.jpk_qi_data.calibrations['sensitivity']*1e9, decimals = 2))

            self.sensitivity['new_start'].set(self.parent.qi_object.jpk_qi_data.calibrations['sensitivity']*1e9)
            self.sensitivity['new_tentative'].set(self.parent.qi_object.jpk_qi_data.calibrations['sensitivity']*1e9)
            self.sensitivity['new_final'].set(0)
            self.sensitivity['updated_label'].set(str(np.round(self.sensitivity['new_final'].get(), decimals = 2)) + ' nm/V')

            self.control_parameter['modify_cantilever_calibration']['sensitivity'].set(False)
            self.sensitivity['status'].set('original')
            self.tag['sensitivity'] = None
            self.menu['corrections'].entryconfig(5, state = 'disabled')


        if self.parent.qi_object.calibrations['modified']['spring_constant']:

            self.entry_spring_constant['spring_constant_scale'].set(0)
            self.entry_spring_constant['spring_constant'].set('')
            self.entry_spring_constant['scale_label'].set(np.round(self.parent.qi_object.calibrations['spring_constant'], decimals = 3))

            self.spring_constant['new_start'].set(self.parent.qi_object.calibrations['spring_constant'])
            self.spring_constant['new_tentative'].set(self.parent.qi_object.calibrations['spring_constant'])
            self.spring_constant['new_final'].set(self.parent.qi_object.calibrations['spring_constant'])
            self.spring_constant['updated_label'].set(str(np.round(self.spring_constant['new_final'].get(), decimals = 3)) + ' nN/nm')

            self.control_parameter['modify_cantilever_calibration']['spring_constant'].set(True)
            self.spring_constant['status'].set('updated')
            self.tag['spring_constant'] = None
            self.menu['corrections'].entryconfig(6, state = 'normal')

        else:

            self.entry_spring_constant['spring_constant_scale'].set(0)
            self.entry_spring_constant['spring_constant'].set('')
            self.entry_spring_constant['scale_label'].set(np.round(self.parent.qi_object.jpk_qi_data.calibrations['spring_constant'], decimals = 3))

            self.spring_constant['new_start'].set(self.parent.qi_object.jpk_qi_data.calibrations['spring_constant'])
            self.spring_constant['new_tentative'].set(self.parent.qi_object.jpk_qi_data.calibrations['spring_constant'])
            self.spring_constant['new_final'].set(0)
            self.spring_constant['updated_label'].set(str(np.round(self.spring_constant['new_final'].get(), decimals = 3)) + ' nN/nm')

            self.control_parameter['modify_cantilever_calibration']['spring_constant'].set(False)
            self.spring_constant['status'].set('original')
            self.tag['spring_constant'] = None
            self.menu['corrections'].entryconfig(6, state = 'disabled')










    def _slider_release_sensitivity(self,event):
        self.tag['sensitivity'] = 'slider'


    def _entry_release_sensitivity(self,event):
        self.tag['sensitivity'] = 'entry'


    def _slider_release_spring_constant(self,event):
        self.tag['spring_constant'] = 'slider'


    def _entry_release_spring_constant(self,event):
        self.tag['spring_constant'] = 'entry'


    def _enter_sensitivity(self,event):

        conv = self.entry_sensitivity['sensitivity'].get()

        try:

            conv = float(conv)

            if conv > 0:

                self.sensitivity['new_tentative'].set(conv)
                self.sensitivity['new_start'].set(conv)
                self.entry_sensitivity['sensitivity_scale'].set(0)
                self.entry_sensitivity['scale_label'].set(np.round(self.sensitivity['new_tentative'].get(),decimals = 2))

                self.tag['sensitivity'] = 'entry'

                self.update_plot()

        except:

            self.enter_window_app.bell()


    def _enter_spring_constant(self,event):

        conv = self.entry_spring_constant['spring_constant'].get()

        try:

            conv = float(conv)

            if conv > 0:

                self.spring_constant['new_tentative'].set(conv)
                self.spring_constant['new_start'].set(conv)
                self.entry_spring_constant['spring_constant_scale'].set(0)
                self.entry_spring_constant['scale_label'].set(np.round(self.spring_constant['new_tentative'].get(),decimals = 3))

                self.tag['spring_constant'] = 'entry'

                self.update_plot()

        except:

            self.enter_window_app.bell()




    def _sensitivity_slider_motion(self, event):

        self.sensitivity['new_tentative'].set(self.sensitivity['new_start'].get()* np.power(10,self.entry_sensitivity['sensitivity_scale'].get()))
        self.entry_sensitivity['scale_label'].set(np.round(self.sensitivity['new_tentative'].get(),decimals = 2))
        self.update_plot()


    def _spring_constant_slider_motion(self, event):

        self.spring_constant['new_tentative'].set(self.spring_constant['new_start'].get()* np.power(10,self.entry_spring_constant['spring_constant_scale'].get()))
        self.entry_spring_constant['scale_label'].set(np.round(self.spring_constant['new_tentative'].get(),decimals = 3))
        self.update_plot()




    def _confirm_sensitivity_value(self):

        if self.tag['sensitivity'] == 'slider':

            self.sensitivity['new_start'].set(self.sensitivity['new_tentative'].get())
            self.entry_sensitivity['sensitivity_scale'].set(0)
            self.entry_sensitivity['scale_label'].set(np.round(self.sensitivity['new_tentative'].get(),decimals = 2))


            self.sensitivity['new_final'].set(self.sensitivity['new_tentative'].get())
            self.sensitivity['updated_label'].set(str(np.round(self.sensitivity['new_final'].get(), decimals = 2)) + ' nm/V')

            self.control_parameter['modify_cantilever_calibration']['sensitivity'].set(True)
            self.sensitivity['status'].set('updated')
            self.menu['corrections'].entryconfig(5, state = 'normal')

            self.parent.qi_object.set_sensitivity(self.sensitivity['new_tentative'].get()/1e9)
            self.update_plot()



        elif self.tag['sensitivity'] == 'entry':

            conv = self.entry_sensitivity['sensitivity'].get()

            try:

                conv = float(conv)

                if conv > 0:

                    self.sensitivity['new_tentative'].set(conv)
                    self.sensitivity['new_start'].set(conv)
                    self.entry_sensitivity['sensitivity_scale'].set(0)
                    self.entry_sensitivity['scale_label'].set(np.round(self.sensitivity['new_tentative'].get(),decimals = 2))

                    self.sensitivity['new_final'].set(self.sensitivity['new_tentative'].get())
                    self.sensitivity['updated_label'].set(str(np.round(self.sensitivity['new_final'].get(), decimals = 2)) + ' nm/V')

                    self.control_parameter['modify_cantilever_calibration']['sensitivity'].set(True)
                    self.sensitivity['status'].set('updated')
                    self.menu['corrections'].entryconfig(5, state = 'normal')

                    self.parent.qi_object.set_sensitivity(self.sensitivity['new_tentative'].get()/1e9)
                    self.update_plot()

            except:

                self.enter_window_app.bell()


        else:

#            self.enter_window_app.bell() #messagebox.warning makes a sound already
            tkinter.messagebox.showwarning(message = 'Specify new sensitivity first!')


    def _confirm_spring_constant_value(self):

        if self.tag['spring_constant'] == 'slider':

            self.spring_constant['new_start'].set(self.spring_constant['new_tentative'].get())
            self.entry_spring_constant['spring_constant_scale'].set(0)
            self.entry_spring_constant['scale_label'].set(np.round(self.spring_constant['new_tentative'].get(),decimals = 3))


            self.spring_constant['new_final'].set(self.spring_constant['new_tentative'].get())
            self.spring_constant['updated_label'].set(str(np.round(self.spring_constant['new_final'].get(), decimals = 3)) + ' nN/nm')

            self.control_parameter['modify_cantilever_calibration']['spring_constant'].set(True)
            self.spring_constant['status'].set('updated')
            self.menu['corrections'].entryconfig(6, state = 'normal')
            self.parent.qi_object.set_spring_constant(self.spring_constant['new_tentative'].get())
            self.update_plot()


        elif self.tag['spring_constant'] == 'entry':

            conv = self.entry_spring_constant['spring_constant'].get()

            try:

                conv = float(conv)

                if conv > 0:

                    self.spring_constant['new_tentative'].set(conv)
                    self.spring_constant['new_start'].set(conv)
                    self.entry_spring_constant['spring_constant_scale'].set(0)
                    self.entry_spring_constant['scale_label'].set(np.round(self.spring_constant['new_tentative'].get(), decimals = 3))

                    self.spring_constant['new_final'].set(self.spring_constant['new_tentative'].get())
                    self.spring_constant['updated_label'].set(str(np.round(self.spring_constant['new_final'].get(), decimals = 3)) + ' nN/nm')

                    self.control_parameter['modify_cantilever_calibration']['spring_constant'].set(True)
                    self.spring_constant['status'].set('updated')
                    self.menu['corrections'].entryconfig(6, state = 'normal')
                    self.parent.qi_object.set_spring_constant(self.spring_constant['new_tentative'].get())
                    self.update_plot()

            except:

                self.enter_window_app.bell()


        else:

            tkinter.messagebox.showwarning(message = 'Specify new spring constant first!')





    def _reset_sensitivity_value(self):

        self.entry_sensitivity['sensitivity_scale'].set(0)
        self.entry_sensitivity['sensitivity'].set('')
        self.entry_sensitivity['scale_label'].set(np.round(self.parent.qi_object.jpk_qi_data.calibrations['sensitivity']*1e9, decimals = 2))

        self.sensitivity['new_start'].set(self.parent.qi_object.jpk_qi_data.calibrations['sensitivity']*1e9)
        self.sensitivity['new_tentative'].set(self.parent.qi_object.jpk_qi_data.calibrations['sensitivity']*1e9)
        self.sensitivity['new_final'].set(0)
        self.sensitivity['updated_label'].set(str(np.round(self.sensitivity['new_final'].get(), decimals = 2)) + ' nm/V')

        self.control_parameter['modify_cantilever_calibration']['sensitivity'].set(False)
        self.sensitivity['status'].set('original')
        self.tag['sensitivity'] = None
        self.menu['corrections'].entryconfig(5, state = 'disabled')
        self.parent.qi_object.reset_sensitivity()
        self.update_plot()


    def _reset_spring_constant_value(self):

        self.entry_spring_constant['spring_constant_scale'].set(0)
        self.entry_spring_constant['spring_constant'].set('')
        self.entry_spring_constant['scale_label'].set(np.round(self.parent.qi_object.jpk_qi_data.calibrations['spring_constant'], decimals = 3))

        self.spring_constant['new_start'].set(self.parent.qi_object.jpk_qi_data.calibrations['spring_constant'])
        self.spring_constant['new_tentative'].set(self.parent.qi_object.jpk_qi_data.calibrations['spring_constant'])
        self.spring_constant['new_final'].set(0)
        self.spring_constant['updated_label'].set(str(np.round(self.spring_constant['new_final'].get(), decimals = 3)) + ' nN/nm')

        self.control_parameter['modify_cantilever_calibration']['spring_constant'].set(False)
        self.spring_constant['status'].set('original')
        self.tag['spring_constant'] = None
        self.menu['corrections'].entryconfig(6, state = 'disabled')
        self.parent.qi_object.reset_spring_constant()
        self.update_plot()


    def reset(self):

        if self.control_parameter['modify_cantilever_calibration']['sensitivity'].get():

            self.entry_sensitivity['sensitivity_scale'].set(0)
            self.entry_sensitivity['sensitivity'].set('')
            self.entry_sensitivity['scale_label'].set(np.round(self.parent.qi_object.jpk_qi_data.calibrations['sensitivity']*1e9, decimals = 2))

            self.sensitivity['new_start'].set(self.parent.qi_object.jpk_qi_data.calibrations['sensitivity']*1e9)
            self.sensitivity['new_tentative'].set(self.parent.qi_object.jpk_qi_data.calibrations['sensitivity']*1e9)
            self.sensitivity['new_final'].set(0)
            self.sensitivity['updated_label'].set(str(np.round(self.sensitivity['new_final'].get(), decimals = 2)) + ' nm/V')

            self.control_parameter['modify_cantilever_calibration']['sensitivity'].set(False)
            self.sensitivity['status'].set('original')
            self.tag['sensitivity'] = None
            self.menu['corrections'].entryconfig(5, state = 'disabled')
            self.parent.qi_object.reset_sensitivity()

        if self.control_parameter['modify_cantilever_calibration']['spring_constant'].get():

            self.entry_spring_constant['spring_constant_scale'].set(0)
            self.entry_spring_constant['spring_constant'].set('')
            self.entry_spring_constant['scale_label'].set(np.round(self.parent.qi_object.jpk_qi_data.calibrations['spring_constant'], decimals = 3))

            self.spring_constant['new_start'].set(self.parent.qi_object.jpk_qi_data.calibrations['spring_constant'])
            self.spring_constant['new_tentative'].set(self.parent.qi_object.jpk_qi_data.calibrations['spring_constant'])
            self.spring_constant['new_final'].set(0)
            self.spring_constant['updated_label'].set(str(np.round(self.spring_constant['new_final'].get(), decimals = 3)) + ' nN/nm')

            self.control_parameter['modify_cantilever_calibration']['spring_constant'].set(False)
            self.spring_constant['status'].set('original')
            self.tag['spring_constant'] = None
            self.menu['corrections'].entryconfig(6, state = 'disabled')
            self.parent.qi_object.reset_spring_constant()


        self.update_plot()
        #self._reset_sensitivity_value()
        #self._reset_spring_constant_value()#update plot is called twice...but that should be okay



class StandardHertzWindow():

    def __init__(self,QI_FD_Preview_object):

        self.parent = QI_FD_Preview_object
        self.safe_closing = True
        self.enter_window_app = None
        self.update_plot = QI_FD_Preview_object.update_plot

        self.settings = dict()
        self.settings['hertz_fit_parameter'] = {'indenter_geometry': tkinter.StringVar(None,'parabolic'), 'indenter_geometry_characteristics': tkinter.StringVar(None, 10), 'indenter_geometry_characteristics_label': tkinter.StringVar(None, 'Radius [nm]:'), 'poisson_ratio':tkinter.StringVar(None, 0.5)}
        self.settings['fit_settings'] = {'mode': tkinter.StringVar(None,'free contact point'), 'y_offset': tkinter.StringVar(None,'zero'), 'max_indentation': tkinter.StringVar(None, 'inf'), 'force_limit': tkinter.StringVar(None, 'inf'), 'residuals_baseline_weight': tkinter.StringVar(None, 0), 'distance_to_contact': tkinter.StringVar(None, 50) , 'min_fit_length': tkinter.StringVar(None, 20)}
        self.settings['visualization'] = {'show_preview': tkinter.BooleanVar(None,False), 'retract_plot': tkinter.BooleanVar(None,False), 'export_result': tkinter.BooleanVar(None,False), 'svg':tkinter.BooleanVar(None,False), 'pdf': tkinter.BooleanVar(None,False), 'png': tkinter.BooleanVar(None,False), 'pkl': tkinter.BooleanVar(None,False)}
        self.settings['export_fileformats'] = list()

        self.indenter_characteristics = {'geometry': 'parabolic', 'radius [nm]': 10}
        #self.indenter_characteristics_string = tkinter.StringVar(None, 'parabolic, 10 nm')
        self.poisson_ratio = 0.5
        self.fit_settings_values = {'mode': 'free_contact_point', 'y_offset':'zero', 'max_indentation': np.inf, 'force_limit': np.inf, 'residuals_baseline_weight': 0, 'distance_to_contact': 50 , 'min_fit_length': 20}

        self.show_in_fd_curve_preview = tkinter.BooleanVar(None,False)
        self.control_parameter = QI_FD_Preview_object.control_parameter

        self.progress_info = tkinter.StringVar(None)
        self.thread_analysis = None

        self.frames = None
        self.header = None
        self.hertz_model_parameter = None
        self.fit_settings = None
        self.visualization = None
        self.analysis_control_panel = None
        self.selection_panel = None
        self.results_panel  = None
        self.results_show = {'full_map': {'qi_map': tkinter.BooleanVar(None,True), 'boxplot': tkinter.BooleanVar(None,False), 'histogram': tkinter.BooleanVar(None,False)}, 'selections': {'data_origin': tkinter.BooleanVar(None,False), 'boxplot': tkinter.BooleanVar(None,True), 'histogram': tkinter.BooleanVar(None,False), 'cumulative': tkinter.BooleanVar(None,False), 'layer': tkinter.IntVar(None, 1), 'layer_string': tkinter.StringVar(None, 'Layer 1')}}

        #self.background = '#282330'
        #self.foreground = '#dfdae0'

        self.color_scheme = _Helper_Functions_GUI._set_color_options()





    def on_closing(self):

        if self.safe_closing:

            self.enter_window_app.destroy()
            self.control_parameter['standard_hertz_window'] = False
            self.settings['visualization']['show_preview'].set(False)
            self.enter_window_app = None

            self.progress_info.set('')
            self.thread_analysis = None

            self.frames = None
            self.header = None
            self.hertz_model_parameter = None
            self.fit_settings = None
            self.visualization = None
            self.analysis_control_panel = None
            self.selection_panel = None
            self.results_panel = None


        else:

            self.enter_window_app.bell()
            tkinter.messagebox.showinfo(parent = self.enter_window_app, title = 'Why so impatient! Let me finish first!', message = 'Cannot close Window. Analysis is still running!')



    #def on_opening(self):

        #self.settings['visualization']['show_preview'].set(True)
        #self._toggle_preview()
        #set all others to false
        #print('To Do: closes all the other analysis windows so that only one is active at times')
        #self.update_plot()




    def _on_open_new_qi_map(self):

        if self.control_parameter['standard_hertz_window']:

            self.results_panel['full_map']['show_results'].configure(state = 'disabled')
            self.results_panel['full_map']['show_parameter'].configure(state = 'disabled')
            self.results_panel['selections']['show_results'].configure(state = 'disabled')
            self.results_panel['selections']['show_parameter'].configure(state = 'disabled')
            self.results_panel['selections']['data_origin'].configure(state = 'disabled')
            self.results_show['selections']['data_origin'].set(False)

            self.analysis_control_panel['button']['run'].configure(state = 'disabled')
            self.selection_panel['run_analysis_selection'].configure(state = 'disabled')

            self.selection_panel['listbox'].delete(0,'end')
            for select in self.parent.qi_object.selections.keys():
                self.selection_panel['listbox'].insert('end', select)



    def _on_loading_qi_snapshot(self):

        if self.control_parameter['standard_hertz_window']:

            if self.parent.qi_object.control_variables['allow_analysis']:
                self.analysis_control_panel['button']['run'].configure(state = 'normal')

                if len(self.parent.qi_object.hertz_fit['full_map']):
                    self.results_panel['full_map']['show_results'].configure(state = 'normal')
                    self.results_panel['selections']['show_results'].configure(state = 'normal')
                    self.results_panel['selections']['data_origin'].configure(state = 'normal')
                    self.results_panel['full_map']['show_parameter'].configure(state = 'normal')
                    self.results_panel['selections']['show_parameter'].configure(state = 'normal')
                else:
                    self.results_panel['full_map']['show_results'].configure(state = 'disabled')
                    self.results_panel['full_map']['show_parameter'].configure(state = 'disabled')

                    if len(self.parent.qi_object.hertz_fit['selections']):
                        self.results_panel['selections']['show_results'].configure(state = 'normal')
                        self.results_panel['selections']['show_parameter'].configure(state = 'normal')
                    else:
                        self.results_panel['selections']['show_results'].configure(state = 'disabled')
                        self.results_panel['selections']['show_parameter'].configure(state = 'disabled')


            else:
                self.analysis_control_panel['button']['run'].configure(state = 'disabled')


            for select in self.parent.qi_object.selections.keys():
                self.selection_panel['listbox'].insert('end', select)









    def setup_standard_hertz(self):

        #self.on_opening()

        if isinstance(self.enter_window_app, tkinter.Toplevel):

            self.enter_window_app.lift()
            self.enter_window_app.focus_set()

        else:

            self.enter_window_app = tkinter.Toplevel() #use tkinter.Tk() only once in an application
            self.enter_window_app.title('Standard Hertz Fit')
            self.enter_window_app.resizable(False, False)
            self.enter_window_app.focus_set()

            self.control_parameter['standard_hertz_window'] = True
            self.settings['visualization']['show_preview'].set(True)

            self._create_frames()
            self._create_frame_content()
            self._toggle_preview()

            self.hertz_model_parameter['entry']['indenter_geometry'].bind('<Return>', self._enter_indenter_characteristics)
            self.hertz_model_parameter['entry']['poisson_ratio'].bind('<Return>', self._enter_poisson_ratio)

            self.fit_settings['max_indentation_entry'].bind('<Return>', self._enter_max_indentation)
            self.fit_settings['force_limit_entry'].bind('<Return>', self._enter_force_limit)
            self.fit_settings['residuals_baseline_weight_entry'].bind('<Return>', self._enter_residual_baseline_weight)
            self.fit_settings['distance_to_contact_entry'].bind('<Return>', self._enter_distance_to_contact)
            self.fit_settings['min_fit_length_entry'].bind('<Return>', self._enter_min_fit_length)

            self.enter_window_app.protocol("WM_DELETE_WINDOW", self.on_closing)




    def run_fit_hertz_model(self):

        if self.settings['export_fileformats']:
            export_result = self.settings['export_fileformats']
        else:
            export_result = False

        self.parent.safe_closing = False
        self.safe_closing = False

        self.selection_panel['run_analysis_selection'].configure(state = 'disabled')
        self.analysis_control_panel['button']['run'].configure(state = 'disabled')
        self.analysis_control_panel['progress']['bar']['maximum'] = self.parent.qi_object.settings['fd_indices']['total'] - 1
        self.thread_analysis = threading.Thread(target = self.parent.qi_object.fit_hertz_model, kwargs = {'poisson_ratio': self.poisson_ratio, 'indenter_characteristics': self.indenter_characteristics, 'mode': self.fit_settings_values['mode'], 'y_offset':self.fit_settings_values['y_offset'], 'max_indentation': self.fit_settings_values['max_indentation'], 'force_limit': self.fit_settings_values['force_limit'], 'residuals_baseline_weight': self.fit_settings_values['residuals_baseline_weight'], 'distance_to_contact': self.fit_settings_values['distance_to_contact'] , 'min_fit_length': self.fit_settings_values['min_fit_length'], 'export_result': export_result, 'retract_plot': self.settings['visualization']['retract_plot'].get()})
        print('====================')
        self.thread_analysis.start()
        self.parent.after(50, self._update_progress)


        #self.fit_settings_values = {'mode': 'free_contact_point', 'y_offset':'zero', 'max_indentation': np.inf, 'force_limit': np.inf, 'residuals_baseline_weight': 0, 'distance_to_contact': 50 , 'min_fit_length': 20}




    def run_fit_hertz_model_selection(self):

        selections = [list(self.parent.qi_object.selections.keys())[i] for i in self.selection_panel['listbox'].curselection()]

        if self.settings['export_fileformats']:
            export_result = self.settings['export_fileformats']
        else:
            export_result = False


        if bool(selections):

            self.parent.safe_closing = False
            self.safe_closing = False

            self.selection_panel['run_analysis_selection'].configure(state = 'disabled')
            self.analysis_control_panel['button']['run'].configure(state = 'disabled')
            self.thread_analysis = threading.Thread(target = self.parent.qi_object.fit_hertz_model, kwargs = {'selection':selections, 'poisson_ratio': self.poisson_ratio, 'indenter_characteristics': self.indenter_characteristics, 'mode': self.fit_settings_values['mode'], 'y_offset':self.fit_settings_values['y_offset'], 'max_indentation': self.fit_settings_values['max_indentation'], 'force_limit': self.fit_settings_values['force_limit'], 'residuals_baseline_weight': self.fit_settings_values['residuals_baseline_weight'], 'distance_to_contact': self.fit_settings_values['distance_to_contact'] , 'min_fit_length': self.fit_settings_values['min_fit_length'], 'export_result': export_result, 'retract_plot': self.settings['visualization']['retract_plot'].get()})
            print('====================')
            self.selection_panel['progress']['maximum'] = self.parent.qi_object.counter['max']
            self.thread_analysis.start()
            self.parent.after(50, self._update_progress_selection)







    def _create_frames(self):

        self.frames = dict()
        self.frames['master_frame'] = dict()
        self.frames['master_frame']['frame'] = tkinter.Frame(self.enter_window_app, background = self.color_scheme['background'])
        self.frames['master_frame']['separator'] = tkinter.Frame(self.enter_window_app, width = 1, bg = self.color_scheme['separator'])
        self.frames['master_frame']['info'] = tkinter.Frame(self.enter_window_app, bg = self.color_scheme['background'])
        #frames['master_frame']['frame'].configure(width = 200, height = 300, background = '#170b28')
        #self.frames['master_frame']['frame'].configure(background = self.color_scheme['background'])#, relief = 'sunken', borderwidth = 1)
        self.frames['master_frame']['frame'].grid(row = 0, column = 0, sticky = 'nswe')
        self.frames['master_frame']['separator'].grid(row = 0, column = 1, sticky = 'ns')
        self.frames['master_frame']['info'].grid(row = 0, column = 2, sticky = 'nswe')
        #frames['master_frame']['frame'].grid_propagate(False)
        self.frames['correction_info_frame'] = dict()
        self.frames['correction_info_frame']['frame'] = CorrectionInfoFrame(self.frames['master_frame']['info'], correction_window_ref = self.parent.corrections_window.confirmed_corrections, background = self.color_scheme['background'], textcolor = self.color_scheme['text_standard'], highlighttextcolor = self.color_scheme['text_highlighted'])#, relief = 'sunken', borderwidth = 1)
        self.frames['correction_info_frame']['frame'].grid(row = 0, column = 0, sticky = 'nswe')

        self.frames['master_frame']['children'] = dict()
        self.frames['master_frame']['children']['hertz_model_parameter'] = tkinter.Frame(self.frames['master_frame']['frame'], bg = self.color_scheme['background'])
        self.frames['master_frame']['children']['fit_settings'] = tkinter.Frame(self.frames['master_frame']['frame'], bg = self.color_scheme['background'])
        self.frames['master_frame']['children']['export_plot'] = tkinter.Frame(self.frames['master_frame']['frame'], bg = self.color_scheme['background'])
        self.frames['master_frame']['children']['analysis_control_panel'] = tkinter.Frame(self.frames['master_frame']['frame'], bg = self.color_scheme['background'])
        self.frames['master_frame']['children']['analysis_selections'] = tkinter.Frame(self.frames['master_frame']['frame'], bg = self.color_scheme['background'])
        #self.frames['master_frame']['children']['results_qi_map'] = tkinter.Frame(self.frames['master_frame']['frame'], bg = self.color_scheme['background'])
        #self.frames['master_frame']['children']['seperator'] = tkinter.Frame(self.frames['master_frame']['frame'], background = self.color_scheme['separator'])
        #self.frames['master_frame']['children']['results_selections'] = tkinter.Frame(self.frames['master_frame']['frame'], bg = self.color_scheme['background'])
        self.frames['master_frame']['children']['results_qi_map'] = tkinter.LabelFrame(self.frames['master_frame']['frame'], text = 'Complete QI Map', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], relief = 'ridge', padx = 10, pady = 5)
        self.frames['master_frame']['children']['results_selections'] = tkinter.LabelFrame(self.frames['master_frame']['frame'], text = 'Individual Selections', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], relief = 'ridge', padx = 10, pady = 5)

        self.header = dict()
        self.header['hertz_model_parameter'] = tkinter.Label(self.frames['master_frame']['frame'], text = "Parameter: Hertz Model", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.header['fit_settings'] = tkinter.Label(self.frames['master_frame']['frame'], text = "Settings: Fit Algorithm", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.header['export_plot'] = tkinter.Label(self.frames['master_frame']['frame'], text = "Force-Distance Curves: Export/Visualization", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.header['analysis_selections'] = tkinter.Label(self.frames['master_frame']['frame'], text = "Analysis: Individual Selections", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.header['analysis_control_panel'] = tkinter.Label(self.frames['master_frame']['frame'], text = "Analysis: Complete QI Map", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.header['show_results'] = tkinter.Label(self.frames['master_frame']['frame'], text = "Visualize Results", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        #self.header['results_qi_map'] = tkinter.Label(self.frames['master_frame']['frame'], text = "Complete Map", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        #self.header['results_selections'] = tkinter.Label(self.frames['master_frame']['frame'], text = "Individual Selections", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])

        self.header['hertz_model_parameter'].grid(row = 0, column = 0, columnspan = 2, sticky = 'ew')
        self.frames['master_frame']['children']['hertz_model_parameter'].grid(row = 1, column = 0, columnspan = 2, sticky = 'ew', padx = 10, pady = 10)
        self.header['fit_settings'].grid(row = 2, column = 0, columnspan = 2, sticky = "ew")
        self.frames['master_frame']['children']['fit_settings'].grid(row = 3, column = 0, columnspan = 2, sticky = 'ew', padx = 10, pady = 10)
        self.header['export_plot'].grid(row = 4, column = 0, columnspan = 2, sticky = "ew")
        self.frames['master_frame']['children']['export_plot'].grid(row = 5, column = 0, columnspan = 2, sticky = 'ew', padx = 10, pady = 10)
        self.header['analysis_control_panel'].grid(row = 6, column = 0, columnspan = 2, sticky = "ew")
        self.frames['master_frame']['children']['analysis_control_panel'].grid(row = 7, column = 0, columnspan = 2, sticky = 'ew', padx = 10, pady = 10)
        self.header['analysis_selections'].grid(row = 8, column = 0, columnspan = 2, sticky = "ew")
        self.frames['master_frame']['children']['analysis_selections'].grid(row = 9, column = 0, columnspan = 2, sticky = 'ew', padx = 10, pady = 10)
        self.header['show_results'].grid(row = 10, column = 0, columnspan = 2, sticky = "ew")
        #self.header['results_qi_map'].grid(row = 11, column = 0, sticky = "ew")
        #self.header['results_selections'].grid(row = 11, column = 2, sticky = "ew")
        self.frames['master_frame']['children']['results_qi_map'].grid(row = 12, column = 0, sticky = 'nsew', padx = (5,1), pady = 10)
        #self.frames['master_frame']['children']['seperator'].grid(row = 11, column = 1, rowspan = 2, sticky = 'ns', pady = (0,5))
        self.frames['master_frame']['children']['results_selections'].grid(row = 12, column = 1, sticky = 'nsew', padx = (1,5), pady = 10)


        self.frames['master_frame']['children']['analysis_control_panel'].columnconfigure(1,weight = 1)
        self.frames['master_frame']['children']['analysis_selections'].columnconfigure(3,weight = 1)



    def _create_frame_content(self):

        self.hertz_model_parameter = dict()
        self.hertz_model_parameter['label'] = dict()
        self.hertz_model_parameter['label']['indenter_geometry'] = tkinter.Label(self.frames['master_frame']['children']['hertz_model_parameter'], text = "Indenter geometry:", width = 26, anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.hertz_model_parameter['label']['indenter_geometry_characteristics'] = tkinter.Label(self.frames['master_frame']['children']['hertz_model_parameter'], textvariable = self.settings['hertz_fit_parameter']['indenter_geometry_characteristics_label'], bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.hertz_model_parameter['label']['poisson_ratio'] = tkinter.Label(self.frames['master_frame']['children']['hertz_model_parameter'], text = "Poisson ratio:", bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])


        self.hertz_model_parameter['combobox'] = dict()
        self.hertz_model_parameter['combobox']['indenter_geometry'] = MyOwnComboBox(self.frames['master_frame']['children']['hertz_model_parameter'], textvariable = self.settings['hertz_fit_parameter']['indenter_geometry'], values = ['parabolic', 'four-sided pyramid', 'conical'], width = 20, command = self._update_combobox_indenter_geometry, background = self.color_scheme['background_input_dark'], foreground = self.color_scheme['text_standard'], arrow_color = self.color_scheme['text_standard'], bordercolor = self.color_scheme['border'], activebordercolor = self.color_scheme['border_active'], arrow_background = self.color_scheme['background_input_dark'], arrow_activebordercolor = self.color_scheme['border_active'], arrow_activebackground = self.color_scheme['background_light'], selectbackground = self.color_scheme['text_selectbackground'])#background = self.background, foreground = self.foreground)


        self.hertz_model_parameter['entry'] = dict()
        self.hertz_model_parameter['entry']['indenter_geometry'] = tkinter.Entry(self.frames['master_frame']['children']['hertz_model_parameter'], textvariable = self.settings['hertz_fit_parameter']['indenter_geometry_characteristics'], width = 4, justify = 'right', bd = 0, bg = self.color_scheme['background_input_dark'], fg = self.color_scheme['text_standard'], insertbackground = self.color_scheme['text_standard'], highlightthickness = 1, highlightcolor =  self.color_scheme['border_active'], highlightbackground = self.color_scheme['border'], selectbackground = self.color_scheme['text_selectbackground'])
        self.hertz_model_parameter['entry']['poisson_ratio'] = tkinter.Entry(self.frames['master_frame']['children']['hertz_model_parameter'], textvariable = self.settings['hertz_fit_parameter']['poisson_ratio'], width = 4, justify = 'right', bd = 0, bg = self.color_scheme['background_input_dark'], fg = self.color_scheme['text_standard'], insertbackground = self.color_scheme['text_standard'], highlightthickness = 1, highlightcolor = self.color_scheme['border_active'], highlightbackground = self.color_scheme['border'], selectbackground = self.color_scheme['text_selectbackground'])

        self.hertz_model_parameter['spacer'] = dict()
        self.hertz_model_parameter['spacer'][1] = tkinter.Frame(self.frames['master_frame']['children']['hertz_model_parameter'])
        self.hertz_model_parameter['spacer'][1].configure(height = 10, bg = self.color_scheme['background'])

        self.hertz_model_parameter['label']['indenter_geometry'].grid(row = 0, column = 0, sticky = 'w', padx = (0,0))
        self.hertz_model_parameter['label']['indenter_geometry_characteristics'].grid(row = 1, column = 0, sticky = 'w')
        self.hertz_model_parameter['spacer'][1].grid(row = 2, column = 0, columnspan = 2, sticky = 'ew')
        self.hertz_model_parameter['label']['poisson_ratio'].grid(row = 3, column = 0, sticky = 'w')
        self.hertz_model_parameter['combobox']['indenter_geometry'].grid(row = 0, column = 1)
        self.hertz_model_parameter['entry']['indenter_geometry'].grid(row = 1, column = 1)
        self.hertz_model_parameter['entry']['poisson_ratio'].grid(row = 3, column = 1)


        self.fit_settings = dict()
        self.fit_settings['mode_label'] = tkinter.Label(self.frames['master_frame']['children']['fit_settings'], text = "Fit mode:", bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['mode_combobox'] = MyOwnComboBox(self.frames['master_frame']['children']['fit_settings'], textvariable = self.settings['fit_settings']['mode'], values = ['free contact point', 'fixed contact point'], width = 20, command = self._update_combobox_fit_mode, background = self.color_scheme['background_input_dark'], foreground = self.color_scheme['text_standard'], arrow_color = self.color_scheme['text_standard'], bordercolor = self.color_scheme['border'], activebordercolor = self.color_scheme['border_active'], arrow_background = self.color_scheme['background_input_dark'], arrow_activebordercolor = self.color_scheme['border_active'], arrow_activebackground = self.color_scheme['background_light'], selectbackground = self.color_scheme['text_selectbackground'])#background = self.background, foreground = self.foreground)


        self.fit_settings['max_indentation_label'] = tkinter.Label(self.frames['master_frame']['children']['fit_settings'], text = "Fit limit: Indentation [nm]", width = 26, anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['max_indentation_entry'] = tkinter.Entry(self.frames['master_frame']['children']['fit_settings'], textvariable = self.settings['fit_settings']['max_indentation'], width = 7, justify = 'right', bd = 0, bg = self.color_scheme['background_input_dark'], fg = self.color_scheme['text_standard'], insertbackground = self.color_scheme['text_standard'], highlightthickness = 1, highlightcolor = self.color_scheme['border_active'], highlightbackground = self.color_scheme['border'], selectbackground = self.color_scheme['text_selectbackground'])
        self.fit_settings['force_limit_label'] = tkinter.Label(self.frames['master_frame']['children']['fit_settings'], text = "Fit limit: Force [nN]", bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['force_limit_entry'] = tkinter.Entry(self.frames['master_frame']['children']['fit_settings'], textvariable = self.settings['fit_settings']['force_limit'], width = 7, justify = 'right', bd = 0, bg = self.color_scheme['background_input_dark'], fg = self.color_scheme['text_standard'], insertbackground = self.color_scheme['text_standard'], highlightthickness = 1, highlightcolor = self.color_scheme['border_active'], highlightbackground = self.color_scheme['border'], selectbackground = self.color_scheme['text_selectbackground'])

        self.fit_settings['free_contact_point_frame'] = tkinter.LabelFrame(self.frames['master_frame']['children']['fit_settings'], text = 'Specific settings: free contact point', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], relief = 'ridge', padx = 5, pady = 5)
        self.fit_settings['contact_point_y_offset_label'] = tkinter.Label(self.fit_settings['free_contact_point_frame'], text = "Contact point y-offset:", bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['contact_point_y_offset_combobox'] = MyOwnComboBox(self.fit_settings['free_contact_point_frame'], textvariable = self.settings['fit_settings']['y_offset'], values = ['zero', 'mean', 'none'], width = 20, command = self._update_combobox_y_offset, background = self.color_scheme['background_input_dark'], foreground = self.color_scheme['text_standard'], arrow_color = self.color_scheme['text_standard'], bordercolor = self.color_scheme['border'], activebordercolor = self.color_scheme['border_active'], arrow_background = self.color_scheme['background_input_dark'], arrow_activebordercolor = self.color_scheme['border_active'], arrow_activebackground = self.color_scheme['background_light'], selectbackground = self.color_scheme['text_selectbackground'], disabledbackground = self.color_scheme['background_input_disabled'], disabledforeground = self.color_scheme['text_disabled'])#background = self.background, foreground = self.foreground)

        self.fit_settings['residuals_baseline_weight_label'] = tkinter.Label(self.fit_settings['free_contact_point_frame'], text = "Baseline weight:", width = 26, anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['residuals_baseline_weight_entry'] = tkinter.Entry(self.fit_settings['free_contact_point_frame'], textvariable = self.settings['fit_settings']['residuals_baseline_weight'], width = 4, justify = 'right', bd = 0, bg = self.color_scheme['background_input_dark'], fg = self.color_scheme['text_standard'], insertbackground = self.color_scheme['text_standard'], highlightthickness = 1, highlightcolor = self.color_scheme['border_active'], highlightbackground = self.color_scheme['border'], selectbackground = self.color_scheme['text_selectbackground'], disabledbackground = self.color_scheme['background_input_disabled'])
        self.fit_settings['distance_to_contact_label'] = tkinter.Label(self.fit_settings['free_contact_point_frame'], text = "Distance to contact point:", width = 26, anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['distance_to_contact_entry'] = tkinter.Entry(self.fit_settings['free_contact_point_frame'], textvariable = self.settings['fit_settings']['distance_to_contact'], width = 4, justify = 'right', bd = 0, bg = self.color_scheme['background_input_dark'], fg = self.color_scheme['text_standard'], insertbackground = self.color_scheme['text_standard'], highlightthickness = 1, highlightcolor = self.color_scheme['border_active'], highlightbackground = self.color_scheme['border'], selectbackground = self.color_scheme['text_selectbackground'], disabledbackground = self.color_scheme['background_input_disabled'])
        self.fit_settings['min_fit_length_label'] = tkinter.Label(self.fit_settings['free_contact_point_frame'], text = "Minimal fit length:", width = 26, anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['min_fit_length_entry'] = tkinter.Entry(self.fit_settings['free_contact_point_frame'], textvariable = self.settings['fit_settings']['min_fit_length'], width = 4, justify = 'right', bd = 0, bg = self.color_scheme['background_input_dark'], fg = self.color_scheme['text_standard'], insertbackground = self.color_scheme['text_standard'], highlightthickness = 1, highlightcolor = self.color_scheme['border_active'], highlightbackground = self.color_scheme['border'], selectbackground = self.color_scheme['text_selectbackground'], disabledbackground = self.color_scheme['background_input_disabled'])

        self.fit_settings['reset_settings'] = tkinter.Button(self.frames['master_frame']['children']['fit_settings'], text = 'Reset default', command = self._reset_settings, bg = self.color_scheme['button'], fg = self.color_scheme['text_highlighted'], activebackground = self.color_scheme['button'], activeforeground = self.color_scheme['text_highlighted'], disabledforeground = self.color_scheme['text_disabled'])


        self.fit_settings['spacer'] = dict()
        self.fit_settings['spacer'][1] = tkinter.Frame(self.frames['master_frame']['children']['fit_settings'])
        self.fit_settings['spacer'][1].configure(height = 10, bg = self.color_scheme['background'])

        self.fit_settings['mode_label'].grid(row = 0, column = 0, sticky = 'w')
        self.fit_settings['mode_combobox'].grid(row = 0, column = 1)
        self.fit_settings['reset_settings'].grid(row = 3, column = 2, padx = (0,0))

        self.fit_settings['spacer'][1].grid(row = 1, column = 0, columnspan = 3, sticky = 'ew')
        self.fit_settings['max_indentation_label'].grid(row = 2, column = 0, sticky = 'w', padx = (0,0))
        self.fit_settings['max_indentation_entry'].grid(row = 2, column = 1)
        self.fit_settings['force_limit_label'].grid(row = 3, column = 0, sticky = 'w')
        self.fit_settings['force_limit_entry'].grid(row = 3, column = 1)
        #self.frames['master_frame']['children']['fit_settings'].columnconfigure(0,weight=1)
        self.fit_settings['free_contact_point_frame'].grid(row = 5, column = 0, columnspan = 3, pady = (20,0))

        self.fit_settings['contact_point_y_offset_label'].grid(row = 0, column = 0, sticky = 'w', padx = (40,0))
        self.fit_settings['contact_point_y_offset_combobox'].grid(row = 0, column = 1, padx = (0,40))
        self.fit_settings['residuals_baseline_weight_label'].grid(row = 1, column = 0, sticky = 'w', padx = (40,0))
        self.fit_settings['residuals_baseline_weight_entry'].grid(row = 1, column = 1, padx = (0,40))
        self.fit_settings['distance_to_contact_label'].grid(row = 2, column = 0, sticky = 'w', padx = (40,0))
        self.fit_settings['distance_to_contact_entry'].grid(row = 2, column = 1, padx = (0,40))
        self.fit_settings['min_fit_length_label'].grid(row = 3, column = 0, sticky = 'w', padx = (40,0))
        self.fit_settings['min_fit_length_entry'].grid(row = 3, column = 1, padx = (0,40))




        self.visualization = dict()
        self.visualization['show_preview'] = tkinter.Checkbutton(self.frames['master_frame']['children']['export_plot'], text = 'Show in main window', variable = self.settings['visualization']['show_preview'], onvalue = True, offvalue = False, command = self._toggle_preview, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.visualization['retract_plot'] = tkinter.Checkbutton(self.frames['master_frame']['children']['export_plot'], text = 'Show \"retract\" curve', variable = self.parent.entry_var['fd_curve']['retract_plot'], onvalue = True, offvalue = False, command = self.update_plot, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.visualization['export_plot'] = tkinter.Checkbutton(self.frames['master_frame']['children']['export_plot'], text = 'Export individual figures', variable = self.settings['visualization']['export_result'], onvalue = True, offvalue = False, command = self._toggle_export_result, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.visualization['svg'] = tkinter.Checkbutton(self.frames['master_frame']['children']['export_plot'], text = 'svg', variable = self.settings['visualization']['svg'], onvalue = True, offvalue = False, command = self._update_export_fileformats,bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.visualization['pdf'] = tkinter.Checkbutton(self.frames['master_frame']['children']['export_plot'], text = 'pdf', variable = self.settings['visualization']['pdf'], onvalue = True, offvalue = False, command = self._update_export_fileformats,bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.visualization['png'] = tkinter.Checkbutton(self.frames['master_frame']['children']['export_plot'], text = 'png', variable = self.settings['visualization']['png'], onvalue = True, offvalue = False, command = self._update_export_fileformats,bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.visualization['pkl'] = tkinter.Checkbutton(self.frames['master_frame']['children']['export_plot'], text = 'pkl', variable = self.settings['visualization']['pkl'], onvalue = True, offvalue = False, command = self._update_export_fileformats,bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])

        self.visualization['show_preview'].grid(row = 0, column = 0, sticky = 'w', padx = (0,20))
        self.visualization['retract_plot'].grid(row = 1, column = 0, sticky = 'w', padx = (0,20))
        self.visualization['export_plot'].grid(row = 0, column = 1, columnspan = 4, sticky = 'w')
        self.visualization['svg'].grid(row = 1, column = 1, sticky = 'w', padx = (10,0))
        self.visualization['pdf'].grid(row = 1, column = 2, sticky = 'w')
        self.visualization['png'].grid(row = 1, column = 3, sticky = 'w')
        self.visualization['pkl'].grid(row = 1, column = 4, sticky = 'w')

        self.analysis_control_panel = dict()
        self.analysis_control_panel['button'] = dict()
        self.analysis_control_panel['button']['run'] = tkinter.Button(self.frames['master_frame']['children']['analysis_control_panel'], text = 'Run analysis', command = self.run_fit_hertz_model, state = 'disabled', bg = self.color_scheme['button'], fg = self.color_scheme['text_highlighted'], activebackground = self.color_scheme['button'], activeforeground = self.color_scheme['text_highlighted'], disabledforeground = self.color_scheme['text_disabled'])
        #self.analysis_control_panel['button']['show_results'] = tkinter.Button(self.frames['master_frame']['children']['analysis_control_panel'], text = 'Show results', command = self.show_analysis_results, state = 'disabled', bg = self.color_scheme['button'], fg = self.color_scheme['text_highlighted'], activebackground = self.color_scheme['button'], activeforeground = self.color_scheme['text_highlighted'], disabledforeground = self.color_scheme['text_disabled'])
        self.analysis_control_panel['progress'] = dict()
        self.analysis_control_panel['progress']['bar'] = tkinter.ttk.Progressbar(self.frames['master_frame']['children']['analysis_control_panel'], value = 0, mode = 'determinate')


        self.analysis_control_panel['button']['run'].grid(row = 0, column = 0, padx = (0,10))
        self.analysis_control_panel['progress']['bar'].grid(row = 0, column = 1, sticky = 'ew')
        #self.analysis_control_panel['button']['show_results'].grid(row = 2, column = 0, padx = 10, pady = (5,0))



        self.selection_panel = dict()
        self.selection_panel['listbox'] = tkinter.Listbox(self.frames['master_frame']['children']['analysis_selections'], height = 6, width = 15, selectmode = 'multiple', bg = self.color_scheme['background_input_dark'], fg = self.color_scheme['text_standard'], selectbackground = self.color_scheme['text_selectbackground'], activestyle = 'none', bd = 0, highlightthickness = 1, highlightcolor =  self.color_scheme['border_active'], highlightbackground = self.color_scheme['border'], relief = 'flat')
        for v in self.parent.qi_object.selections.keys():
            self.selection_panel['listbox'].insert('end', v)
        self.selection_panel['listbox_scrollbar'] = tkinter.Scrollbar(self.frames['master_frame']['children']['analysis_selections'])
        self.selection_panel['listbox'].config(yscrollcommand=self.selection_panel['listbox_scrollbar'].set)
        self.selection_panel['listbox_scrollbar'].config(command=self.selection_panel['listbox'].yview)
        self.selection_panel['run_analysis_selection'] = tkinter.Button(self.frames['master_frame']['children']['analysis_selections'], text = 'Run analysis', command = self.run_fit_hertz_model_selection, state = 'disabled', bg = self.color_scheme['button'], fg = self.color_scheme['text_highlighted'], activebackground = self.color_scheme['button'], activeforeground = self.color_scheme['text_highlighted'], disabledforeground = self.color_scheme['text_disabled'])
        self.selection_panel['progress_information'] = tkinter.Label(self.frames['master_frame']['children']['analysis_selections'], width = 25, anchor = 'w', textvariable = self.progress_info, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.selection_panel['progress'] = tkinter.ttk.Progressbar(self.frames['master_frame']['children']['analysis_selections'], value = 0, mode = 'determinate')


        self.selection_panel['listbox'].grid(row = 0, column = 0, rowspan = 4, sticky = 'w')
        self.selection_panel['listbox_scrollbar'].grid(row = 0, column = 1, rowspan = 4, sticky = 'nsw')
        self.selection_panel['run_analysis_selection'].grid(row = 0, column = 2, sticky = 'w', padx = (10,10))

        self.selection_panel['progress'].grid(row = 0, column = 3, sticky = 'we')
        self.selection_panel['progress_information'].grid(row = 1, column = 2, columnspan = 2, sticky = 'nw', padx = (10,0), pady = (5,5))

        if self.control_parameter['apply_corrections'].get():
            self.analysis_control_panel['button']['run'].configure(state = 'normal')
            self.selection_panel['run_analysis_selection'].configure(state = 'normal')


        self.results_panel = dict()
        self.results_panel['full_map'] = dict()
        #self.results_panel['full_map']['header'] = tkinter.Label(self.frames['master_frame']['children']['results_qi_map'], text = 'Results: QI map', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.results_panel['full_map']['qi_map'] = tkinter.Checkbutton(self.frames['master_frame']['children']['results_qi_map'], text = 'QI Map', variable = self.results_show['full_map']['qi_map'], onvalue = True, offvalue = False, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.results_panel['full_map']['boxplot'] = tkinter.Checkbutton(self.frames['master_frame']['children']['results_qi_map'], text = 'Boxplot', variable = self.results_show['full_map']['boxplot'], onvalue = True, offvalue = False, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.results_panel['full_map']['histogram'] = tkinter.Checkbutton(self.frames['master_frame']['children']['results_qi_map'], text = 'Histogram', variable = self.results_show['full_map']['histogram'], onvalue = True, offvalue = False, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.results_panel['full_map']['spacer'] = tkinter.Label(self.frames['master_frame']['children']['results_qi_map'], text = '', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.results_panel['full_map']['show_results'] = tkinter.Button(self.frames['master_frame']['children']['results_qi_map'], text = 'Show results', command = self.show_analysis_results_full_map, state = 'disabled', bg = self.color_scheme['button'], fg = self.color_scheme['text_highlighted'], activebackground = self.color_scheme['button'], activeforeground = self.color_scheme['text_highlighted'], disabledforeground = self.color_scheme['text_disabled'])
        self.results_panel['full_map']['show_parameter'] = tkinter.Button(self.frames['master_frame']['children']['results_qi_map'], text = 'Show parameter', command = self.show_analysis_parameter_full_map, state = 'disabled', bg = self.color_scheme['button'], fg = self.color_scheme['text_highlighted'], activebackground = self.color_scheme['button'], activeforeground = self.color_scheme['text_highlighted'], disabledforeground = self.color_scheme['text_disabled'])

        self.results_panel['selections'] = dict()
        self.results_panel['selections']['show_results'] = tkinter.Button(self.frames['master_frame']['children']['results_selections'], text = 'Show results', command = self.show_analysis_results_selections, state = 'disabled', bg = self.color_scheme['button'], fg = self.color_scheme['text_highlighted'], activebackground = self.color_scheme['button'], activeforeground = self.color_scheme['text_highlighted'], disabledforeground = self.color_scheme['text_disabled'])
        self.results_panel['selections']['data_origin'] = tkinter.Checkbutton(self.frames['master_frame']['children']['results_selections'], text = 'Use full map data ', variable = self.results_show['selections']['data_origin'], onvalue = True, offvalue = False, state = 'disabled', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.results_panel['selections']['boxplot'] = tkinter.Checkbutton(self.frames['master_frame']['children']['results_selections'], text = 'Boxplot', variable = self.results_show['selections']['boxplot'], onvalue = True, offvalue = False, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.results_panel['selections']['histogram'] = tkinter.Checkbutton(self.frames['master_frame']['children']['results_selections'], text = 'Histogram', variable = self.results_show['selections']['histogram'], onvalue = True, offvalue = False, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.results_panel['selections']['spacer'] = tkinter.Label(self.frames['master_frame']['children']['results_selections'], text = '', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.results_panel['selections']['show_parameter'] = tkinter.Button(self.frames['master_frame']['children']['results_selections'], text = 'Show parameter', command = self.show_analysis_parameter_selections, state = 'disabled', bg = self.color_scheme['button'], fg = self.color_scheme['text_highlighted'], activebackground = self.color_scheme['button'], activeforeground = self.color_scheme['text_highlighted'], disabledforeground = self.color_scheme['text_disabled'])

        self.results_panel['full_map']['qi_map'].grid(row = 0, column = 0, sticky = 'w')
        self.results_panel['full_map']['boxplot'].grid(row = 1, column = 0, sticky = 'w')
        self.results_panel['full_map']['histogram'].grid(row = 2, column = 0, sticky = 'w')
        self.results_panel['full_map']['spacer'].grid(row = 3, column = 0, sticky = 'w', pady = (10,0))
        self.results_panel['full_map']['show_results'].grid(row = 4, column = 0, sticky = 'w', pady = (5,0))
        self.results_panel['full_map']['show_parameter'].grid(row = 4, column = 1, sticky = 'w', pady = (5,0))


        self.results_panel['selections']['boxplot'].grid(row = 0, column = 0, sticky = 'w')
        self.results_panel['selections']['histogram'].grid(row = 1, column = 0, sticky = 'w')
        self.results_panel['selections']['spacer'].grid(row = 2, column = 0, sticky = 'w', pady = (0,0))
        self.results_panel['selections']['data_origin'].grid(row = 3, column = 0, columnspan = 2, sticky = 'w', pady = (0,10))

        self.results_panel['selections']['show_results'].grid(row = 4, column = 0, sticky = 'w', pady = (5,0))
        self.results_panel['selections']['show_parameter'].grid(row = 4, column = 1, sticky = 'w', pady = (5,0))


        if len(self.parent.qi_object.hertz_fit['full_map']):
            self.results_panel['full_map']['show_results'].configure(state = 'normal')
            self.results_panel['selections']['show_results'].configure(state = 'normal')
            self.results_panel['selections']['data_origin'].configure(state = 'normal')
            self.results_panel['full_map']['show_parameter'].configure(state = 'normal')
            self.results_panel['selections']['show_parameter'].configure(state = 'normal')
        else:
            #self.results_panel['full_map']['show_results'].configure(state = 'disabled')
            if len(self.parent.qi_object.hertz_fit['selections']):
                self.results_panel['selections']['show_results'].configure(state = 'normal')
                self.results_panel['selections']['show_parameter'].configure(state = 'normal')
            #else:
                #self.results_panel['selections']['show_results'].configure(state = 'disabled')


        #self.frames['master_frame']['info'].columnconfigure(0, weight = 1)
        self.fit_settings['info'] = dict()
        self.fit_settings['info']['master_frame'] = tkinter.Frame(self.frames['master_frame']['info'], background = self.color_scheme['background'])
        self.fit_settings['info']['header'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = "==== Analysis Parameter ====", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['info']['indenter_geometry_label'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = 'Indenter geometry: ', width = 18, anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['info']['indenter_geometry_details'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = 'parabolic', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])
        self.fit_settings['info']['indenter_characteristics_label'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = 'Radius [nm]: ', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['info']['indenter_characteristics_details'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = '10', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])
        self.fit_settings['info']['poisson_ratio_label'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = 'Poisson ratio: ', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['info']['poisson_ratio_details'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = '0.5', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])
        self.fit_settings['info']['fit_mode_label'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = 'Fit mode: ', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['info']['fit_mode_details'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = 'free CP', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])
        self.fit_settings['info']['max_indentation_label'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = 'Max indentation: ', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['info']['max_indentation_details'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = 'inf', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])
        self.fit_settings['info']['force_limit_label'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = 'Force limit: ', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['info']['force_limit_details'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = 'inf', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])

        self.fit_settings['info']['cp_offset_label'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = 'CP y-offset: ', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['info']['cp_offset_details'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = 'zero', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])
        self.fit_settings['info']['baseline_weight_label'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = 'Baseline weight: ', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['info']['baseline_weight_details'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = '0', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])
        self.fit_settings['info']['distance_to_contact_label'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = 'Distance to CP: ', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['info']['distance_to_contact_details'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = '50', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])
        self.fit_settings['info']['min_fit_length_label'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = 'Min fit length: ', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['info']['min_fit_length_details'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = '20', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])

        #self.fit_settings['info']['spacer'] = tkinter.Frame(self.frames['master_frame']['info'], height = 1, bg = self.color_scheme['separator'])
        #self.fit_settings['info']['spacer'].grid(row = 1, column = 0, pady = (25,10), sticky = 'ew')

        self.fit_settings['info']['master_frame'].grid(row = 1, column = 0, pady = (50,0), sticky = 'ew')
        self.fit_settings['info']['master_frame'].columnconfigure(1, weight = 1)
        self.fit_settings['info']['header'].grid(row = 0, column = 0, columnspan = 2, sticky = 'ew')
        self.fit_settings['info']['indenter_geometry_label'].grid(row = 1, column = 0, sticky = 'w', pady = (10,0), padx = (10,0))
        self.fit_settings['info']['indenter_geometry_details'].grid(row = 1, column = 1, sticky = 'w', pady = (10,0), padx = (0,10))
        self.fit_settings['info']['indenter_characteristics_label'].grid(row = 2, column = 0, sticky = 'w', pady = (0,0), padx = (10,0))
        self.fit_settings['info']['indenter_characteristics_details'].grid(row = 2, column = 1, sticky = 'w', pady = (0,0), padx = (0,10))
        self.fit_settings['info']['poisson_ratio_label'].grid(row = 3, column = 0, sticky = 'w', pady = (0,10), padx = (10,0))
        self.fit_settings['info']['poisson_ratio_details'].grid(row = 3, column = 1, sticky = 'w', pady = (0,10), padx = (0,10))

        self.fit_settings['info']['fit_mode_label'].grid(row = 4, column = 0, sticky = 'w', pady = (0,10), padx = (10,0))
        self.fit_settings['info']['fit_mode_details'].grid(row = 4, column = 1, sticky = 'w', pady = (0,10), padx = (0,10))
        self.fit_settings['info']['max_indentation_label'].grid(row = 5, column = 0, sticky = 'w', pady = (0,0), padx = (10,0))
        self.fit_settings['info']['max_indentation_details'].grid(row = 5, column = 1, sticky = 'w', pady = (0,0), padx = (0,10))
        self.fit_settings['info']['force_limit_label'].grid(row = 6, column = 0, sticky = 'w', pady = (0,10), padx = (10,0))
        self.fit_settings['info']['force_limit_details'].grid(row = 6, column = 1, sticky = 'w', pady = (0,10), padx = (0,10))

        self.fit_settings['info']['cp_offset_label'].grid(row = 7, column = 0, sticky = 'w', pady = (0,0), padx = (10,0))
        self.fit_settings['info']['cp_offset_details'].grid(row = 7, column = 1, sticky = 'w', pady = (0,0), padx = (0,10))
        self.fit_settings['info']['baseline_weight_label'].grid(row = 8, column = 0, sticky = 'w', pady = (0,0), padx = (10,0))
        self.fit_settings['info']['baseline_weight_details'].grid(row = 8, column = 1, sticky = 'w', pady = (0,0), padx = (0,10))
        self.fit_settings['info']['distance_to_contact_label'].grid(row = 9, column = 0, sticky = 'w', pady = (0,0), padx = (10,0))
        self.fit_settings['info']['distance_to_contact_details'].grid(row = 9, column = 1, sticky = 'w', pady = (0,0), padx = (0,10))
        self.fit_settings['info']['min_fit_length_label'].grid(row = 10, column = 0, sticky = 'w', pady = (0,10), padx = (10,0))
        self.fit_settings['info']['min_fit_length_details'].grid(row = 10, column = 1, sticky = 'w', pady = (0,10), padx = (0,10))


        info1 = CreateToolTip(self.fit_settings['mode_label'], 'free contact point: Each data point in the extend data (from a start point) is set as the contact point of an individual fit to the Hertz model. That is, a familiy of individual fits is performed. From these fits, the fit with the smalles residuals is chosen as the best fit to the data. The start point of this procedure is set by the \'distance to contact point\' parameter. (Based on: Lin et al, Robust Strategies for Automated AFM Force Curve Analzysis1.Non-adhesive Indentation of Soft, Inhomogeneous Materials, J Biomech Eng 129 (2007))\n\nfixed contact point: A single fit to the Hertz model is performed with the contact point as set beforhand during the distance correction method.')
        info2 = CreateToolTip(self.fit_settings['max_indentation_label'], 'Enter maximal indentation depth up to which data is fitted (\'inf\' for no limit). Indentation limit is defined relative to the contact point. See \'Fit mode\' for details.')
        info3 = CreateToolTip(self.fit_settings['force_limit_label'], 'Enter maximal force up to which data is fitted (\'inf\' for no limit). Force limit is relative to contact point. See \'Contact point y-offset\' for details.')
        info4 = CreateToolTip(self.fit_settings['contact_point_y_offset_label'], 'Sets the y-value of the hypothetical contact point. As the contact point is moved along the extend cycle, the y-value of data points after indentation started is non-zero.\n\nzero: y-value is always 0. This option seems optimal to capture a stiff material underneath some softer material.\n\nmean: y-value is based on the mean of the data points around the contact point\n\nnone: y-value is not modified, that is the data point as recorded in the extend cycle is used as contact point')
        info5 = CreateToolTip(self.fit_settings['residuals_baseline_weight_label'], 'Sets how much the baseline contributes to the overall fit residual in addition to the residual from the hertz fit (0: nothing, 0.1: 1*hertz+0.1*baseline, 1: 1*hertz+1*baseline). The length of the baseline considered in the calculation is given by the \'Distance to contact point\' parameter.')
        info6 = CreateToolTip(self.fit_settings['distance_to_contact_label'], 'Sets how many data points before the contact point (as found in the distance correction method) are included in the fitting procedure. That is, sets the start point of the first fit in the procedure to the given distance to the contact point.')
        info7 = CreateToolTip(self.fit_settings['min_fit_length_label'], 'Minimal length of fit in the free contact point procedure. Fitting is performed for each data point in the extend cycle as fit start to the end of the extend cycle (or end point set by max indentation and/orforce limit) that results in a fit length larger than or equal to the given limit.')




    def _update_progress(self):

        if self.thread_analysis.is_alive():
            self.analysis_control_panel['progress']['bar']['value'] = self.parent.qi_object.counter['count']
            self.parent.after(50, self._update_progress)
        else:
            self.analysis_control_panel['progress']['bar']['value'] = self.parent.qi_object.counter['count']
            self.selection_panel['run_analysis_selection'].configure(state = 'normal')
            self.analysis_control_panel['button']['run'].configure(state = 'normal')
            self.results_panel['full_map']['show_results'].configure(state = 'normal')
            self.results_panel['full_map']['show_parameter'].configure(state = 'normal')
            self.results_panel['selections']['show_results'].configure(state = 'normal')
            #self.results_panel['selections']['show_parameter'].configure(state = 'normal')
            self.results_panel['selections']['data_origin'].configure(state = 'normal')
            self.results_show['selections']['data_origin'].set(True)

            self.parent.safe_closing = True
            self.safe_closing = True




    def _update_progress_selection(self):

        if self.thread_analysis.is_alive():
            self.progress_info.set('Progressing selection: ' + self.parent.qi_object.counter['select'])
            self.selection_panel['progress']['maximum'] = self.parent.qi_object.counter['max']
            self.selection_panel['progress']['value'] = self.parent.qi_object.counter['count']
            self.parent.after(50, self._update_progress_selection)
        else:
            self.selection_panel['progress']['value'] = self.parent.qi_object.counter['count']
            self.progress_info.set('')
            self.selection_panel['run_analysis_selection'].configure(state = 'normal')
            self.analysis_control_panel['button']['run'].configure(state = 'normal')
            self.results_panel['selections']['show_results'].configure(state = 'normal')
            self.results_panel['selections']['show_parameter'].configure(state = 'normal')

            self.parent.safe_closing = True
            self.safe_closing = True



    def show_analysis_results_full_map(self):


        if self.results_show['full_map']['qi_map'].get():

            x_width = np.round(self.parent.qi_object.settings['grid']['u-length']*10**6,2)
            y_width = np.round(self.parent.qi_object.settings['grid']['u-length']*10**6,2)

            fig_map_layer_1 = plt.figure()
            ax_map_layer_1 = fig_map_layer_1.add_subplot(111)
            c_map_layer_1 = ax_map_layer_1.imshow(self.parent.qi_object.data['hertz_fit']['value'], extent = [0, x_width, 0, y_width], origin = 'lower', cmap = 'gnuplot', norm=matplotlib.colors.LogNorm(vmin = 300, vmax = 30000000))
            cbar_map_layer_1 = fig_map_layer_1.colorbar(c_map_layer_1, ax=ax_map_layer_1)
            cbar_map_layer_1.set_label('Apparent Young\'s modulus / Pa', rotation = 270, labelpad = 20)
            ax_map_layer_1.set_xlabel('Position / \u03BCm')
            ax_map_layer_1.set_ylabel('Position / \u03BCm')
            ax_map_layer_1.set_title('Standard Hertz Fit')


        if self.results_show['full_map']['histogram'].get():

            data_1 = np.reshape(self.parent.qi_object.data['hertz_fit']['value'], -1)
            data_1 = data_1[~np.isnan(data_1)]



            fig_hist_layer_1 = plt.figure()
            ax_hist_layer_1 = fig_hist_layer_1.add_subplot(111)
            ax_hist_layer_1.hist(data_1/1000, bins = 'auto')
            ax_hist_layer_1.set_xlabel('Young\'s modulus / kPa')
            ax_hist_layer_1.set_ylabel('Occurrence')
            ax_hist_layer_1.set_title('Standard Hertz Fit')
            ax_hist_layer_1.tick_params(direction = 'in', top = True, right = True)


        if self.results_show['full_map']['boxplot'].get():

            data_1 = np.reshape(self.parent.qi_object.data['hertz_fit']['value'], -1)
            data_1 = data_1[~np.isnan(data_1)]


            fig_box_layer_1 = plt.figure()
            ax_box_layer_1 = fig_box_layer_1.add_subplot(111)
            ax_box_layer_1.boxplot([data_1/1000], flierprops = {'marker': 'x'})
            ax_box_layer_1.set_xlabel('')
            ax_box_layer_1.set_ylabel('Young\'s modulus / kPa')
            ax_box_layer_1.set_title('Standard Hertz Fit')
            ax_box_layer_1.tick_params(direction = 'in', top = True, right = True)







    def show_analysis_results_selections(self):

        selections = [list(self.parent.qi_object.selections.keys())[i] for i in self.selection_panel['listbox'].curselection()]
        data = dict()
        plot = False

        if not len(selections):

            self.enter_window_app.bell()
            print('No selections chosen!')
            plot = False

        elif self.results_show['selections']['data_origin'].get() and 'hertz_fit' in self.parent.qi_object.data.keys(): # data pulled from whole map

            for select in selections:

                data[select] = self.parent.qi_object.get_data(['hertz_fit', 'value'], selection = select)
                data[select] = data[select][~np.isnan(data[select])]

            plot = True

        elif not self.results_show['selections']['data_origin'].get():

            plot = True
            for select in selections:

                if select in self.parent.qi_object.hertz_fit['selections'].keys():

                    data[select] = list()
                    for ind in self.parent.qi_object.hertz_fit['selections'][select]['indices'].keys():

                        data[select] = np.append(data[select], self.parent.qi_object.hertz_fit['selections'][select]['indices'][ind]['young_modulus']['value'])

                    data[select] = data[select][~np.isnan(data[select])]

                else:

                    self.enter_window_app.bell()
                    print('Analyze the requested data first:', select)
                    plot = False

        else:

            self.enter_window_app.bell()
            print('Analyze the full map first!')
            plot = False


        if plot:


            if self.results_show['selections']['boxplot'].get():

                fig_box_selection = plt.figure()
                ax_box_selection = fig_box_selection.add_subplot(111)
                ax_box_selection.boxplot([data[select] for select in selections], labels = selections, flierprops = {'marker': 'x'})
                ax_box_selection.set_xlabel('Selection')
                ax_box_selection.set_ylabel('Young\'s modulus / Pa')
                ax_box_selection.set_title('Boxplot - Selections: Standard Hertz Fit')
                ax_box_selection.set_ylim(20,5e8)
                ax_box_selection.tick_params(direction = 'in', top = True, right = True)
                ax_box_selection.set_yscale('log')


            if self.results_show['selections']['histogram'].get():

                fig_hist_selection = plt.figure()
                ax_hist_selection = fig_hist_selection.add_subplot(111)
                ax_hist_selection.hist([data[select] for select in selections], bins = 'auto', density = True, label = selections)
                ax_hist_selection.legend()
                ax_hist_selection.set_xlabel('Young\'s modulus / Pa')
                ax_hist_selection.set_ylabel('Occurrence')
                ax_hist_selection.set_title('Histogram - Selections: Standard Hertz Fit')
                #ax_hist_selection.set_xlim(y_lim)
                ax_hist_selection.tick_params(direction = 'in', top = True, right = True)






    def show_analysis_parameter_full_map(self):

        info_window = tkinter.Toplevel()
        info_window.title('Info')
        info_window.resizable(False, False)
        info_window.focus_set()


        corrections = dict()
        corrections['force_unit'] = self.parent.qi_object.hertz_fit['full_map']['corrections']['force_unit']
        corrections['distance_unit'] = self.parent.qi_object.hertz_fit['full_map']['corrections']['distance_unit']

        corrections['baseline_correction'] = dict()
        corrections['baseline_correction']['method'] = self.parent.qi_object.hertz_fit['full_map']['corrections']['baseline_correction']['method']
        corrections['baseline_correction']['reference'] = self.parent.qi_object.hertz_fit['full_map']['corrections']['baseline_correction']['reference']
        corrections['baseline_correction']['frac_data'] = dict()
        corrections['baseline_correction']['frac_data']['min'] = self.parent.qi_object.hertz_fit['full_map']['corrections']['baseline_correction']['frac_data'][0]
        corrections['baseline_correction']['frac_data']['min'] = self.parent.qi_object.hertz_fit['full_map']['corrections']['baseline_correction']['frac_data'][1]

        frac_str = '(' + str(self.parent.qi_object.hertz_fit['full_map']['corrections']['baseline_correction']['frac_data'][0]) + ',' + str(self.parent.qi_object.hertz_fit['full_map']['corrections']['baseline_correction']['frac_data'][1]) + ')'
        corrections['baseline_correction']['frac_data_str'] = frac_str

        corrections['distance_correction'] = dict()
        corrections['distance_correction']['method'] = self.parent.qi_object.hertz_fit['full_map']['corrections']['distance_correction']['method']
        corrections['distance_correction']['reference'] = self.parent.qi_object.hertz_fit['full_map']['corrections']['distance_correction']['reference']
        corrections['distance_correction']['smooth_applied'] = self.parent.qi_object.hertz_fit['full_map']['corrections']['distance_correction']['smooth_applied']
        corrections['distance_correction']['smooth_length'] = self.parent.qi_object.hertz_fit['full_map']['corrections']['distance_correction']['smooth_length']
        corrections['distance_correction']['length_fit'] = self.parent.qi_object.hertz_fit['full_map']['corrections']['distance_correction']['length_fit']

        corrections['get_tip_sample_separation'] = str(self.parent.qi_object.hertz_fit['full_map']['corrections']['get_tip_sample_separation'])


        parameters = dict()
        parameters[0] = dict()
        if self.parent.qi_object.hertz_fit['full_map']['indenter']['geometry'] == 'parabolic':
            parameters[0]['Indenter geometry'] = 'parabolic'
            parameters[0]['Radius [nm]'] = self.parent.qi_object.hertz_fit['full_map']['indenter']['radius [nm]']
        elif self.parent.qi_object.hertz_fit['full_map']['indenter']['geometry'] == 'four-sided pyramid':
            parameters[0]['Indenter geometry'] = 'f-s pyramid'
            parameters[0]['Radius [nm]'] = self.parent.qi_object.hertz_fit['full_map']['indenter']['angle [grad]']
        elif self.parent.qi_object.hertz_fit['full_map']['indenter']['geometry'] == 'conical':
            parameters[0]['Indenter geometry'] = 'conical'
            parameters[0]['Angle [grad]'] = self.parent.qi_object.hertz_fit['full_map']['indenter']['angle [grad]']
        parameters[0]['Poisson ratio'] = self.parent.qi_object.hertz_fit['full_map']['poisson_ratio']

        parameters[1] = dict()


        parameters[2] = dict()
        parameters[2]['Max indentation'] = self.parent.qi_object.hertz_fit['full_map']['method']['parameter']['max_indentation']
        parameters[2]['Force limit'] = self.parent.qi_object.hertz_fit['full_map']['method']['parameter']['force_limit']


        if self.parent.qi_object.hertz_fit['full_map']['method']['parameter']['mode'] == 'free_contact_point':
            parameters[1]['Fit mode'] = 'free CP'
            parameters[3] = dict()
            parameters[3]['CP y-offset'] = self.parent.qi_object.hertz_fit['full_map']['method']['parameter']['y_offset']
            parameters[3]['Baseline weight'] = self.parent.qi_object.hertz_fit['full_map']['method']['parameter']['residuals_baseline_weight']
            parameters[3]['Distance to CP'] = self.parent.qi_object.hertz_fit['full_map']['method']['parameter']['distance_to_contact']
            parameters[3]['Min fit length'] = self.parent.qi_object.hertz_fit['full_map']['method']['parameter']['min_fit_length']

        else:
            parameters[1]['Fit mode'] = 'fixed CP'


        info_frames = dict()
        info_frames['header_frame'] = tkinter.Frame(info_window, background = self.color_scheme['background'], relief = 'ridge', borderwidth = 2)
        info_frames['header 1'] = tkinter.Label(info_frames['header_frame'], text = 'Analysis Info - Standard Hertz Fit', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])
        info_frames['header 2'] = tkinter.Label(info_frames['header_frame'], text = '----- Full Map -----', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])

        info_frames['corrections_master'] = tkinter.Frame(info_window, background = self.color_scheme['background'])
        info_frames['parameters_master'] = tkinter.Frame(info_window, background = self.color_scheme['background'])
        info_frames['corrections'] = CorrectionInfoFrame_Result(info_frames['corrections_master'], corrections = corrections, background = self.color_scheme['background'], textcolor = self.color_scheme['text_standard'], highlighttextcolor = self.color_scheme['text_highlighted'])
        info_frames['parameters'] = ParameterInfoFrame_Result(info_frames['parameters_master'], parameters = parameters, background = self.color_scheme['background'], textcolor = self.color_scheme['text_standard'], highlighttextcolor = self.color_scheme['text_highlighted'])

        info_frames['header_frame'].grid(row = 0, column = 0, sticky = 'nswe')
        info_frames['corrections_master'].grid(row = 1, column = 0, sticky = 'nswe')
        info_frames['parameters_master'].grid(row = 2, column = 0, sticky = 'we')

        info_frames['header 1'].grid(row = 0, column = 0, sticky = 'nswe', padx = 10, pady = (10,0))
        info_frames['header 2'].grid(row = 1, column = 0, sticky = 'nswe', padx = 10, pady = (0,10))
        info_frames['corrections'].grid(row = 0, column = 0, sticky = 'nswe', pady = (0,50))
        info_frames['parameters'].grid(row = 0, column = 0, sticky = 'nswe')
        #info_window.columnconfigure(0, weight = 1)
        info_frames['corrections_master'].columnconfigure(0, weight = 1)
        info_frames['parameters_master'].columnconfigure(0, weight = 1)
        #info_frames['parameters'].columnconfigure(0, weight = 1)





    def show_analysis_parameter_selections(self):

        selections = [list(self.parent.qi_object.selections.keys())[i] for i in self.selection_panel['listbox'].curselection()]

        show_info = False

        if not len(selections):

            self.enter_window_app.bell()
            print('No selections chosen!')
            show_info = False

        else:

            show_info = True

            for select in selections:

                if select not in self.parent.qi_object.hertz_fit['selections'].keys():

                    self.enter_window_app.bell()
                    print('Analyze the requested data first:', select)
                    show_info = False


        if show_info:

            info_window = tkinter.Toplevel()
            info_window.title('Info')
            info_window.resizable(False, False)
            info_window.focus_set()

            corrections = dict()
            parameters = dict()

            for select in selections:

                corrections[select] = dict()
                corrections[select]['force_unit'] = self.parent.qi_object.hertz_fit['selections'][select]['corrections']['force_unit']
                corrections[select]['distance_unit'] = self.parent.qi_object.hertz_fit['selections'][select]['corrections']['distance_unit']

                corrections[select]['baseline_correction'] = dict()
                corrections[select]['baseline_correction']['method'] = self.parent.qi_object.hertz_fit['selections'][select]['corrections']['baseline_correction']['method']
                corrections[select]['baseline_correction']['reference'] = self.parent.qi_object.hertz_fit['selections'][select]['corrections']['baseline_correction']['reference']
                corrections[select]['baseline_correction']['frac_data'] = dict()
                corrections[select]['baseline_correction']['frac_data']['min'] = self.parent.qi_object.hertz_fit['selections'][select]['corrections']['baseline_correction']['frac_data'][0]
                corrections[select]['baseline_correction']['frac_data']['min'] = self.parent.qi_object.hertz_fit['selections'][select]['corrections']['baseline_correction']['frac_data'][1]

                frac_str = '(' + str(self.parent.qi_object.hertz_fit['selections'][select]['corrections']['baseline_correction']['frac_data'][0]) + ',' + str(self.parent.qi_object.hertz_fit['selections'][select]['corrections']['baseline_correction']['frac_data'][1]) + ')'
                corrections[select]['baseline_correction']['frac_data_str'] = frac_str

                corrections[select]['distance_correction'] = dict()
                corrections[select]['distance_correction']['method'] = self.parent.qi_object.hertz_fit['selections'][select]['corrections']['distance_correction']['method']
                corrections[select]['distance_correction']['reference'] = self.parent.qi_object.hertz_fit['selections'][select]['corrections']['distance_correction']['reference']
                corrections[select]['distance_correction']['smooth_applied'] = self.parent.qi_object.hertz_fit['selections'][select]['corrections']['distance_correction']['smooth_applied']
                corrections[select]['distance_correction']['smooth_length'] = self.parent.qi_object.hertz_fit['selections'][select]['corrections']['distance_correction']['smooth_length']
                corrections[select]['distance_correction']['length_fit'] = self.parent.qi_object.hertz_fit['selections'][select]['corrections']['distance_correction']['length_fit']

                corrections[select]['get_tip_sample_separation'] = str(self.parent.qi_object.hertz_fit['selections'][select]['corrections']['get_tip_sample_separation'])



                parameters[select] = dict()
                parameters[select][0] = dict()
                if self.parent.qi_object.hertz_fit['selections'][select]['indenter']['geometry'] == 'parabolic':
                    parameters[select][0]['Indenter geometry'] = 'parabolic'
                    parameters[select][0]['Radius [nm]'] = self.parent.qi_object.hertz_fit['selections'][select]['indenter']['radius [nm]']
                elif self.parent.qi_object.hertz_fit['selections'][select]['indenter']['geometry'] == 'four-sided pyramid':
                    parameters[select][0]['Indenter geometry'] = 'f-s pyramid'
                    parameters[select][0]['Radius [nm]'] = self.parent.qi_object.hertz_fit['selections'][select]['indenter']['angle [grad]']
                elif self.parent.qi_object.hertz_fit['selections'][select]['indenter']['geometry'] == 'conical':
                    parameters[select][0]['Indenter geometry'] = 'conical'
                    parameters[select][0]['Angle [grad]'] = self.parent.qi_object.hertz_fit['selections'][select]['indenter']['angle [grad]']
                parameters[select][0]['Poisson ratio'] = self.parent.qi_object.hertz_fit['selections'][select]['poisson_ratio']

                parameters[select][1] = dict()


                parameters[select][2] = dict()
                parameters[select][2]['Max indentation'] = self.parent.qi_object.hertz_fit['selections'][select]['method']['parameter']['max_indentation']
                parameters[select][2]['Force limit'] = self.parent.qi_object.hertz_fit['selections'][select]['method']['parameter']['force_limit']


                if self.parent.qi_object.hertz_fit['selections'][select]['method']['parameter']['mode'] == 'free_contact_point':
                    parameters[select][1]['Fit mode'] = 'free CP'
                    parameters[select][3] = dict()
                    parameters[select][3]['CP y-offset'] = self.parent.qi_object.hertz_fit['selections'][select]['method']['parameter']['y_offset']
                    parameters[select][3]['Baseline weight'] = self.parent.qi_object.hertz_fit['selections'][select]['method']['parameter']['residuals_baseline_weight']
                    parameters[select][3]['Distance to CP'] = self.parent.qi_object.hertz_fit['selections'][select]['method']['parameter']['distance_to_contact']
                    parameters[select][3]['Min fit length'] = self.parent.qi_object.hertz_fit['selections'][select]['method']['parameter']['min_fit_length']

                else:
                    parameters[select][1]['Fit mode'] = 'fixed CP'


            info_frames = dict()
            column = 0

            for i in range(len(selections)):

                info_frames[selections[i]] = dict()
                info_frames[selections[i]]['header_frame'] = tkinter.Frame(info_window, background = self.color_scheme['background'], relief = 'ridge', borderwidth = 2)
                info_frames[selections[i]]['header 1'] = tkinter.Label(info_frames[selections[i]]['header_frame'], text = 'Analysis Info - Standard Hertz Fit', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])
                info_frames[selections[i]]['header 2'] = tkinter.Label(info_frames[selections[i]]['header_frame'], text = '----- Selection: '+ str(selections[i])+ ' -----', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])

                info_frames[selections[i]]['corrections_master'] = tkinter.Frame(info_window, background = self.color_scheme['background'])
                info_frames[selections[i]]['parameters_master'] = tkinter.Frame(info_window, background = self.color_scheme['background'])
                info_frames[selections[i]]['corrections'] = CorrectionInfoFrame_Result(info_frames[selections[i]]['corrections_master'], corrections = corrections[selections[i]], background = self.color_scheme['background'], textcolor = self.color_scheme['text_standard'], highlighttextcolor = self.color_scheme['text_highlighted'])
                info_frames[selections[i]]['parameters'] = ParameterInfoFrame_Result(info_frames[selections[i]]['parameters_master'], parameters = parameters[selections[i]], background = self.color_scheme['background'], textcolor = self.color_scheme['text_standard'], highlighttextcolor = self.color_scheme['text_highlighted'])

                info_frames[selections[i]]['header_frame'].grid(row = 0, column = column, sticky = 'nswe')
                info_frames[selections[i]]['corrections_master'].grid(row = 1, column = column, sticky = 'nswe')
                info_frames[selections[i]]['parameters_master'].grid(row = 2, column = column, sticky = 'nswe')

                if not i == len(selections) - 1:

                    info_frames[selections[i]]['separator'] = tkinter.Frame(info_window, width = 1, bg = self.color_scheme['separator'])
                    info_frames[selections[i]]['separator'].grid(row = 0, column = column + 1, rowspan = 3, sticky = 'ns')


                info_frames[selections[i]]['header 1'].grid(row = 0, column = 0, sticky = 'nswe', padx = 10, pady = (10,0))
                info_frames[selections[i]]['header 2'].grid(row = 1, column = 0, sticky = 'nswe', padx = 10, pady = (0,10))
                info_frames[selections[i]]['corrections'].grid(row = 0, column = 0, sticky = 'nswe', pady = (0,50))
                info_frames[selections[i]]['parameters'].grid(row = 0, column = 0, sticky = 'nswe')
                #info_window.columnconfigure(0, weight = 1)
                info_frames[selections[i]]['corrections_master'].columnconfigure(0, weight = 1)
                info_frames[selections[i]]['parameters_master'].columnconfigure(0, weight = 1)

                column += 2



    def _update_combobox_indenter_geometry(self, event = None):

        choice = self.settings['hertz_fit_parameter']['indenter_geometry'].get()

        if choice == 'parabolic':

            self.settings['hertz_fit_parameter']['indenter_geometry_characteristics_label'].set('Radius [nm]:')
            self.settings['hertz_fit_parameter']['indenter_geometry_characteristics'].set(10)
            self.indenter_characteristics = {'geometry': 'parabolic', 'radius [nm]': 10}
            self.fit_settings['info']['indenter_geometry_details'].configure(text = 'parabolic')
            self.fit_settings['info']['indenter_characteristics_label'].configure(text = 'Radius [nm]')
            self.fit_settings['info']['indenter_characteristics_details'].configure(text = '10')

        elif choice == 'four-sided pyramid':

            self.settings['hertz_fit_parameter']['indenter_geometry_characteristics_label'].set('Face angle [grad]:')
            self.settings['hertz_fit_parameter']['indenter_geometry_characteristics'].set(35)
            self.indenter_characteristics = {'geometry': 'four-sided pyramid', 'angle [grad]': 35}
            self.fit_settings['info']['indenter_geometry_details'].configure(text = 'f-s pyramid')
            self.fit_settings['info']['indenter_characteristics_label'].configure(text = 'Face angle [grad]:')
            self.fit_settings['info']['indenter_characteristics_details'].configure(text = '35')

        elif choice == 'conical':

            self.settings['hertz_fit_parameter']['indenter_geometry_characteristics_label'].set('Half cone angle [grad]:')
            self.settings['hertz_fit_parameter']['indenter_geometry_characteristics'].set(15)
            self.indenter_characteristics = {'geometry': 'conical', 'angle [grad]': 15}
            self.fit_settings['info']['indenter_geometry_details'].configure(text = 'conical')
            self.fit_settings['info']['indenter_characteristics_label'].configure(text = 'Half cone angle [grad]:')
            self.fit_settings['info']['indenter_characteristics_details'].configure(text = '15')

        # elif choice == 'spherical':
        #
        #     self.settings['hertz_fit_parameter']['indenter_geometry_characteristics_label'].set('Radius [nm]:')
        #     self.settings['hertz_fit_parameter']['indenter_geometry_characteristics'].set(10)
        #     self.indenter_characteristics = {'geometry': 'spherical', 'radius [nm]': 10}
        #     self.fit_settings['info']['indenter_geometry_details'].configure(text = 'spherical')

        self.update_plot()




    def _update_combobox_fit_mode(self, event = None):

        choice = self.settings['fit_settings']['mode'].get()

        if choice == 'free contact point':
            self.fit_settings_values['mode'] = 'free_contact_point'
            self.fit_settings['free_contact_point_frame'].configure(fg = self.color_scheme['text_standard'])
            self.fit_settings['info']['fit_mode_details'].configure(text = 'free CP')

            self.fit_settings['contact_point_y_offset_label'].configure(state = 'normal')
            self.fit_settings['contact_point_y_offset_combobox'].set_state('normal')
            self.fit_settings['residuals_baseline_weight_label'].configure(state = 'normal')
            self.fit_settings['residuals_baseline_weight_entry'].configure(state = 'normal')
            self.fit_settings['distance_to_contact_label'].configure(state = 'normal')
            self.fit_settings['distance_to_contact_entry'].configure(state = 'normal')
            self.fit_settings['min_fit_length_label'].configure(state = 'normal')
            self.fit_settings['min_fit_length_entry'].configure(state = 'normal')

            self.fit_settings['info']['cp_offset_label'].configure(state = 'normal')
            self.fit_settings['info']['cp_offset_details'].configure(state = 'normal')
            self.fit_settings['info']['baseline_weight_label'].configure(state = 'normal')
            self.fit_settings['info']['baseline_weight_details'].configure(state = 'normal')
            self.fit_settings['info']['distance_to_contact_label'].configure(state = 'normal')
            self.fit_settings['info']['distance_to_contact_details'].configure(state = 'normal')
            self.fit_settings['info']['min_fit_length_label'].configure(state = 'normal')
            self.fit_settings['info']['min_fit_length_details'].configure(state = 'normal')

        elif choice == 'fixed contact point':
            self.fit_settings_values['mode'] = 'fixed_contact_point'

            self.fit_settings['free_contact_point_frame'].configure(fg = self.color_scheme['text_disabled'])
            self.fit_settings['info']['fit_mode_details'].configure(text = 'fixed CP')

            self.fit_settings['contact_point_y_offset_label'].configure(state = 'disabled')
            self.fit_settings['contact_point_y_offset_combobox'].set_state('disabled')
            self.fit_settings['residuals_baseline_weight_label'].configure(state = 'disabled')
            self.fit_settings['residuals_baseline_weight_entry'].configure(state = 'disabled')
            self.fit_settings['distance_to_contact_label'].configure(state = 'disabled')
            self.fit_settings['distance_to_contact_entry'].configure(state = 'disabled')
            self.fit_settings['min_fit_length_label'].configure(state = 'disabled')
            self.fit_settings['min_fit_length_entry'].configure(state = 'disabled')

            self.fit_settings['info']['cp_offset_label'].configure(state = 'disabled')
            self.fit_settings['info']['cp_offset_details'].configure(state = 'disabled')
            self.fit_settings['info']['baseline_weight_label'].configure(state = 'disabled')
            self.fit_settings['info']['baseline_weight_details'].configure(state = 'disabled')
            self.fit_settings['info']['distance_to_contact_label'].configure(state = 'disabled')
            self.fit_settings['info']['distance_to_contact_details'].configure(state = 'disabled')
            self.fit_settings['info']['min_fit_length_label'].configure(state = 'disabled')
            self.fit_settings['info']['min_fit_length_details'].configure(state = 'disabled')


        self.update_plot()






    def _update_combobox_y_offset(self, event = None):

        choice = self.settings['fit_settings']['y_offset'].get()

        if choice == 'zero':
            self.fit_settings_values['y_offset'] = 'zero'
            self.fit_settings['info']['cp_offset_details'].configure(text = 'zero')
        elif choice == 'mean':
            self.fit_settings_values['y_offset'] = 'mean_contact_point'
            self.fit_settings['info']['cp_offset_details'].configure(text = 'mean')
        elif choice == 'none':
            self.fit_settings_values['y_offset'] = 'none'
            self.fit_settings['info']['cp_offset_details'].configure(text = 'none')
        self.update_plot()




    def _enter_poisson_ratio(self, event = None):

        try:

            conv = float(self.settings['hertz_fit_parameter']['poisson_ratio'].get())

            if conv:

                self.poisson_ratio = conv
                self.fit_settings['info']['poisson_ratio_details'].configure(text = str(conv))
                self.update_plot()

            else:

                self.enter_window_app.bell()

        except:

            self.enter_window_app.bell()




    def _enter_indenter_characteristics(self, event = None):

        try:

            conv = float(self.settings['hertz_fit_parameter']['indenter_geometry_characteristics'].get())


            if conv > 0:

                choice = self.settings['hertz_fit_parameter']['indenter_geometry'].get()

                if choice == 'parabolic':

                    self.indenter_characteristics = {'geometry': 'parabolic', 'radius [nm]': conv}

                elif choice == 'four-sided pyramid':

                    self.indenter_characteristics = {'geometry': 'four-sided pyramid', 'angle [grad]': conv}

                # elif choice == 'spherical':
                #
                #     self.indenter_characteristics = {'geometry': 'spherical', 'radius [nm]': conv}

                elif choice == 'conical':

                    self.indenter_characteristics = {'geometry': 'conical', 'angle [grad]': conv}

                self.fit_settings['info']['indenter_characteristics_details'].configure(text = str(conv))
                self.update_plot()


            else:

                self.enter_window_app.bell()

        except:


            self.enter_window_app.bell()




    def _enter_max_indentation(self, event = None):

        if self.settings['fit_settings']['max_indentation'].get() == 'inf':
            self.fit_settings_values['max_indentation'] = np.inf
            self.fit_settings['info']['max_indentation_details'].configure(text = 'inf')
            self.update_plot()

        else:
            try:
                conv = float(self.settings['fit_settings']['max_indentation'].get())
                if conv > 0:
                    self.fit_settings_values['max_indentation'] = conv
                    self.fit_settings['info']['max_indentation_details'].configure(text = str(conv))
                    self.update_plot()
                else:
                    self.enter_window_app.bell()
            except:
                self.enter_window_app.bell()




    def _enter_force_limit(self, event = None):

        if self.settings['fit_settings']['force_limit'].get() == 'inf':
            self.fit_settings_values['force_limit'] = np.inf
            self.fit_settings['info']['force_limit_details'].configure(text = 'inf')
            self.update_plot()

        else:
            try:
                conv = float(self.settings['fit_settings']['force_limit'].get())
                if conv > 0:
                    self.fit_settings_values['force_limit'] = conv
                    self.fit_settings['info']['force_limit_details'].configure(text = str(conv))
                    self.update_plot()
                else:
                    self.enter_window_app.bell()
            except:
                self.enter_window_app.bell()

        #print(self.fit_settings_values)




    def _enter_residual_baseline_weight(self, event = None):

        try:
            conv = float(self.settings['fit_settings']['residuals_baseline_weight'].get())
            if conv >= 0:
                self.fit_settings_values['residuals_baseline_weight'] = conv
                self.fit_settings['info']['baseline_weight_details'].configure(text = str(conv))
                self.update_plot()
            else:
                self.enter_window_app.bell()
        except:
            self.enter_window_app.bell()




    def _enter_distance_to_contact(self, event = None):

        try:
            conv = int(self.settings['fit_settings']['distance_to_contact'].get())
            if conv >= 0:
                self.fit_settings_values['distance_to_contact'] = conv
                self.fit_settings['info']['distance_to_contact_details'].configure(text = str(conv))
                self.update_plot()
            else:
                self.enter_window_app.bell()
        except:
            self.enter_window_app.bell()




    def _enter_min_fit_length(self, event = None):

        try:
            conv = int(self.settings['fit_settings']['min_fit_length'].get())
            if conv > 9:
                self.fit_settings_values['min_fit_length'] = conv
                self.fit_settings['info']['min_fit_length_details'].configure(text = str(conv))
                self.update_plot()
            else:
                self.enter_window_app.bell()
        except:
            self.enter_window_app.bell()




    def _reset_settings(self):

        self.settings['fit_settings']['mode'].set('free contact point')
        self.settings['fit_settings']['y_offset'].set('zero')
        self.settings['fit_settings']['max_indentation'].set('inf')
        self.settings['fit_settings']['force_limit'].set('inf')
        self.settings['fit_settings']['residuals_baseline_weight'].set('0')
        self.settings['fit_settings']['distance_to_contact'].set('50')
        self.settings['fit_settings']['min_fit_length'].set('20')
        self.fit_settings_values = {'mode': 'free_contact_point', 'y_offset':'zero', 'max_indentation': np.inf, 'force_limit': np.inf, 'residuals_baseline_weight': 0, 'distance_to_contact': 50 , 'min_fit_length': 20}

        self.fit_settings['free_contact_point_frame'].configure(fg = self.color_scheme['text_standard'])

        self.fit_settings['contact_point_y_offset_label'].configure(state = 'normal')
        self.fit_settings['contact_point_y_offset_combobox'].set_state('normal')
        self.fit_settings['residuals_baseline_weight_label'].configure(state = 'normal')
        self.fit_settings['residuals_baseline_weight_entry'].configure(state = 'normal')
        self.fit_settings['distance_to_contact_label'].configure(state = 'normal')
        self.fit_settings['distance_to_contact_entry'].configure(state = 'normal')
        self.fit_settings['min_fit_length_label'].configure(state = 'normal')
        self.fit_settings['min_fit_length_entry'].configure(state = 'normal')

        self.fit_settings['info']['fit_mode_details'].configure(text = 'free CP')
        self.fit_settings['info']['max_indentation_details'].configure(text = 'inf')
        self.fit_settings['info']['force_limit_details'].configure(text = 'inf')
        self.fit_settings['info']['baseline_weight_details'].configure(text = '0')
        self.fit_settings['info']['distance_to_contact_details'].configure(text = '50')
        self.fit_settings['info']['min_fit_length_details'].configure(text = '20')

        self.fit_settings['info']['cp_offset_label'].configure(state = 'normal')
        self.fit_settings['info']['cp_offset_details'].configure(state = 'normal')
        self.fit_settings['info']['baseline_weight_label'].configure(state = 'normal')
        self.fit_settings['info']['baseline_weight_details'].configure(state = 'normal')
        self.fit_settings['info']['distance_to_contact_label'].configure(state = 'normal')
        self.fit_settings['info']['distance_to_contact_details'].configure(state = 'normal')
        self.fit_settings['info']['min_fit_length_label'].configure(state = 'normal')
        self.fit_settings['info']['min_fit_length_details'].configure(state = 'normal')

        self.update_plot()




    def _toggle_preview(self):

        #print(self.settings['visualization']['show_preview'].get())
        if self.settings['visualization']['show_preview'].get():

            self.parent.breakthrough_events_window.settings['visualization']['show_preview'].set(False)
            self.parent.multi_layer_segments_window.settings['visualization']['show_preview'].set(False)


        self.update_plot()
            #print('switch all other previews off')

        #self.settings['visualization']['show_preview'].set(True)
        #breakthrough events --> false




    def _toggle_export_result(self):

        if self.settings['visualization']['export_result'].get():

            self.settings['visualization']['svg'].set(True)
            self.settings['visualization']['pdf'].set(True)
            self.settings['visualization']['png'].set(True)
            self.settings['visualization']['pkl'].set(True)

        else:

            self.settings['visualization']['svg'].set(False)
            self.settings['visualization']['pdf'].set(False)
            self.settings['visualization']['png'].set(False)
            self.settings['visualization']['pkl'].set(False)

        self._update_export_fileformats()




    def _update_export_fileformats(self):

        if self.settings['visualization']['svg'].get():

            if 'svg' not in self.settings['export_fileformats']:
                self.settings['export_fileformats'].append('svg')
        else:
            if 'svg' in self.settings['export_fileformats']:
                self.settings['export_fileformats'].remove('svg')

        if self.settings['visualization']['pdf'].get():
            if 'pdf' not in self.settings['export_fileformats']:
                self.settings['export_fileformats'].append('pdf')
        else:
            if 'pdf' in self.settings['export_fileformats']:
                self.settings['export_fileformats'].remove('pdf')

        if self.settings['visualization']['png'].get():
            if 'png' not in self.settings['export_fileformats']:
                self.settings['export_fileformats'].append('png')
        else:
            if 'png' in self.settings['export_fileformats']:
                self.settings['export_fileformats'].remove('png')

        if self.settings['visualization']['pkl'].get():
            if 'pkl' not in self.settings['export_fileformats']:
                self.settings['export_fileformats'].append('pkl')
        else:
            if 'pkl' in self.settings['export_fileformats']:
                self.settings['export_fileformats'].remove('pkl')

        #print(self.settings['export_fileformats'])









class MultiLayerLinearizedHertzWindow():

    def __init__(self,QI_FD_Preview_object):

        self.parent = QI_FD_Preview_object
        self.safe_closing = True
        self.enter_window_app = None
        self.update_plot = QI_FD_Preview_object.update_plot

        self.settings = dict()
        self.settings['hertz_fit_parameter'] = {'indenter_geometry': tkinter.StringVar(None,'parabolic'), 'indenter_geometry_characteristics': tkinter.StringVar(None, 10), 'indenter_geometry_characteristics_label': tkinter.StringVar(None, 'Radius [nm]:'), 'poisson_ratio':tkinter.StringVar(None, 0.5)}
        self.settings['visualization'] = {'show_preview': tkinter.BooleanVar(None,False), 'retract_plot': tkinter.BooleanVar(None,False), 'export_result': tkinter.BooleanVar(None,False), 'svg':tkinter.BooleanVar(None,False), 'pdf': tkinter.BooleanVar(None,False), 'png': tkinter.BooleanVar(None,False), 'pkl': tkinter.BooleanVar(None,False)}
        self.settings['export_fileformats'] = list()

        self.indenter_characteristics = {'geometry': 'parabolic', 'radius [nm]': 10}
        #self.indenter_characteristics_string = tkinter.StringVar(None, 'parabolic, 10 nm')
        self.poisson_ratio = 0.5

        self.show_in_fd_curve_preview = tkinter.BooleanVar(None,False)
        self.control_parameter = QI_FD_Preview_object.control_parameter

        self.progress_info = tkinter.StringVar(None)
        self.thread_analysis = None

        self.frames = None
        self.header = None
        self.hertz_model_parameter = None
        self.fit_settings = None
        self.visualization = None
        self.analysis_control_panel = None
        self.selection_panel = None
        self.results_panel  = None
        self.results_show = {'full_map': {'qi_map': tkinter.BooleanVar(None,True), 'boxplot': tkinter.BooleanVar(None,False), 'histogram': tkinter.BooleanVar(None,False)}, 'selections': {'data_origin': tkinter.BooleanVar(None,False), 'boxplot': tkinter.BooleanVar(None,True), 'histogram': tkinter.BooleanVar(None,False), 'cumulative': tkinter.BooleanVar(None,False), 'layer': tkinter.IntVar(None, 1), 'layer_string': tkinter.StringVar(None, 'Layer 1')}}

        #self.background = '#282330'
        #self.foreground = '#dfdae0'

        self.color_scheme = _Helper_Functions_GUI._set_color_options()






    def on_closing(self):

        if self.safe_closing:

            self.enter_window_app.destroy()
            self.control_parameter['multi_layer_segments_window'] = False
            self.settings['visualization']['show_preview'].set(False)
            self.enter_window_app = None

            self.progress_info.set('')
            self.thread_analysis = None

            self.frames = None
            self.header = None
            self.hertz_model_parameter = None
            self.fit_settings = None
            self.visualization = None
            self.analysis_control_panel = None
            self.selection_panel = None
            self.results_panel = None


        else:

            self.enter_window_app.bell()
            tkinter.messagebox.showinfo(parent = self.enter_window_app, title = 'Why so impatient! Let me finish first!', message = 'Cannot close Window. Analysis is still running!')



    #def on_opening(self):

        #self.settings['visualization']['show_preview'].set(True)
        #self._toggle_preview()
        #set all others to false
        #print('To Do: closes all the other analysis windows so that only one is active at times')
        #self.update_plot()




    def _on_open_new_qi_map(self):

        if self.control_parameter['multi_layer_segments_window']:

            self.results_panel['full_map']['show_results'].configure(state = 'disabled')
            self.results_panel['selections']['show_results'].configure(state = 'disabled')
            self.results_panel['selections']['data_origin'].configure(state = 'disabled')
            self.results_show['selections']['data_origin'].set(False)

            self.analysis_control_panel['button']['run'].configure(state = 'disabled')
            self.selection_panel['run_analysis_selection'].configure(state = 'disabled')

            self.selection_panel['listbox'].delete(0,'end')
            for select in self.parent.qi_object.selections.keys():
                self.selection_panel['listbox'].insert('end', select)




    def _on_loading_qi_snapshot(self):

        if self.control_parameter['multi_layer_segments_window']:

            if self.parent.qi_object.control_variables['allow_analysis']:
                self.analysis_control_panel['button']['run'].configure(state = 'normal')

                if len(self.parent.qi_object.multi_layer_hertz['full_map']):
                    self.results_panel['full_map']['show_results'].configure(state = 'normal')
                    self.results_panel['selections']['show_results'].configure(state = 'normal')
                    self.results_panel['selections']['data_origin'].configure(state = 'normal')
                else:
                    self.results_panel['full_map']['show_results'].configure(state = 'disabled')

                    if len(self.parent.qi_object.multi_layer_hertz['selections']):
                        self.results_panel['selections']['show_results'].configure(state = 'normal')
                    else:
                        self.results_panel['selections']['show_results'].configure(state = 'disabled')


            else:
                self.analysis_control_panel['button']['run'] .configure(state = 'disabled')


            for select in self.parent.qi_object.selections.keys():
                self.selection_panel['listbox'].insert('end', select)





    def setup_multi_layer_segments(self):

        #self.on_opening()

        if isinstance(self.enter_window_app, tkinter.Toplevel):

            self.enter_window_app.lift()
            self.enter_window_app.focus_set()

        else:

            self.enter_window_app = tkinter.Toplevel() #use tkinter.Tk() only once in an application
            self.enter_window_app.title('Three-Layer Linearized Hertz Algorithm')
            self.enter_window_app.resizable(False, False)
            self.enter_window_app.focus_set()

            self.control_parameter['multi_layer_segments_window'] = True
            self.settings['visualization']['show_preview'].set(True)

            self._create_frames()
            self._create_frame_content()
            self._toggle_preview()

            self.hertz_model_parameter['entry']['indenter_geometry'].bind('<Return>', self._enter_indenter_characteristics)
            self.hertz_model_parameter['entry']['poisson_ratio'].bind('<Return>', self._enter_poisson_ratio)

            self.enter_window_app.protocol("WM_DELETE_WINDOW", self.on_closing)




    def run_fit_multi_layer_segments(self):

        if self.settings['export_fileformats']:
            export_result = self.settings['export_fileformats']
        else:
            export_result = False

        self.parent.safe_closing = False
        self.safe_closing = False

        self.selection_panel['run_analysis_selection'].configure(state = 'disabled')
        self.analysis_control_panel['button']['run'].configure(state = 'disabled')
        self.analysis_control_panel['progress']['bar']['maximum'] = self.parent.qi_object.settings['fd_indices']['total'] - 1
        self.thread_analysis = threading.Thread(target = self.parent.qi_object.fit_multi_layer_segments, kwargs = {'poisson_ratio': self.poisson_ratio, 'indenter_characteristics': self.indenter_characteristics, 'export_result': export_result, 'retract_plot': self.settings['visualization']['retract_plot'].get()})
        print('====================')
        self.thread_analysis.start()
        self.parent.after(500, self._update_progress)






    def run_fit_multi_layer_segments_selection(self):

        selections = [list(self.parent.qi_object.selections.keys())[i] for i in self.selection_panel['listbox'].curselection()]

        if self.settings['export_fileformats']:
            export_result = self.settings['export_fileformats']
        else:
            export_result = False


        if bool(selections):

            self.parent.safe_closing = False
            self.safe_closing = False

            self.selection_panel['run_analysis_selection'].configure(state = 'disabled')
            self.analysis_control_panel['button']['run'].configure(state = 'disabled')
            self.thread_analysis = threading.Thread(target = self.parent.qi_object.fit_multi_layer_segments, kwargs = {'selection':selections, 'poisson_ratio': self.poisson_ratio, 'indenter_characteristics': self.indenter_characteristics, 'export_result': export_result, 'retract_plot': self.settings['visualization']['retract_plot'].get()})
            print('====================')
            self.selection_panel['progress']['maximum'] = self.parent.qi_object.counter['max']
            self.thread_analysis.start()
            self.parent.after(50, self._update_progress_selection)







    def _create_frames(self):

        self.frames = dict()
        self.frames['master_frame'] = dict()
        self.frames['master_frame']['frame'] = tkinter.Frame(self.enter_window_app, background = self.color_scheme['background'])
        self.frames['master_frame']['separator'] = tkinter.Frame(self.enter_window_app, width = 1, bg = self.color_scheme['separator'])
        self.frames['master_frame']['info'] = tkinter.Frame(self.enter_window_app, bg = self.color_scheme['background'])

        self.frames['master_frame']['frame'].grid(row = 0, column = 0, sticky = 'nsw')
        self.frames['master_frame']['separator'].grid(row = 0, column = 1, sticky = 'ns')
        self.frames['master_frame']['info'].grid(row = 0, column = 2, sticky = 'nswe')
        #frames['master_frame']['frame'].grid_propagate(False)
        self.frames['correction_info_frame'] = dict()
        self.frames['correction_info_frame']['frame'] = CorrectionInfoFrame(self.frames['master_frame']['info'], correction_window_ref = self.parent.corrections_window.confirmed_corrections, background = self.color_scheme['background'], textcolor = self.color_scheme['text_standard'], highlighttextcolor = self.color_scheme['text_highlighted'])#, relief = 'sunken', borderwidth = 1)
        self.frames['correction_info_frame']['frame'].grid(row = 0, column = 0, sticky = 'nswe')

        self.frames['master_frame']['children'] = dict()
        self.frames['master_frame']['children']['hertz_model_parameter'] = tkinter.Frame(self.frames['master_frame']['frame'], bg = self.color_scheme['background'])
        #frames['master_frame']['children']['segment_parameter'] = tkinter.Frame(frames['master_frame']['frame'])
        self.frames['master_frame']['children']['export_plot'] = tkinter.Frame(self.frames['master_frame']['frame'], bg = self.color_scheme['background'])
        self.frames['master_frame']['children']['analysis_control_panel'] = tkinter.Frame(self.frames['master_frame']['frame'], bg = self.color_scheme['background'])
        self.frames['master_frame']['children']['analysis_selections'] = tkinter.Frame(self.frames['master_frame']['frame'], bg = self.color_scheme['background'])
        #self.frames['master_frame']['children']['results_qi_map'] = tkinter.Frame(self.frames['master_frame']['frame'], bg = self.color_scheme['background'])
        #self.frames['master_frame']['children']['seperator'] = tkinter.Frame(self.frames['master_frame']['frame'], background = self.color_scheme['separator'])
        #self.frames['master_frame']['children']['results_selections'] = tkinter.Frame(self.frames['master_frame']['frame'], bg = self.color_scheme['background'])
        self.frames['master_frame']['children']['results_qi_map'] = tkinter.LabelFrame(self.frames['master_frame']['frame'], text = 'Complete QI Map', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], relief = 'ridge', padx = 10, pady = 5)
        self.frames['master_frame']['children']['results_selections'] = tkinter.LabelFrame(self.frames['master_frame']['frame'], text = 'Individual Selections', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], relief = 'ridge', padx = 10, pady = 5)

        self.header = dict()
        self.header['hertz_model_parameter'] = tkinter.Label(self.frames['master_frame']['frame'], text = "Parameter: Hertz Model", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        #header['segment_parameter'] = tkinter.Label(frames['master_frame']['frame'], text = "Parameter: Individual Segments", relief = 'ridge')
        self.header['export_plot'] = tkinter.Label(self.frames['master_frame']['frame'], text = "Force-Distance Curves: Export/Visualization", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.header['analysis_selections'] = tkinter.Label(self.frames['master_frame']['frame'], text = "Analysis: Individual Selections", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.header['analysis_control_panel'] = tkinter.Label(self.frames['master_frame']['frame'], text = "Analysis: Complete QI Map", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.header['show_results'] = tkinter.Label(self.frames['master_frame']['frame'], text = "Visualize Results", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        #self.header['results_qi_map'] = tkinter.Label(self.frames['master_frame']['frame'], text = "Complete Map", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        #self.header['results_selections'] = tkinter.Label(self.frames['master_frame']['frame'], text = "Individual Selections", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])

        self.header['hertz_model_parameter'].grid(row = 0, column = 0, columnspan = 2, sticky = 'ew')
        self.frames['master_frame']['children']['hertz_model_parameter'].grid(row = 1, column = 0, columnspan = 2, sticky = 'ew', padx = 10, pady = 10)
        #header['segment_parameter'].grid(row = 2, column = 0, sticky = "ew")
        #frames['master_frame']['children']['segment_parameter']['frame'].grid(row = 3, column = 0, sticky = 'ew', padx = 10, pady = 5)
        self.header['export_plot'].grid(row = 4, column = 0, columnspan = 2, sticky = "ew")
        self.frames['master_frame']['children']['export_plot'].grid(row = 5, column = 0, columnspan = 2, sticky = 'ew', padx = 10, pady = 10)
        self.header['analysis_control_panel'].grid(row = 6, column = 0, columnspan = 2, sticky = "ew")
        self.frames['master_frame']['children']['analysis_control_panel'].grid(row = 7, column = 0, columnspan = 2, sticky = 'ew', padx = 10, pady = 10)
        self.header['analysis_selections'].grid(row = 8, column = 0, columnspan = 2, sticky = "ew")
        self.frames['master_frame']['children']['analysis_selections'].grid(row = 9, column = 0, columnspan = 2, sticky = 'ew', padx = 10, pady = 10)
        self.header['show_results'].grid(row = 10, column = 0, columnspan = 2, sticky = "ew")
        #self.header['results_qi_map'].grid(row = 11, column = 0, sticky = "ew")
        #self.header['results_selections'].grid(row = 11, column = 2, sticky = "ew")
        self.frames['master_frame']['children']['results_qi_map'].grid(row = 12, column = 0, sticky = 'nsew', padx = (5,1), pady = 10)
        #self.frames['master_frame']['children']['seperator'].grid(row = 11, column = 1, rowspan = 2, sticky = 'ns', pady = (0,5))
        self.frames['master_frame']['children']['results_selections'].grid(row = 12, column = 1, sticky = 'nsew', padx = (1,5), pady = 10)


        self.frames['master_frame']['children']['analysis_control_panel'].columnconfigure(1,weight = 1)
        self.frames['master_frame']['children']['analysis_selections'].columnconfigure(3,weight = 1)



    def _create_frame_content(self):

        self.hertz_model_parameter = dict()
        self.hertz_model_parameter['label'] = dict()
        self.hertz_model_parameter['label']['indenter_geometry'] = tkinter.Label(self.frames['master_frame']['children']['hertz_model_parameter'], text = "Indenter geometry:\t", bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.hertz_model_parameter['label']['indenter_geometry_characteristics'] = tkinter.Label(self.frames['master_frame']['children']['hertz_model_parameter'], textvariable = self.settings['hertz_fit_parameter']['indenter_geometry_characteristics_label'], bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.hertz_model_parameter['label']['poisson_ratio'] = tkinter.Label(self.frames['master_frame']['children']['hertz_model_parameter'], text = "Poisson ratio:", bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])


        self.hertz_model_parameter['combobox'] = dict()
        self.hertz_model_parameter['combobox']['indenter_geometry'] = MyOwnComboBox(self.frames['master_frame']['children']['hertz_model_parameter'], textvariable = self.settings['hertz_fit_parameter']['indenter_geometry'], values = ['parabolic', 'four-sided pyramid', 'conical'], width = 20, command = self._update_combobox_indenter_geometry, background = self.color_scheme['background_input_dark'], foreground = self.color_scheme['text_standard'], arrow_color = self.color_scheme['text_standard'], bordercolor = self.color_scheme['border'], activebordercolor = self.color_scheme['border_active'], arrow_background = self.color_scheme['background_input_dark'], arrow_activebordercolor = self.color_scheme['border_active'], arrow_activebackground = self.color_scheme['background_light'], selectbackground = self.color_scheme['text_selectbackground'])#background = self.background, foreground = self.foreground)


        self.hertz_model_parameter['entry'] = dict()
        self.hertz_model_parameter['entry']['indenter_geometry'] = tkinter.Entry(self.frames['master_frame']['children']['hertz_model_parameter'], textvariable = self.settings['hertz_fit_parameter']['indenter_geometry_characteristics'], width = 4, justify = 'right', bd = 0, bg = self.color_scheme['background_input_dark'], fg = self.color_scheme['text_standard'], insertbackground = self.color_scheme['text_standard'], highlightthickness = 1, highlightcolor =  self.color_scheme['border_active'], highlightbackground = self.color_scheme['border'], selectbackground = self.color_scheme['text_selectbackground'])
        self.hertz_model_parameter['entry']['poisson_ratio'] = tkinter.Entry(self.frames['master_frame']['children']['hertz_model_parameter'], textvariable = self.settings['hertz_fit_parameter']['poisson_ratio'], width = 4, justify = 'right', bd = 0, bg = self.color_scheme['background_input_dark'], fg = self.color_scheme['text_standard'], insertbackground = self.color_scheme['text_standard'], highlightthickness = 1, highlightcolor = self.color_scheme['border_active'], highlightbackground = self.color_scheme['border'], selectbackground = self.color_scheme['text_selectbackground'])

        self.hertz_model_parameter['spacer'] = dict()
        self.hertz_model_parameter['spacer'][1] = tkinter.Frame(self.frames['master_frame']['children']['hertz_model_parameter'])
        self.hertz_model_parameter['spacer'][1].configure(height = 10, bg = self.color_scheme['background'])

        self.hertz_model_parameter['label']['indenter_geometry'].grid(row = 0, column = 0, sticky = 'w')
        self.hertz_model_parameter['label']['indenter_geometry_characteristics'].grid(row = 1, column = 0, sticky = 'w')
        self.hertz_model_parameter['spacer'][1].grid(row = 2, column = 0, columnspan = 2, sticky = 'ew')
        self.hertz_model_parameter['label']['poisson_ratio'].grid(row = 3, column = 0, sticky = 'w')
        self.hertz_model_parameter['combobox']['indenter_geometry'].grid(row = 0, column = 1)
        self.hertz_model_parameter['entry']['indenter_geometry'].grid(row = 1, column = 1)
        self.hertz_model_parameter['entry']['poisson_ratio'].grid(row = 3, column = 1)

        self.visualization = dict()
        self.visualization['show_preview'] = tkinter.Checkbutton(self.frames['master_frame']['children']['export_plot'], text = 'Show in main window', variable = self.settings['visualization']['show_preview'], onvalue = True, offvalue = False, command = self._toggle_preview, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.visualization['retract_plot'] = tkinter.Checkbutton(self.frames['master_frame']['children']['export_plot'], text = 'Show \"retract\" curve', variable = self.parent.entry_var['fd_curve']['retract_plot'], onvalue = True, offvalue = False, command = self.update_plot, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.visualization['export_plot'] = tkinter.Checkbutton(self.frames['master_frame']['children']['export_plot'], text = 'Export individual figures', variable = self.settings['visualization']['export_result'], onvalue = True, offvalue = False, command = self._toggle_export_result, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.visualization['svg'] = tkinter.Checkbutton(self.frames['master_frame']['children']['export_plot'], text = 'svg', variable = self.settings['visualization']['svg'], onvalue = True, offvalue = False, command = self._update_export_fileformats,bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.visualization['pdf'] = tkinter.Checkbutton(self.frames['master_frame']['children']['export_plot'], text = 'pdf', variable = self.settings['visualization']['pdf'], onvalue = True, offvalue = False, command = self._update_export_fileformats,bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.visualization['png'] = tkinter.Checkbutton(self.frames['master_frame']['children']['export_plot'], text = 'png', variable = self.settings['visualization']['png'], onvalue = True, offvalue = False, command = self._update_export_fileformats,bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.visualization['pkl'] = tkinter.Checkbutton(self.frames['master_frame']['children']['export_plot'], text = 'pkl', variable = self.settings['visualization']['pkl'], onvalue = True, offvalue = False, command = self._update_export_fileformats,bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])

        self.visualization['show_preview'].grid(row = 0, column = 0, sticky = 'w', padx = (0,20))
        self.visualization['retract_plot'].grid(row = 1, column = 0, sticky = 'w', padx = (0,20))
        self.visualization['export_plot'].grid(row = 0, column = 1, columnspan = 4, sticky = 'w')
        self.visualization['svg'].grid(row = 1, column = 1, sticky = 'w', padx = (10,0))
        self.visualization['pdf'].grid(row = 1, column = 2, sticky = 'w')
        self.visualization['png'].grid(row = 1, column = 3, sticky = 'w')
        self.visualization['pkl'].grid(row = 1, column = 4, sticky = 'w')

        self.analysis_control_panel = dict()
        self.analysis_control_panel['button'] = dict()
        self.analysis_control_panel['button']['run'] = tkinter.Button(self.frames['master_frame']['children']['analysis_control_panel'], text = 'Run analysis', command = self.run_fit_multi_layer_segments, state = 'disabled', bg = self.color_scheme['button'], fg = self.color_scheme['text_highlighted'], activebackground = self.color_scheme['button'], activeforeground = self.color_scheme['text_highlighted'], disabledforeground = self.color_scheme['text_disabled'])
        #self.analysis_control_panel['button']['show_results'] = tkinter.Button(self.frames['master_frame']['children']['analysis_control_panel'], text = 'Show results', command = self.show_analysis_results, state = 'disabled', bg = self.color_scheme['button'], fg = self.color_scheme['text_highlighted'], activebackground = self.color_scheme['button'], activeforeground = self.color_scheme['text_highlighted'], disabledforeground = self.color_scheme['text_disabled'])
        self.analysis_control_panel['progress'] = dict()
        self.analysis_control_panel['progress']['bar'] = tkinter.ttk.Progressbar(self.frames['master_frame']['children']['analysis_control_panel'], value = 0, mode = 'determinate')


        self.analysis_control_panel['button']['run'].grid(row = 0, column = 0, padx = (0,10))
        self.analysis_control_panel['progress']['bar'].grid(row = 0, column = 1, sticky = 'ew')
        #self.analysis_control_panel['button']['show_results'].grid(row = 2, column = 0, padx = 10, pady = (5,0))



        self.selection_panel = dict()
        self.selection_panel['listbox'] = tkinter.Listbox(self.frames['master_frame']['children']['analysis_selections'], height = 6, width = 15, selectmode = 'multiple', bg = self.color_scheme['background_input_dark'], fg = self.color_scheme['text_standard'], selectbackground = self.color_scheme['text_selectbackground'], activestyle = 'none', bd = 0, highlightthickness = 1, highlightcolor =  self.color_scheme['border_active'], highlightbackground = self.color_scheme['border'], relief = 'flat')
        for v in self.parent.qi_object.selections.keys():
            self.selection_panel['listbox'].insert('end', v)
        self.selection_panel['listbox_scrollbar'] = tkinter.Scrollbar(self.frames['master_frame']['children']['analysis_selections'])
        self.selection_panel['listbox'].config(yscrollcommand=self.selection_panel['listbox_scrollbar'].set)
        self.selection_panel['listbox_scrollbar'].config(command=self.selection_panel['listbox'].yview)
        self.selection_panel['run_analysis_selection'] = tkinter.Button(self.frames['master_frame']['children']['analysis_selections'], text = 'Run analysis', command = self.run_fit_multi_layer_segments_selection, state = 'disabled', bg = self.color_scheme['button'], fg = self.color_scheme['text_highlighted'], activebackground = self.color_scheme['button'], activeforeground = self.color_scheme['text_highlighted'], disabledforeground = self.color_scheme['text_disabled'])
        self.selection_panel['progress_information'] = tkinter.Label(self.frames['master_frame']['children']['analysis_selections'], width = 25, anchor = 'w', textvariable = self.progress_info, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.selection_panel['progress'] = tkinter.ttk.Progressbar(self.frames['master_frame']['children']['analysis_selections'], value = 0, mode = 'determinate')


        self.selection_panel['listbox'].grid(row = 0, column = 0, rowspan = 4, sticky = 'w')
        self.selection_panel['listbox_scrollbar'].grid(row = 0, column = 1, rowspan = 4, sticky = 'nsw')
        self.selection_panel['run_analysis_selection'].grid(row = 0, column = 2, sticky = 'w', padx = (10,10))

        self.selection_panel['progress'].grid(row = 0, column = 3, sticky = 'we')
        self.selection_panel['progress_information'].grid(row = 1, column = 2, columnspan = 2, sticky = 'nw', padx = (10,0), pady = (5,5))

        if self.control_parameter['apply_corrections'].get():
            self.analysis_control_panel['button']['run'].configure(state = 'normal')
            self.selection_panel['run_analysis_selection'].configure(state = 'normal')


        self.results_panel = dict()
        self.results_panel['full_map'] = dict()
        #self.results_panel['full_map']['header'] = tkinter.Label(self.frames['master_frame']['children']['results_qi_map'], text = 'Results: QI map', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.results_panel['full_map']['show_results'] = tkinter.Button(self.frames['master_frame']['children']['results_qi_map'], text = 'Show results', command = self.show_analysis_results_full_map, state = 'disabled', bg = self.color_scheme['button'], fg = self.color_scheme['text_highlighted'], activebackground = self.color_scheme['button'], activeforeground = self.color_scheme['text_highlighted'], disabledforeground = self.color_scheme['text_disabled'])
        self.results_panel['full_map']['qi_map'] = tkinter.Checkbutton(self.frames['master_frame']['children']['results_qi_map'], text = 'QI Map', variable = self.results_show['full_map']['qi_map'], onvalue = True, offvalue = False, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.results_panel['full_map']['boxplot'] = tkinter.Checkbutton(self.frames['master_frame']['children']['results_qi_map'], text = 'Boxplot', variable = self.results_show['full_map']['boxplot'], onvalue = True, offvalue = False, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.results_panel['full_map']['histogram'] = tkinter.Checkbutton(self.frames['master_frame']['children']['results_qi_map'], text = 'Histogram', variable = self.results_show['full_map']['histogram'], onvalue = True, offvalue = False, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.results_panel['full_map']['spacer'] = tkinter.Label(self.frames['master_frame']['children']['results_qi_map'], text = '', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])

        self.results_panel['selections'] = dict()
        self.results_panel['selections']['show_results'] = tkinter.Button(self.frames['master_frame']['children']['results_selections'], text = 'Show results', command = self.show_analysis_results_selections, state = 'disabled', bg = self.color_scheme['button'], fg = self.color_scheme['text_highlighted'], activebackground = self.color_scheme['button'], activeforeground = self.color_scheme['text_highlighted'], disabledforeground = self.color_scheme['text_disabled'])
        self.results_panel['selections']['data_origin'] = tkinter.Checkbutton(self.frames['master_frame']['children']['results_selections'], text = 'Use full map data ', variable = self.results_show['selections']['data_origin'], onvalue = True, offvalue = False, state = 'disabled', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.results_panel['selections']['boxplot'] = tkinter.Checkbutton(self.frames['master_frame']['children']['results_selections'], text = 'Boxplot', variable = self.results_show['selections']['boxplot'], onvalue = True, offvalue = False, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.results_panel['selections']['histogram'] = tkinter.Checkbutton(self.frames['master_frame']['children']['results_selections'], text = 'Histogram', variable = self.results_show['selections']['histogram'], onvalue = True, offvalue = False, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.results_panel['selections']['layer_label'] = tkinter.Label(self.frames['master_frame']['children']['results_selections'], text = 'Show data from: ', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.results_panel['selections']['layer_selection'] = MyOwnComboBox(self.frames['master_frame']['children']['results_selections'], textvariable = self.results_show['selections']['layer_string'], values = ['Layer 1', 'Layer 2', 'Layer 3'], width = 8, command = self._set_layer_selection_show, background = self.color_scheme['background_input_dark'], foreground = self.color_scheme['text_standard'], arrow_color = self.color_scheme['text_standard'], bordercolor = self.color_scheme['border'], activebordercolor = self.color_scheme['border_active'], arrow_background = self.color_scheme['background_input_dark'], arrow_activebordercolor = self.color_scheme['border_active'], arrow_activebackground = self.color_scheme['background_light'], selectbackground = self.color_scheme['text_selectbackground'])
        #self.results_panel['selections']['layer1'] = tkinter.Radiobutton(self.frames['master_frame']['children']['results_selections'], text = 'Layer 1', variable = self.results_show['selections']['layer'], value = 1, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])

        self.results_panel['full_map']['qi_map'].grid(row = 0, column = 0, sticky = 'w')
        self.results_panel['full_map']['boxplot'].grid(row = 1, column = 0, sticky = 'w')
        self.results_panel['full_map']['histogram'].grid(row = 2, column = 0, sticky = 'w')
        self.results_panel['full_map']['spacer'].grid(row = 3, column = 0, sticky = 'w', pady = (10,10))
        self.results_panel['full_map']['show_results'].grid(row = 4, column = 0, sticky = 'w', pady = (5))


        self.results_panel['selections']['boxplot'].grid(row = 0, column = 0, sticky = 'w')
        self.results_panel['selections']['histogram'].grid(row = 1, column = 0, sticky = 'w')
        self.results_panel['selections']['layer_label'].grid(row = 2, column = 0, sticky = 'w', pady = (10,0))
        self.results_panel['selections']['layer_selection'].grid(row = 2, column = 1, pady = (10,0))

        self.results_panel['selections']['data_origin'].grid(row = 3, column = 0, columnspan = 2, sticky = 'w', pady = (0,10))
        self.results_panel['selections']['show_results'].grid(row = 4, column = 0, sticky = 'w', pady = (5,0))


        if len(self.parent.qi_object.multi_layer_hertz['full_map']):
            self.results_panel['full_map']['show_results'].configure(state = 'normal')
            self.results_panel['selections']['show_results'].configure(state = 'normal')
            self.results_panel['selections']['data_origin'].configure(state = 'normal')
        else:
            #self.results_panel['full_map']['show_results'].configure(state = 'disabled')
            if len(self.parent.qi_object.multi_layer_hertz['selections']):
                self.results_panel['selections']['show_results'].configure(state = 'normal')


        self.fit_settings = dict()
        self.fit_settings['info'] = dict()
        self.fit_settings['info']['master_frame'] = tkinter.Frame(self.frames['master_frame']['info'], background = self.color_scheme['background'])
        self.fit_settings['info']['header'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = "==== Analysis Parameter ====", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['info']['indenter_geometry_label'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = 'Indenter geometry: ', width = 18, anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['info']['indenter_geometry_details'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = 'parabolic', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])
        self.fit_settings['info']['indenter_characteristics_label'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = 'Radius [nm]: ', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['info']['indenter_characteristics_details'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = '10', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])
        self.fit_settings['info']['poisson_ratio_label'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = 'Poisson ratio: ', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['info']['poisson_ratio_details'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = '0.5', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])

        self.fit_settings['info']['master_frame'].grid(row = 1, column = 0, pady = (50,0), sticky = 'ew')
        self.fit_settings['info']['master_frame'].columnconfigure(1, weight = 1)
        self.fit_settings['info']['header'].grid(row = 0, column = 0, columnspan = 2, sticky = 'ew')
        self.fit_settings['info']['indenter_geometry_label'].grid(row = 1, column = 0, sticky = 'w', pady = (10,0), padx = (10,0))
        self.fit_settings['info']['indenter_geometry_details'].grid(row = 1, column = 1, sticky = 'w', pady = (10,0), padx = (0,10))
        self.fit_settings['info']['indenter_characteristics_label'].grid(row = 2, column = 0, sticky = 'w', pady = (0,0), padx = (10,0))
        self.fit_settings['info']['indenter_characteristics_details'].grid(row = 2, column = 1, sticky = 'w', pady = (0,0), padx = (0,10))
        self.fit_settings['info']['poisson_ratio_label'].grid(row = 3, column = 0, sticky = 'w', pady = (0,10), padx = (10,0))
        self.fit_settings['info']['poisson_ratio_details'].grid(row = 3, column = 1, sticky = 'w', pady = (0,10), padx = (0,10))




    def _update_progress(self):

        if self.thread_analysis.is_alive():
            self.analysis_control_panel['progress']['bar']['value'] = self.parent.qi_object.counter['count']
            self.parent.after(50, self._update_progress)
        else:
            self.analysis_control_panel['progress']['bar']['value'] = self.parent.qi_object.counter['count']
            self.selection_panel['run_analysis_selection'].configure(state = 'normal')
            self.analysis_control_panel['button']['run'].configure(state = 'normal')
            self.results_panel['full_map']['show_results'].configure(state = 'normal')
            self.results_panel['selections']['show_results'].configure(state = 'normal')
            self.results_panel['selections']['data_origin'].configure(state = 'normal')
            self.results_show['selections']['data_origin'].set(True)

            self.parent.safe_closing = True
            self.safe_closing = True




    def _update_progress_selection(self):

        if self.thread_analysis.is_alive():
            self.progress_info.set('Progressing selection: ' + self.parent.qi_object.counter['select'])
            self.selection_panel['progress']['maximum'] = self.parent.qi_object.counter['max']
            self.selection_panel['progress']['value'] = self.parent.qi_object.counter['count']
            self.parent.after(50, self._update_progress_selection)
        else:
            self.analysis_control_panel['progress']['bar']['value'] = self.parent.qi_object.counter['count']
            self.progress_info.set('')
            self.selection_panel['run_analysis_selection'].configure(state = 'normal')
            self.analysis_control_panel['button']['run'].configure(state = 'normal')
            self.results_panel['selections']['show_results'].configure(state = 'normal')

            self.parent.safe_closing = True
            self.safe_closing = True



    def show_analysis_results_full_map(self):


        if self.results_show['full_map']['qi_map'].get():

            x_width = np.round(self.parent.qi_object.settings['grid']['u-length']*10**6,2)
            y_width = np.round(self.parent.qi_object.settings['grid']['u-length']*10**6,2)

            fig_map_layer_1 = plt.figure()
            ax_map_layer_1 = fig_map_layer_1.add_subplot(111)
            c_map_layer_1 = ax_map_layer_1.imshow(self.parent.qi_object.data['linearized_hertz_fit_multi_layer']['value'][1], extent = [0, x_width, 0, y_width], origin = 'lower', cmap = 'gnuplot', norm=matplotlib.colors.LogNorm(vmin = 300, vmax = 30000000))
            cbar_map_layer_1 = fig_map_layer_1.colorbar(c_map_layer_1, ax=ax_map_layer_1)
            cbar_map_layer_1.set_label('Apparent Young\'s modulus / Pa', rotation = 270, labelpad = 20)
            ax_map_layer_1.set_xlabel('Position / \u03BCm')
            ax_map_layer_1.set_ylabel('Position / \u03BCm')
            ax_map_layer_1.set_title('Three Layer Linearized Hertz Algorithm - Layer 1')

            fig_map_layer_2 = plt.figure()
            ax_map_layer_2 = fig_map_layer_2.add_subplot(111)
            c_map_layer_2 = ax_map_layer_2.imshow(self.parent.qi_object.data['linearized_hertz_fit_multi_layer']['value'][2], extent = [0, x_width, 0, y_width], origin = 'lower', cmap = 'gnuplot', norm=matplotlib.colors.LogNorm(vmin = 300, vmax = 30000000))
            cbar_map_layer_2 = fig_map_layer_2.colorbar(c_map_layer_2, ax=ax_map_layer_2)
            cbar_map_layer_2.set_label('Apparent Young\'s modulus / Pa', rotation = 270, labelpad = 20)
            ax_map_layer_2.set_xlabel('Position / \u03BCm')
            ax_map_layer_2.set_ylabel('Position / \u03BCm')
            ax_map_layer_2.set_title('Three Layer Linearized Hertz Algorithm - Layer 2')

            fig_map_layer_3 = plt.figure()
            ax_map_layer_3 = fig_map_layer_3.add_subplot(111)
            c_map_layer_3 = ax_map_layer_3.imshow(self.parent.qi_object.data['linearized_hertz_fit_multi_layer']['value'][3], extent = [0, x_width, 0, y_width], origin = 'lower', cmap = 'gnuplot', norm=matplotlib.colors.LogNorm(vmin = 300, vmax = 30000000))
            cbar_map_layer_3 = fig_map_layer_3.colorbar(c_map_layer_3, ax=ax_map_layer_3)
            cbar_map_layer_3.set_label('Apparent Young\'s modulus / Pa', rotation = 270, labelpad = 20)
            ax_map_layer_3.set_xlabel('Position / \u03BCm')
            ax_map_layer_3.set_ylabel('Position / \u03BCm')
            ax_map_layer_3.set_title('Three Layer Linearized Hertz Algorithm - Layer 3')

        if self.results_show['full_map']['histogram'].get():

            data_1 = np.reshape(self.parent.qi_object.data['linearized_hertz_fit_multi_layer']['value'][1], -1)
            data_1 = data_1[~np.isnan(data_1)]
            data_2 = np.reshape(self.parent.qi_object.data['linearized_hertz_fit_multi_layer']['value'][2], -1)
            data_2 = data_2[~np.isnan(data_2)]
            data_3 = np.reshape(self.parent.qi_object.data['linearized_hertz_fit_multi_layer']['value'][3], -1)
            data_3 = data_3[~np.isnan(data_3)]


            fig_hist_layer_1 = plt.figure()
            ax_hist_layer_1 = fig_hist_layer_1.add_subplot(111)
            ax_hist_layer_1.hist(data_1/1000, bins = 'auto', range = (-.5, 10.5))
            ax_hist_layer_1.set_xlabel('Young\'s modulus / kPa')
            ax_hist_layer_1.set_ylabel('Occurrence')
            ax_hist_layer_1.set_title('Three Layer Linearized Hertz Algorithm - Layer 1')
            ax_hist_layer_1.set_xlim([-.5, 10.5])
            ax_hist_layer_1.tick_params(direction = 'in', top = True, right = True)

            fig_hist_layer_2 = plt.figure()
            ax_hist_layer_2 = fig_hist_layer_2.add_subplot(111)
            ax_hist_layer_2.hist(data_2/1000, bins = 'auto', range = (-5, 105))
            ax_hist_layer_2.set_xlabel('Young\'s modulus / kPa')
            ax_hist_layer_2.set_ylabel('Occurrence')
            ax_hist_layer_2.set_title('Three Layer Linearized Hertz Algorithm - Layer 2')
            ax_hist_layer_2.set_xlim([-5, 105])
            ax_hist_layer_2.tick_params(direction = 'in', top = True, right = True)

            fig_hist_layer_3 = plt.figure()
            ax_hist_layer_3 = fig_hist_layer_3.add_subplot(111)
            ax_hist_layer_3.hist(data_3/1e6, bins = 'auto', range = (-.5, 12.5))
            ax_hist_layer_3.set_xlabel('Young\'s modulus / kPa')
            ax_hist_layer_3.set_ylabel('Occurrence')
            ax_hist_layer_3.set_title('Three Layer Linearized Hertz Algorithm - Layer 3')
            ax_hist_layer_3.set_xlim([-.5, 12.5])
            ax_hist_layer_3.tick_params(direction = 'in', top = True, right = True)

        if self.results_show['full_map']['boxplot'].get():

            data_1 = np.reshape(self.parent.qi_object.data['linearized_hertz_fit_multi_layer']['value'][1], -1)
            data_1 = data_1[~np.isnan(data_1)]
            data_2 = np.reshape(self.parent.qi_object.data['linearized_hertz_fit_multi_layer']['value'][2], -1)
            data_2 = data_2[~np.isnan(data_2)]
            data_3 = np.reshape(self.parent.qi_object.data['linearized_hertz_fit_multi_layer']['value'][3], -1)
            data_3 = data_3[~np.isnan(data_3)]

            fig_box_layer_1 = plt.figure()
            ax_box_layer_1 = fig_box_layer_1.add_subplot(111)
            ax_box_layer_1.boxplot(data_1/1000, flierprops = {'marker': 'x'})
            ax_box_layer_1.set_xlabel('Layer 1')
            ax_box_layer_1.set_ylabel('Young\'s modulus / kPa')
            ax_box_layer_1.set_title('Three Layer Linearized Hertz Algorithm - Layer 1')
            ax_box_layer_1.set_xlim([-.5, 10.5])
            ax_box_layer_1.tick_params(direction = 'in', top = True, right = True)

            fig_box_layer_2 = plt.figure()
            ax_box_layer_2 = fig_box_layer_2.add_subplot(111)
            ax_box_layer_2.boxplot(data_2/1000, flierprops = {'marker': 'x'})
            ax_box_layer_2.set_xlabel('Layer 2')
            ax_box_layer_2.set_ylabel('Young\'s modulus / kPa')
            ax_box_layer_2.set_title('Three Layer Linearized Hertz Algorithm - Layer 2')
            ax_box_layer_2.set_xlim([-5, 105])
            ax_box_layer_2.tick_params(direction = 'in', top = True, right = True)

            fig_box_layer_3 = plt.figure()
            ax_box_layer_3 = fig_box_layer_3.add_subplot(111)
            ax_box_layer_3.boxplot(data_3/1e6, flierprops = {'marker': 'x'})
            ax_box_layer_3.set_xlabel('Layer 3')
            ax_box_layer_3.set_ylabel('Young\'s modulus / kPa')
            ax_box_layer_3.set_title('Three Layer Linearized Hertz Algorithm - Layer 3')
            ax_box_layer_3.set_xlim([-.5, 12.5])
            ax_box_layer_3.tick_params(direction = 'in', top = True, right = True)







    def show_analysis_results_selections(self):

        selections = [list(self.parent.qi_object.selections.keys())[i] for i in self.selection_panel['listbox'].curselection()]
        seg = self.results_show['selections']['layer'].get()
        data = dict()
        plot = False

        if not len(selections):

            self.enter_window_app.bell()
            print('No selections chosen!')
            plot = False

        elif self.results_show['selections']['data_origin'].get() and 'linearized_hertz_fit_multi_layer' in self.parent.qi_object.data.keys(): # data pulled from whole map

            for select in selections:

                data[select] = self.parent.qi_object.get_data(['linearized_hertz_fit_multi_layer', 'value', seg], selection = select)
                data[select] = data[select][~np.isnan(data[select])]

            plot = True

        elif not self.results_show['selections']['data_origin'].get():

            plot = True
            for select in selections:

                if select in self.parent.qi_object.multi_layer_hertz['selections'].keys():

                    data[select] = list()
                    for ind in self.parent.qi_object.multi_layer_hertz['selections'][select]['indices'].keys():

                        data[select] = np.append(data[select], self.parent.qi_object.multi_layer_hertz['selections'][select]['indices'][ind]['young_modulus'][seg])

                    data[select] = data[select][~np.isnan(data[select])]

                else:

                    self.enter_window_app.bell()
                    print('Analyze the requested data first:', select)
                    plot = False

        else:

            self.enter_window_app.bell()
            print('Analyze the full map first!')
            plot = False



        if plot:

            if self.results_show['selections']['layer'].get() == 1:

                x_label = 'Young\'s modulus / kPa'
                y_lim = [-0.5, 10.5]
                fac = 1e3


            elif self.results_show['selections']['layer'].get() == 2:

                x_label = 'Young\'s modulus / kPa'
                y_lim = [-5, 105]
                fac = 1e3

            elif self.results_show['selections']['layer'].get() == 3:

                x_label = 'Young\'s modulus / MPa'
                y_lim = [-0.5, 12.5]
                fac = 1e6


            if self.results_show['selections']['boxplot'].get():

                fig_box_selection = plt.figure()
                ax_box_selection = fig_box_selection.add_subplot(111)
                ax_box_selection.boxplot([data[select]/fac for select in selections], labels = selections, flierprops = {'marker': 'x'})
                ax_box_selection.set_xlabel('Selection')
                ax_box_selection.set_ylabel(x_label)
                ax_box_selection.set_title('Boxplot - Selections: Three Layer Linearized Hertz Algorithm - Layer ' + str(self.results_show['selections']['layer'].get()))
                ax_box_selection.set_ylim(y_lim)
                ax_box_selection.tick_params(direction = 'in', top = True, right = True)


            if self.results_show['selections']['histogram'].get():

                fig_hist_selection = plt.figure()
                ax_hist_selection = fig_hist_selection.add_subplot(111)
                ax_hist_selection.hist([data[select]/fac for select in selections], bins = 'auto', density = True, label = selections)
                ax_hist_selection.legend()
                ax_hist_selection.set_xlabel(x_label)
                ax_hist_selection.set_ylabel('Occurrence')
                ax_hist_selection.set_title('Histogram - Selections: Three Layer Linearized Hertz Algorithm - Layer ' + str(self.results_show['selections']['layer'].get()))
                ax_hist_selection.set_xlim(y_lim)
                ax_hist_selection.tick_params(direction = 'in', top = True, right = True)














    def _update_combobox_indenter_geometry(self, event = None):

        choice = self.settings['hertz_fit_parameter']['indenter_geometry'].get()

        if choice == 'parabolic':

            self.settings['hertz_fit_parameter']['indenter_geometry_characteristics_label'].set('Radius [nm]:')
            self.settings['hertz_fit_parameter']['indenter_geometry_characteristics'].set(10)
            self.indenter_characteristics = {'geometry': 'parabolic', 'radius [nm]': 10}
            self.fit_settings['info']['indenter_geometry_details'].configure(text = 'parabolic')
            self.fit_settings['info']['indenter_characteristics_label'].configure(text = 'Radius [nm]')
            self.fit_settings['info']['indenter_characteristics_details'].configure(text = '10')

        elif choice == 'four-sided pyramid':

            self.settings['hertz_fit_parameter']['indenter_geometry_characteristics_label'].set('Face angle [grad]:')
            self.settings['hertz_fit_parameter']['indenter_geometry_characteristics'].set(35)
            self.indenter_characteristics = {'geometry': 'four-sided pyramid', 'angle [grad]': 35}
            self.fit_settings['info']['indenter_geometry_details'].configure(text = 'f-s pyramid')
            self.fit_settings['info']['indenter_characteristics_label'].configure(text = 'Face angle [grad]:')
            self.fit_settings['info']['indenter_characteristics_details'].configure(text = '35')

        elif choice == 'conical':

            self.settings['hertz_fit_parameter']['indenter_geometry_characteristics_label'].set('Half cone angle [grad]:')
            self.settings['hertz_fit_parameter']['indenter_geometry_characteristics'].set(15)
            self.indenter_characteristics = {'geometry': 'conical', 'angle [grad]': 15}
            self.fit_settings['info']['indenter_geometry_details'].configure(text = 'conical')
            self.fit_settings['info']['indenter_characteristics_label'].configure(text = 'Half cone angle [grad]:')
            self.fit_settings['info']['indenter_characteristics_details'].configure(text = '15')

        self.update_plot()




    def _enter_poisson_ratio(self, event = None):

        try:

            conv = float(self.settings['hertz_fit_parameter']['poisson_ratio'].get())

            if conv:

                self.poisson_ratio = conv
                self.fit_settings['info']['poisson_ratio_details'].configure(text = str(conv))
                self.update_plot()

            else:

                self.enter_window_app.bell()

        except:

            self.enter_window_app.bell()




    def _enter_indenter_characteristics(self, event = None):

        try:

            conv = float(self.settings['hertz_fit_parameter']['indenter_geometry_characteristics'].get())


            if conv > 0:

                choice = self.settings['hertz_fit_parameter']['indenter_geometry'].get()

                if choice == 'parabolic':

                    self.indenter_characteristics = {'geometry': 'parabolic', 'radius [nm]': conv}

                elif choice == 'four-sided pyramid':

                    self.indenter_characteristics = {'geometry': 'four-sided pyramid', 'angle [grad]': conv}

                else:

                    self.indenter_characteristics = {'geometry': 'conical', 'angle [grad]': conv}

                self.fit_settings['info']['indenter_characteristics_details'].configure(text = str(conv))
                self.update_plot()


            else:

                self.enter_window_app.bell()

        except:


            self.enter_window_app.bell()




    def _set_layer_selection_show(self, event = None):

        if self.results_show['selections']['layer_string'].get() == 'Layer 1':
            self.results_show['selections']['layer'].set(1)
        elif self.results_show['selections']['layer_string'].get() == 'Layer 2':
            self.results_show['selections']['layer'].set(2)
        elif self.results_show['selections']['layer_string'].get() == 'Layer 3':
            self.results_show['selections']['layer'].set(3)




    # def _activate_plot_result(self):
    #
    #     if self.settings['visualization']['plot_result'].get():
    #
    #         self.settings['visualization']['plot_result'].set(False)
    #
    #         self.enter_window_app.bell()
    #         proceed = tkinter.messagebox.askyesno(parent = self.enter_window_app, title='I warned you!', message = 'Only affects analysis of selections.\nActivating opens an individual figure for each force-distance curve during analysis. This option is not recommended when analyzing more than a handfull of force-distance curves (for example, in case of a small selections).\nYour computer may freeze/crash!\nActivate display of individual figures for each force-distance curves?')
    #
    #         if proceed:
    #             self.settings['visualization']['plot_result'].set(True)
    #         else:
    #             self.settings['visualization']['plot_result'].set(False)





    def _toggle_preview(self):

        #print(self.settings['visualization']['show_preview'].get())
        if self.settings['visualization']['show_preview'].get():

            self.parent.standard_hertz_window.settings['visualization']['show_preview'].set(False)
            self.parent.breakthrough_events_window.settings['visualization']['show_preview'].set(False)


        self.update_plot()
            #print('switch all other previews off')

        #self.settings['visualization']['show_preview'].set(True)
        #breakthrough events --> false




    def _toggle_export_result(self):

        if self.settings['visualization']['export_result'].get():

            self.settings['visualization']['svg'].set(True)
            self.settings['visualization']['pdf'].set(True)
            self.settings['visualization']['png'].set(True)
            self.settings['visualization']['pkl'].set(True)

        else:

            self.settings['visualization']['svg'].set(False)
            self.settings['visualization']['pdf'].set(False)
            self.settings['visualization']['png'].set(False)
            self.settings['visualization']['pkl'].set(False)

        self._update_export_fileformats()




    def _update_export_fileformats(self):

        if self.settings['visualization']['svg'].get():

            if 'svg' not in self.settings['export_fileformats']:
                self.settings['export_fileformats'].append('svg')
        else:
            if 'svg' in self.settings['export_fileformats']:
                self.settings['export_fileformats'].remove('svg')

        if self.settings['visualization']['pdf'].get():
            if 'pdf' not in self.settings['export_fileformats']:
                self.settings['export_fileformats'].append('pdf')
        else:
            if 'pdf' in self.settings['export_fileformats']:
                self.settings['export_fileformats'].remove('pdf')

        if self.settings['visualization']['png'].get():
            if 'png' not in self.settings['export_fileformats']:
                self.settings['export_fileformats'].append('png')
        else:
            if 'png' in self.settings['export_fileformats']:
                self.settings['export_fileformats'].remove('png')

        if self.settings['visualization']['pkl'].get():
            if 'pkl' not in self.settings['export_fileformats']:
                self.settings['export_fileformats'].append('pkl')
        else:
            if 'pkl' in self.settings['export_fileformats']:
                self.settings['export_fileformats'].remove('pkl')

        #print(self.settings['export_fileformats'])








class ApparentLayerThicknessWindow():

    def __init__(self,QI_FD_Preview_object):

        self.parent = QI_FD_Preview_object
        self.safe_closing = True
        self.enter_window_app = None
        self.update_plot = QI_FD_Preview_object.update_plot
        self.control_parameter = QI_FD_Preview_object.control_parameter


        #self.progress = tkinter.StringVar(None)
        self.thread_analysis = None

        self.frames = None
        self.header = None
        #self.hertz_model_parameter = None
        self.analysis_control_panel = None

        self.color_scheme = _Helper_Functions_GUI._set_color_options()






    def on_closing(self):

        if self.safe_closing:

            self.enter_window_app.destroy()
            self.control_parameter['apparent_layer_thickness_window'] = False
            self.enter_window_app = None
            self.frames = None
            self.header = None
            self.analysis_control_panel = None

        else:

            self.enter_window_app.bell()
            tkinter.messagebox.showinfo(parent = self.enter_window_app, title = 'Why so impatient! Let me finish first!', message = 'Cannot close Window. Analysis is still running!')

    #def on_opening(self):



    def _on_open_new_qi_map(self):

        if self.control_parameter['apparent_layer_thickness_window']:

            self.analysis_control_panel['button']['run'].configure(state = 'disabled')
            #self.results_panel['full_map']['show_results'].configure(state = 'disabled')




    def _on_loading_qi_snapshot(self):

        if self.control_parameter['apparent_layer_thickness_window']:

            if self.parent.qi_object.control_variables['allow_analysis']:
                self.analysis_control_panel['button']['run'].configure(state = 'normal')
            else:
            #self.results_panel['full_map']['show_results'].configure(state = 'disabled')
                self.analysis_control_panel['button']['run'].configure(state = 'disabled')






    def setup_apparent_layer_thickness(self):

        #self.on_opening()

        if isinstance(self.enter_window_app, tkinter.Toplevel):

            self.enter_window_app.lift()
            self.enter_window_app.focus_set()

        else:

            self.enter_window_app = tkinter.Toplevel() #use tkinter.Tk() only once in an application
            self.enter_window_app.title('Apparent Layer Thickness')
            self.enter_window_app.resizable(False, False)
            self.enter_window_app.focus_set()

            self.control_parameter['apparent_layer_thickness_window'] = True


            self.frames = dict()
            self.frames['master_frame'] = dict()
            self.frames['master_frame']['frame'] = tkinter.Frame(self.enter_window_app)
            self.frames['master_frame']['separator'] = tkinter.Frame(self.enter_window_app, width = 1, bg = self.color_scheme['separator'])
            #frames['master_frame']['frame'].configure(width = 200, height = 300, background = '#170b28')
            self.frames['master_frame']['frame'].configure(background = self.color_scheme['background'])#, relief = 'sunken', borderwidth = 1)
            self.frames['master_frame']['frame'].grid(row = 0, column = 0, sticky = 'nsw')
            self.frames['master_frame']['separator'].grid(row = 0, column = 1, sticky = 'ns')
            #frames['master_frame']['frame'].grid_propagate(False)
            self.frames['correction_info_frame'] = dict()
            self.frames['correction_info_frame']['frame'] = CorrectionInfoFrame(self.enter_window_app, correction_window_ref = self.parent.corrections_window.confirmed_corrections, background = self.color_scheme['background'], textcolor = self.color_scheme['text_standard'], highlighttextcolor = self.color_scheme['text_highlighted'])#, relief = 'sunken', borderwidth = 1)
            self.frames['correction_info_frame']['frame'].grid(row = 0, column = 2, sticky = 'nse')

            self.frames['master_frame']['children'] = dict()
            self.frames['master_frame']['children']['layer_thickness_parameter'] = {'frame':tkinter.Frame(self.frames['master_frame']['frame'], bg = self.color_scheme['background'])}
            #self.frames['master_frame']['children']['export_plot'] = {'frame':tkinter.Frame(self.frames['master_frame']['frame'], bg = self.color_scheme['background'])}
            self.frames['master_frame']['children']['selections'] = {'frame':tkinter.Frame(self.frames['master_frame']['frame'], bg = self.color_scheme['background'])}
            self.frames['master_frame']['children']['analysis_control_panel'] = {'frame':tkinter.Frame(self.frames['master_frame']['frame'], bg = self.color_scheme['background'])}

            self.header = dict()
            self.header['layer_thickness_parameter'] = tkinter.Label(self.frames['master_frame']['frame'], text = "Parameter: Layer Thickness", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
            #self.header['export_plot'] = tkinter.Label(self.frames['master_frame']['frame'], text = "Force-Distance Curves: Export/Visualization", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
            self.header['selections'] = tkinter.Label(self.frames['master_frame']['frame'], text = "Selection Tool", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
            self.header['analysis_control_panel'] = tkinter.Label(self.frames['master_frame']['frame'], text = "Analysis Control Panel", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])

            self.header['layer_thickness_parameter'].grid(row = 0, column = 0, sticky = 'ew')
            self.frames['master_frame']['children']['layer_thickness_parameter']['frame'].grid(row = 1, column = 0, sticky = 'ew', padx = 10, pady = 5)
            #self.header['export_plot'].grid(row = 4, column = 0, sticky = "ew")
            #self.frames['master_frame']['children']['export_plot']['frame'].grid(row = 5, column = 0, sticky = 'ew', padx = 10, pady = 5)
            self.header['selections'].grid(row = 6, column = 0, sticky = "ew")
            self.frames['master_frame']['children']['selections']['frame'].grid(row = 7, column = 0, sticky = 'ew', padx = 10, pady = 5)
            self.header['analysis_control_panel'].grid(row = 8, column = 0, sticky = "ew")
            self.frames['master_frame']['children']['analysis_control_panel']['frame'].grid(row = 9, column = 0, sticky = 'ew', padx = 10, pady = 5)


            self.analysis_control_panel = dict()
            self.analysis_control_panel['button'] = dict()
            self.analysis_control_panel['button']['run'] = tkinter.Button(self.frames['master_frame']['children']['analysis_control_panel']['frame'], text = 'Run analysis', command = self.run_get_apparent_layer_thickness, state = 'disabled', bg = self.color_scheme['button'], fg = self.color_scheme['text_highlighted'], activebackground = self.color_scheme['button'], activeforeground = self.color_scheme['text_highlighted'], disabledforeground = self.color_scheme['text_disabled'])
            self.analysis_control_panel['progress'] = dict()
            self.analysis_control_panel['progress']['bar'] = tkinter.ttk.Progressbar(self.frames['master_frame']['children']['analysis_control_panel']['frame'], value = 0, mode = 'determinate', length = 200)


            self.analysis_control_panel['button']['run'].grid(row = 0, column = 0)
            self.analysis_control_panel['progress']['bar'].grid(row = 2, column = 0, pady = 5)


            if self.control_parameter['apply_corrections'].get():

                self.analysis_control_panel['button']['run'].configure(state = 'normal')
                #self.selection_panel['run_analysis_selection'].configure(state = 'normal')



            self._toggle_preview()

            self.enter_window_app.protocol("WM_DELETE_WINDOW", self.on_closing)




    def run_get_apparent_layer_thickness(self):

        self.parent.safe_closing = False
        self.safe_closing = False

        #self.thread_analysis = threading.Thread(target = self.parent.qi_object.get_topography)
        self.thread_analysis = threading.Thread(target = self.parent.qi_object.get_apparent_layer_thickness)
        print('====================')
        self.thread_analysis.start()
        self.analysis_control_panel['progress']['bar']['maximum'] = self.parent.qi_object.counter['max']
        self.parent.after(50, self._update_progress)




    def _update_progress(self):

        if self.thread_analysis.is_alive():

            self.analysis_control_panel['progress']['bar']['value'] = self.parent.qi_object.counter['count']
            self.parent.after(50, self._update_progress)

        else:

            self.parent.safe_closing = True
            self.safe_closing = True




    def _toggle_preview(self):

        self.parent.standard_hertz_window.settings['visualization']['show_preview'].set(False)
        self.parent.multi_layer_segments_window.settings['visualization']['show_preview'].set(False)
        self.parent.breakthrough_events_window.settings['visualization']['show_preview'].set(False)







class BreakthroughEventsWindow():

    def __init__(self,QI_FD_Preview_object):

        self.parent = QI_FD_Preview_object
        self.safe_closing = True
        self.enter_window_app = None
        self.update_plot = QI_FD_Preview_object.update_plot
        self.control_parameter = QI_FD_Preview_object.control_parameter

        self.settings = dict()
        self.settings['parameter'] = {'sensitivity': tkinter.StringVar(None,'1'), 'event_sep': tkinter.StringVar(None,'1')}
        self.settings['visualization'] = {'show_preview': tkinter.BooleanVar(None,False), 'retract_plot': tkinter.BooleanVar(None,False), 'export_result': tkinter.BooleanVar(None,False), 'svg':tkinter.BooleanVar(None,False), 'pdf': tkinter.BooleanVar(None,False), 'png': tkinter.BooleanVar(None,False), 'pkl': tkinter.BooleanVar(None,False)}
        self.settings['export_fileformats'] = list()

        #self.entry_var = dict()
        #self.entry_var = {'sensitivity': tkinter.StringVar(None,'1'), 'event_sep': tkinter.StringVar(None,'1')}
        self.sensitivity = 1
        self.event_sep = 1
        #self.progress = tkinter.StringVar(None)
        self.thread_analysis = None

        self.frames = None
        self.header = None
        #self.hertz_model_parameter = None
        self.parameter = None
        self.fit_settings = None
        self.analysis_control_panel = None
        self.results_panel = None

        self.results_show = {'full_map': {'qi_map': tkinter.BooleanVar(None,True), 'boxplot': tkinter.BooleanVar(None,True), 'histogram': tkinter.BooleanVar(None,True)}, 'selections': {'data_origin': tkinter.BooleanVar(None,True), 'boxplot': tkinter.BooleanVar(None,True), 'histogram': tkinter.BooleanVar(None,True), 'cumulative': tkinter.BooleanVar(None,False), 'layer': tkinter.IntVar(None, 1), 'layer_string': tkinter.StringVar(None, 'Layer 1')}}



        self.color_scheme = _Helper_Functions_GUI._set_color_options()






    def on_closing(self):

        if self.safe_closing:

            self.enter_window_app.destroy()
            self.control_parameter['breakthrough_events_window'] = False
            self.settings['visualization']['show_preview'].set(False)
            self.enter_window_app = None

            self.settings['parameter']['sensitivity'].set('1')
            self.settings['parameter']['event_sep'].set('1')
            self.sensitivity = 1
            self.event_sep = 1

            self.frames = None
            self.header = None
            self.parameter = None
            self.fit_settings = None
            self.analysis_control_panel = None
            self.results_panel = None

        else:

            self.enter_window_app.bell()
            tkinter.messagebox.showinfo(parent = self.enter_window_app, title = 'Why so impatient! Let me finish first!', message = 'Cannot close Window. Analysis is still running!')


    #def on_opening(self):



    def _on_open_new_qi_map(self):

        if self.control_parameter['breakthrough_events_window']:

            self.results_panel['full_map']['show_results'].configure(state = 'disabled')
            self.results_panel['full_map']['show_parameter'].configure(state = 'disabled')
            #self.results_panel['selections']['show_results'].configure(state = 'disabled')

            self.analysis_control_panel['button_run'].configure(state = 'disabled')
            #self.selection_panel['run_analysis_selection'].configure(state = 'disabled')




    def _on_loading_qi_snapshot(self):

        if self.control_parameter['breakthrough_events_window']:

            if self.parent.qi_object.control_variables['allow_analysis']:
                self.analysis_control_panel['button_run'].configure(state = 'normal')

                if len(self.parent.qi_object.breakthrough_events['full_map']):
                    self.results_panel['full_map']['show_results'].configure(state = 'normal')
                    self.results_panel['full_map']['show_parameter'].configure(state = 'normal')
                else:
                    self.results_panel['full_map']['show_results'].configure(state = 'disabled')
                    self.results_panel['full_map']['show_parameter'].configure(state = 'disabled')

            else:
                self.analysis_control_panel['button_run'].configure(state = 'disabled')





    def setup_breakthrough_events(self):

        #self.on_opening()

        if isinstance(self.enter_window_app, tkinter.Toplevel):

            self.enter_window_app.lift()
            self.enter_window_app.focus_set()

        else:

            self.enter_window_app = tkinter.Toplevel() #use tkinter.Tk() only once in an application
            self.enter_window_app.title('Breakthrough Events')
            self.enter_window_app.resizable(False, False)
            self.enter_window_app.focus_set()

            self.control_parameter['breakthrough_events_window'] = True
            self.settings['visualization']['show_preview'].set(True)

            self._create_frames()
            self._create_frame_content()
            self._toggle_preview()



            self.parameter['sensitivity_entry'].bind('<Return>', self._enter_sensitivity)
            self.parameter['event_sep_entry'].bind('<Return>', self._enter_event_sep)







    def run_get_breakthrough_events(self):

        self.parent.safe_closing = False
        self.safe_closing = False
        self.analysis_control_panel['button_run'].configure(state = 'disabled')
        self.analysis_control_panel['progress_bar']['maximum'] = self.parent.qi_object.settings['fd_indices']['total'] - 1
        self.thread_analysis = threading.Thread(target = self.parent.qi_object.get_breakthrough_events, kwargs = {'sensitivity': self.sensitivity, 'event_sep': self.event_sep, 'export_result': self.settings['export_fileformats'], 'retract_plot': self.settings['visualization']['retract_plot'].get()})
        print('====================')
        self.thread_analysis.start()
        self.parent.after(50, self._update_progress)




    def show_analysis_results_full_map(self):

        if self.results_show['full_map']['qi_map'].get():

            x_width = np.round(self.parent.qi_object.settings['grid']['u-length']*10**6,2)
            y_width = np.round(self.parent.qi_object.settings['grid']['u-length']*10**6,2)

            fig_map_location = plt.figure()
            ax_map_location = fig_map_location.add_subplot(111)
            c_map_location = ax_map_location.imshow(self.parent.qi_object.data['breakthrough_events']['exists'], extent = [0, x_width, 0, y_width], origin = 'lower', cmap = 'gray_r')
#            cbar_map_layer_1 = fig_map_layer_1.colorbar(c_map_layer_1, ax=ax_map_layer_1)
#            cbar_map_layer_1.set_label('Apparent Young\'s modulus / Pa', rotation = 270, labelpad = 20)
            ax_map_location.set_xlabel('Position / \u03BCm')
            ax_map_location.set_ylabel('Position / \u03BCm')
            ax_map_location.set_title('Breakthrough Events: Location')




        if self.results_show['full_map']['histogram'].get():

            data_magn = list()

            for ind in self.parent.qi_object.breakthrough_events['full_map']['indices'].keys():
                for event in self.parent.qi_object.breakthrough_events['full_map']['indices'][ind]['events'].keys():

                    data_magn = np.append(data_magn,self.parent.qi_object.breakthrough_events['full_map']['indices'][ind]['events'][event]['magnitude'])



            fig_hist_magn = plt.figure()
            ax_hist_magn = fig_hist_magn.add_subplot(111)
            ax_hist_magn.hist(data_magn, bins = 'auto')
            ax_hist_magn.set_xlabel('Breakthrough event magnitude /' + self.parent.qi_object.breakthrough_events['full_map']['units']['distance']['unit'])
            ax_hist_magn.set_ylabel('Occurrence')
            ax_hist_magn.set_title('Breakthrough Events: Magnitude')
            ax_hist_magn.tick_params(direction = 'in', top = True, right = True)






    def show_analysis_parameter_full_map(self):

        info_window = tkinter.Toplevel()
        info_window.title('Info')
        info_window.resizable(False, False)
        info_window.focus_set()


        corrections = dict()
        corrections['force_unit'] = self.parent.qi_object.breakthrough_events['full_map']['corrections']['force_unit']
        corrections['distance_unit'] = self.parent.qi_object.breakthrough_events['full_map']['corrections']['distance_unit']

        corrections['baseline_correction'] = dict()
        corrections['baseline_correction']['method'] = self.parent.qi_object.breakthrough_events['full_map']['corrections']['baseline_correction']['method']
        corrections['baseline_correction']['reference'] = self.parent.qi_object.breakthrough_events['full_map']['corrections']['baseline_correction']['reference']
        corrections['baseline_correction']['frac_data'] = dict()
        corrections['baseline_correction']['frac_data']['min'] = self.parent.qi_object.breakthrough_events['full_map']['corrections']['baseline_correction']['frac_data'][0]
        corrections['baseline_correction']['frac_data']['min'] = self.parent.qi_object.breakthrough_events['full_map']['corrections']['baseline_correction']['frac_data'][1]

        frac_str = '(' + str(self.parent.qi_object.breakthrough_events['full_map']['corrections']['baseline_correction']['frac_data'][0]) + ',' + str(self.parent.qi_object.breakthrough_events['full_map']['corrections']['baseline_correction']['frac_data'][1]) + ')'
        corrections['baseline_correction']['frac_data_str'] = frac_str

        corrections['distance_correction'] = dict()
        corrections['distance_correction']['method'] = self.parent.qi_object.breakthrough_events['full_map']['corrections']['distance_correction']['method']
        corrections['distance_correction']['reference'] = self.parent.qi_object.breakthrough_events['full_map']['corrections']['distance_correction']['reference']
        corrections['distance_correction']['smooth_applied'] = self.parent.qi_object.breakthrough_events['full_map']['corrections']['distance_correction']['smooth_applied']
        corrections['distance_correction']['smooth_length'] = self.parent.qi_object.breakthrough_events['full_map']['corrections']['distance_correction']['smooth_length']
        corrections['distance_correction']['length_fit'] = self.parent.qi_object.breakthrough_events['full_map']['corrections']['distance_correction']['length_fit']

        corrections['get_tip_sample_separation'] = str(self.parent.qi_object.breakthrough_events['full_map']['corrections']['get_tip_sample_separation'])


        parameters = dict()
        parameters[0] = dict()
        parameters[0]['Sensitivity'] = self.parent.qi_object.breakthrough_events['full_map']['parameter']['sensitivity']
        parameters[0]['Event separation'] = self.parent.qi_object.breakthrough_events['full_map']['parameter']['event_separation']


        info_frames = dict()
        info_frames['header_frame'] = tkinter.Frame(info_window, background = self.color_scheme['background'], relief = 'ridge', borderwidth = 2)
        info_frames['header 1'] = tkinter.Label(info_frames['header_frame'], text = 'Analysis Info - Breakthough Events', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])
        info_frames['header 2'] = tkinter.Label(info_frames['header_frame'], text = '----- Full Map -----', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])
        info_frames['corrections_master'] = tkinter.Frame(info_window, background = self.color_scheme['background'])
        info_frames['parameters_master'] = tkinter.Frame(info_window, background = self.color_scheme['background'])
        info_frames['corrections'] = CorrectionInfoFrame_Result(info_frames['corrections_master'], corrections = corrections, background = self.color_scheme['background'], textcolor = self.color_scheme['text_standard'], highlighttextcolor = self.color_scheme['text_highlighted'])
        info_frames['parameters'] = ParameterInfoFrame_Result(info_frames['parameters_master'], parameters = parameters, background = self.color_scheme['background'], textcolor = self.color_scheme['text_standard'], highlighttextcolor = self.color_scheme['text_highlighted'])

        info_frames['header_frame'].grid(row = 0, column = 0, sticky = 'nswe')
        info_frames['corrections_master'].grid(row = 1, column = 0, sticky = 'nswe')
        info_frames['parameters_master'].grid(row = 2, column = 0, sticky = 'we')

        info_frames['header 1'].grid(row = 0, column = 0, sticky = 'nswe', padx = 10, pady = (10,0))
        info_frames['header 2'].grid(row = 1, column = 0, sticky = 'nswe', padx = 10, pady = (0,10))
        info_frames['corrections'].grid(row = 0, column = 0, sticky = 'nswe', pady = (0,50))
        info_frames['parameters'].grid(row = 0, column = 0, sticky = 'nswe')
        #info_window.columnconfigure(0, weight = 1)
        info_frames['parameters_master'].columnconfigure(0, weight = 1)
        #info_frames['parameters'].columnconfigure(0, weight = 1)



    def _create_frames(self):

        self.frames = dict()
        self.frames['master_frame'] = dict()
        self.frames['master_frame']['frame'] = tkinter.Frame(self.enter_window_app, background = self.color_scheme['background'])
        self.frames['master_frame']['separator'] = tkinter.Frame(self.enter_window_app, width = 1, bg = self.color_scheme['separator'])
        self.frames['master_frame']['info'] = tkinter.Frame(self.enter_window_app, bg = self.color_scheme['background'])

        self.frames['master_frame']['frame'].grid(row = 0, column = 0, sticky = 'nsw')
        self.frames['master_frame']['separator'].grid(row = 0, column = 1, sticky = 'ns')
        self.frames['master_frame']['info'].grid(row = 0, column = 2, sticky = 'nswe')


        self.frames['correction_info_frame'] = dict()
        self.frames['correction_info_frame']['frame'] = CorrectionInfoFrame(self.frames['master_frame']['info'], correction_window_ref = self.parent.corrections_window.confirmed_corrections, background = self.color_scheme['background'], textcolor = self.color_scheme['text_standard'], highlighttextcolor = self.color_scheme['text_highlighted'])#, relief = 'sunken', borderwidth = 1)
        self.frames['correction_info_frame']['frame'].grid(row = 0, column = 0, sticky = 'nswe')

        self.frames['master_frame']['children'] = dict()


        self.frames['master_frame']['children']['parameter'] = tkinter.Frame(self.frames['master_frame']['frame'], bg = self.color_scheme['background'])
        self.frames['master_frame']['children']['export_plot'] = tkinter.Frame(self.frames['master_frame']['frame'], bg = self.color_scheme['background'])
        self.frames['master_frame']['children']['analysis_control_panel'] = tkinter.Frame(self.frames['master_frame']['frame'], bg = self.color_scheme['background'])

        self.frames['master_frame']['children']['results_qi_map'] = tkinter.LabelFrame(self.frames['master_frame']['frame'], text = 'Complete QI Map', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], relief = 'ridge', padx = 10, pady = 5)
        self.frames['master_frame']['children']['results_selections'] = tkinter.LabelFrame(self.frames['master_frame']['frame'], text = 'Individual Selections', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], relief = 'ridge', padx = 10, pady = 5)

        self.header = dict()
        self.header['parameter'] = tkinter.Label(self.frames['master_frame']['frame'], text = "Parameter: Breakthrough Events", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.header['export_plot'] = tkinter.Label(self.frames['master_frame']['frame'], text = "Force-Distance Curves: Export/Visualization", width = 40, relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.header['analysis_control_panel'] = tkinter.Label(self.frames['master_frame']['frame'], text = "Analysis: Complete QI Map", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.header['show_results'] = tkinter.Label(self.frames['master_frame']['frame'], text = "Visualize Results", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])


        self.header['parameter'].grid(row = 0, column = 0, sticky = 'ew')
        self.frames['master_frame']['children']['parameter'].grid(row = 1, column = 0, sticky = 'ew', padx = 10, pady = 10)
        self.header['export_plot'].grid(row = 2, column = 0, sticky = "ew")
        self.frames['master_frame']['children']['export_plot'].grid(row = 3, column = 0, sticky = 'ew', padx = 10, pady = 10)
        self.header['analysis_control_panel'].grid(row = 4, column = 0, sticky = "ew")
        self.frames['master_frame']['children']['analysis_control_panel'].grid(row = 5, column = 0, sticky = 'ew', padx = 10, pady = 10)
        self.header['show_results'].grid(row = 6, column = 0, sticky = "ew")
        self.frames['master_frame']['children']['results_qi_map'].grid(row = 7, column = 0, sticky = 'ew', padx = 10, pady = 10)

        self.frames['master_frame']['children']['analysis_control_panel'].columnconfigure(1,weight = 1)


        self.enter_window_app.protocol("WM_DELETE_WINDOW", self.on_closing)




    def _create_frame_content(self):

        self.parameter = dict()
        self.parameter['sensitivity_label'] = tkinter.Label(self.frames['master_frame']['children']['parameter'], text = "Sensitivity:", bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.parameter['sensitivity_entry'] = tkinter.Entry(self.frames['master_frame']['children']['parameter'], textvariable = self.settings['parameter']['sensitivity'], width = 7, justify = 'right', bd = 0, bg = self.color_scheme['background_input_dark'], fg = self.color_scheme['text_standard'], insertbackground = self.color_scheme['text_standard'], highlightthickness = 1, highlightcolor = self.color_scheme['border_active'], highlightbackground = self.color_scheme['border'], selectbackground = self.color_scheme['text_selectbackground'])
        self.parameter['event_sep_label'] = tkinter.Label(self.frames['master_frame']['children']['parameter'], text = "Event separation:", bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.parameter['event_sep_entry'] = tkinter.Entry(self.frames['master_frame']['children']['parameter'], textvariable = self.settings['parameter']['event_sep'], width = 7, justify = 'right', bd = 0, bg = self.color_scheme['background_input_dark'], fg = self.color_scheme['text_standard'], insertbackground = self.color_scheme['text_standard'], highlightthickness = 1, highlightcolor = self.color_scheme['border_active'], highlightbackground = self.color_scheme['border'], selectbackground = self.color_scheme['text_selectbackground'])

        self.parameter['reset_settings'] = tkinter.Button(self.frames['master_frame']['children']['parameter'], text = 'Reset default', command = self._reset_settings, bg = self.color_scheme['button'], fg = self.color_scheme['text_highlighted'], activebackground = self.color_scheme['button'], activeforeground = self.color_scheme['text_highlighted'], disabledforeground = self.color_scheme['text_disabled'])

        self.parameter['sensitivity_label'].grid(row = 0, column = 0, sticky = 'w')
        self.parameter['sensitivity_entry'].grid(row = 0, column = 1, sticky = 'w', padx = (20,0))
        self.parameter['event_sep_label'].grid(row = 1, column = 0, sticky = 'w', pady = (10,0))
        self.parameter['event_sep_entry'].grid(row = 1, column = 1, sticky = 'w', padx = (20,0), pady = (10,0))
        self.parameter['reset_settings'].grid(row = 0, column = 2, padx = (40,0))




        self.visualization = dict()
        self.visualization['show_preview'] = tkinter.Checkbutton(self.frames['master_frame']['children']['export_plot'], text = 'Show in main window', variable = self.settings['visualization']['show_preview'], onvalue = True, offvalue = False, command = self._toggle_preview, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.visualization['retract_plot'] = tkinter.Checkbutton(self.frames['master_frame']['children']['export_plot'], text = 'Show \"retract\" curve', variable = self.parent.entry_var['fd_curve']['retract_plot'], onvalue = True, offvalue = False, command = self.update_plot, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.visualization['export_plot'] = tkinter.Checkbutton(self.frames['master_frame']['children']['export_plot'], text = 'Export individual figures', variable = self.settings['visualization']['export_result'], onvalue = True, offvalue = False, command = self._toggle_export_result, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.visualization['svg'] = tkinter.Checkbutton(self.frames['master_frame']['children']['export_plot'], text = 'svg', variable = self.settings['visualization']['svg'], onvalue = True, offvalue = False, command = self._update_export_fileformats,bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.visualization['pdf'] = tkinter.Checkbutton(self.frames['master_frame']['children']['export_plot'], text = 'pdf', variable = self.settings['visualization']['pdf'], onvalue = True, offvalue = False, command = self._update_export_fileformats,bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.visualization['png'] = tkinter.Checkbutton(self.frames['master_frame']['children']['export_plot'], text = 'png', variable = self.settings['visualization']['png'], onvalue = True, offvalue = False, command = self._update_export_fileformats,bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.visualization['pkl'] = tkinter.Checkbutton(self.frames['master_frame']['children']['export_plot'], text = 'pkl', variable = self.settings['visualization']['pkl'], onvalue = True, offvalue = False, command = self._update_export_fileformats,bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])

        self.visualization['show_preview'].grid(row = 0, column = 0, columnspan = 4, sticky = 'w', padx = (0,20))
        self.visualization['retract_plot'].grid(row = 1, column = 0, columnspan = 4, sticky = 'w', padx = (0,20))
        self.visualization['export_plot'].grid(row = 2, column = 0, columnspan = 4, sticky = 'w', pady = (20,0))
        self.visualization['svg'].grid(row = 3, column = 0, sticky = 'w', padx = (10,0))
        self.visualization['pdf'].grid(row = 3, column = 1, sticky = 'w')
        self.visualization['png'].grid(row = 3, column = 2, sticky = 'w')
        self.visualization['pkl'].grid(row = 3, column = 3, sticky = 'w')



        self.analysis_control_panel = dict()
        self.analysis_control_panel['button_run'] = tkinter.Button(self.frames['master_frame']['children']['analysis_control_panel'], text = 'Run analysis', command = self.run_get_breakthrough_events, state = 'disabled', bg = self.color_scheme['button'], fg = self.color_scheme['text_highlighted'], activebackground = self.color_scheme['button'], activeforeground = self.color_scheme['text_highlighted'], disabledforeground = self.color_scheme['text_disabled'])
        self.analysis_control_panel['progress_bar'] = tkinter.ttk.Progressbar(self.frames['master_frame']['children']['analysis_control_panel'], value = 0, mode = 'determinate')


        self.analysis_control_panel['button_run'].grid(row = 0, column = 0, padx = (0,10))
        self.analysis_control_panel['progress_bar'].grid(row = 0, column = 1, sticky = 'ew')

        if self.control_parameter['apply_corrections'].get():
            self.analysis_control_panel['button_run'].configure(state = 'normal')


        self.results_panel = dict()
        self.results_panel['full_map'] = dict()
        self.results_panel['full_map']['show_results'] = tkinter.Button(self.frames['master_frame']['children']['results_qi_map'], text = 'Show results', command = self.show_analysis_results_full_map, state = 'disabled', bg = self.color_scheme['button'], fg = self.color_scheme['text_highlighted'], activebackground = self.color_scheme['button'], activeforeground = self.color_scheme['text_highlighted'], disabledforeground = self.color_scheme['text_disabled'])
        self.results_panel['full_map']['qi_map'] = tkinter.Checkbutton(self.frames['master_frame']['children']['results_qi_map'], text = 'QI Map', variable = self.results_show['full_map']['qi_map'], onvalue = True, offvalue = False, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.results_panel['full_map']['boxplot'] = tkinter.Checkbutton(self.frames['master_frame']['children']['results_qi_map'], text = 'Boxplot', variable = self.results_show['full_map']['boxplot'], onvalue = True, offvalue = False, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.results_panel['full_map']['histogram'] = tkinter.Checkbutton(self.frames['master_frame']['children']['results_qi_map'], text = 'Histogram', variable = self.results_show['full_map']['histogram'], onvalue = True, offvalue = False, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.results_panel['full_map']['show_parameter'] = tkinter.Button(self.frames['master_frame']['children']['results_qi_map'], text = 'Show parameter', command = self.show_analysis_parameter_full_map, state = 'disabled', bg = self.color_scheme['button'], fg = self.color_scheme['text_highlighted'], activebackground = self.color_scheme['button'], activeforeground = self.color_scheme['text_highlighted'], disabledforeground = self.color_scheme['text_disabled'])


        self.results_panel['statistics'] = dict()
#        self.results_panel['statistics']['header'] = tkinter.Label(self.frames['master_frame']['children']['results_qi_map'], text = "Statistics", bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.results_panel['statistics']['events_number_label'] = tkinter.Label(self.frames['master_frame']['children']['results_qi_map'], text = '# of events:', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.results_panel['statistics']['events_number_details'] = tkinter.Label(self.frames['master_frame']['children']['results_qi_map'], text = 'N/A', width = 13, anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])
        self.results_panel['statistics']['events_probability_label'] = tkinter.Label(self.frames['master_frame']['children']['results_qi_map'], text = 'Fraction:', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.results_panel['statistics']['events_probability_details'] = tkinter.Label(self.frames['master_frame']['children']['results_qi_map'], text = 'N/A', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])

        self.results_panel['full_map']['qi_map'].grid(row = 0, column = 0, sticky = 'w')
        self.results_panel['full_map']['histogram'].grid(row = 1, column = 0, sticky = 'w', pady = (0,0))

#        self.results_panel['statistics']['header'].grid(row = 0, column = 1, columnspan = 2, sticky = 'w', padx = (20,10))
        self.results_panel['statistics']['events_number_label'].grid(row = 0, column = 1, sticky = 'w', padx = (40,10), pady = (0,0))
        self.results_panel['statistics']['events_number_details'].grid(row = 0, column = 2, sticky = 'w', pady = (0,0))
        self.results_panel['statistics']['events_probability_label'].grid(row = 1, column = 1, sticky = 'w', padx = (40,10), pady = (0,0))
        self.results_panel['statistics']['events_probability_details'].grid(row = 1, column = 2, sticky = 'w', pady = (0,0))

        self.results_panel['full_map']['show_results'].grid(row = 2, column = 0, sticky = 'w', pady = (15,5))
        self.results_panel['full_map']['show_parameter'].grid(row = 2, column = 1, sticky = 'w', pady = (15,5))


        if len(self.parent.qi_object.breakthrough_events['full_map']):
            self.results_panel['full_map']['show_results'].configure(state = 'normal')
            self.results_panel['full_map']['show_parameter'].configure(state = 'normal')


        self.fit_settings = dict()
        self.fit_settings['info'] = dict()
        self.fit_settings['info']['master_frame'] = tkinter.Frame(self.frames['master_frame']['info'], background = self.color_scheme['background'])
        self.fit_settings['info']['header'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = "==== Analysis Parameter ====", relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['info']['sensitivity_label'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = 'Sensitivity: ', width = 18, anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['info']['sensitivity_details'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = '1', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])
        self.fit_settings['info']['event_sep_label'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = 'Event separation: ', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.fit_settings['info']['event_sep_details'] = tkinter.Label(self.fit_settings['info']['master_frame'], text = '1', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])

        self.fit_settings['info']['master_frame'].grid(row = 1, column = 0, pady = (50,0), sticky = 'ew')
        self.fit_settings['info']['master_frame'].columnconfigure(1, weight = 1)
        self.fit_settings['info']['header'].grid(row = 0, column = 0, columnspan = 2, sticky = 'ew')
        self.fit_settings['info']['sensitivity_label'].grid(row = 1, column = 0, sticky = 'w', pady = (10,0), padx = (10,0))
        self.fit_settings['info']['sensitivity_details'].grid(row = 1, column = 1, sticky = 'w', pady = (10,0), padx = (0,10))
        self.fit_settings['info']['event_sep_label'].grid(row = 2, column = 0, sticky = 'w', pady = (0,10), padx = (10,0))
        self.fit_settings['info']['event_sep_details'].grid(row = 2, column = 1, sticky = 'w', pady = (0,10), padx = (0,10))



        info = dict()
        info[1] = CreateToolTip(self.parameter['sensitivity_label'], 'A breakthrough event is defined as a signature in the extend cycle where the cantilever deflection decreases by more than a threshold (default, 5 times baseline noise level). The threshold is set as x times the baseline noise level, where x = 5 - log10(sensitivity)')
        info[2] = CreateToolTip(self.parameter['event_sep_label'], 'Events that are seperated by equal or fewer data points than specified, will be combined to a single event. Default 1 means that an event ending with data point 100 is combined with an event starting at point 101, while it would not be combined with an event starting at 102. Enter 0 to not combined any events.')




    def _update_progress(self):

        if self.thread_analysis.is_alive():
            self.analysis_control_panel['progress_bar']['value'] = self.parent.qi_object.counter['count']
            self.parent.after(50, self._update_progress)
        else:
            self.analysis_control_panel['button_run'].configure(state = 'normal')
            self.results_panel['full_map']['show_results'].configure(state = 'normal')
            self.results_panel['full_map']['show_parameter'].configure(state = 'normal')
            #self.results_panel['selections']['show_results'].configure(state = 'normal')
            self.parent.safe_closing = True
            self.safe_closing = True

            #self.results_panel['statistics']['events_number_label']
            self.results_panel['statistics']['events_number_details'].configure(text = '%d/%d' %(int(np.nansum(self.parent.qi_object.data['breakthrough_events']['exists'])),self.parent.qi_object.data['breakthrough_events']['exists'].size))
            #self.results_panel['statistics']['events_probability_label']
            self.results_panel['statistics']['events_probability_details'].configure(text = str(np.round(100*np.nansum(self.parent.qi_object.data['breakthrough_events']['exists'])/self.parent.qi_object.data['breakthrough_events']['exists'].size,2)) + ' %')







    def _enter_sensitivity(self, event = None):

        try:

            conv = float(self.settings['parameter']['sensitivity'].get())

            if conv:

                self.senstivity = conv
                self.fit_settings['info']['sensitivity_details'].configure(text = str(conv))
                self.update_plot()

            else:

                self.enter_window_app.bell()

        except:

            self.enter_window_app.bell()




    def _enter_event_sep(self, event = None):

        try:

            conv = int(self.settings['parameter']['event_sep'].get())

            if conv:

                self.event_sep = conv
                self.fit_settings['info']['event_sep_details'].configure(text = str(conv))
                self.update_plot()

            else:

                self.enter_window_app.bell()

        except:

            self.enter_window_app.bell()




    def _reset_settings(self):

        self.settings['parameter']['sensitivity'].set('1')
        self.settings['parameter']['event_sep'].set('1')

        self.fit_settings['info']['sensitivity_details'].configure(text = '1')
        self.fit_settings['info']['event_sep_details'].configure(text = '1')





        self.update_plot()




    def _toggle_preview(self):

        if self.settings['visualization']['show_preview'].get():

            self.parent.standard_hertz_window.settings['visualization']['show_preview'].set(False)
            self.parent.multi_layer_segments_window.settings['visualization']['show_preview'].set(False)

        self.update_plot()




    def _toggle_export_result(self):

        if self.settings['visualization']['export_result'].get():

            self.settings['visualization']['svg'].set(True)
            self.settings['visualization']['pdf'].set(True)
            self.settings['visualization']['png'].set(True)
            self.settings['visualization']['pkl'].set(True)

        else:

            self.settings['visualization']['svg'].set(False)
            self.settings['visualization']['pdf'].set(False)
            self.settings['visualization']['png'].set(False)
            self.settings['visualization']['pkl'].set(False)

        self._update_export_fileformats()




    def _update_export_fileformats(self):

        if self.settings['visualization']['svg'].get():

            if 'svg' not in self.settings['export_fileformats']:
                self.settings['export_fileformats'].append('svg')
        else:
            if 'svg' in self.settings['export_fileformats']:
                self.settings['export_fileformats'].remove('svg')

        if self.settings['visualization']['pdf'].get():
            if 'pdf' not in self.settings['export_fileformats']:
                self.settings['export_fileformats'].append('pdf')
        else:
            if 'pdf' in self.settings['export_fileformats']:
                self.settings['export_fileformats'].remove('pdf')

        if self.settings['visualization']['png'].get():
            if 'png' not in self.settings['export_fileformats']:
                self.settings['export_fileformats'].append('png')
        else:
            if 'png' in self.settings['export_fileformats']:
                self.settings['export_fileformats'].remove('png')

        if self.settings['visualization']['pkl'].get():
            if 'pkl' not in self.settings['export_fileformats']:
                self.settings['export_fileformats'].append('pkl')
        else:
            if 'pkl' in self.settings['export_fileformats']:
                self.settings['export_fileformats'].remove('pkl')








class SelectionToolWindow():

    def __init__(self,QI_FD_Preview_object):

        self.parent = QI_FD_Preview_object
        self.safe_closing = True
        self.enter_window_app = None
        self.control_parameter = QI_FD_Preview_object.control_parameter

        self.entry_var = dict()
        self.entry_var['identifier'] = tkinter.StringVar(None)
        self.entry_var['colormap'] = tkinter.StringVar(None, 'afmhot')
        self.entry_var['limits'] = {'vmin': tkinter.StringVar(None), 'vmax': tkinter.StringVar(None)}
        self.selections = list(self.parent.qi_object.selections.keys())
        self.characteristics = {'identifier': tkinter.StringVar(None), 'type': tkinter.StringVar(None), 'root': tkinter.StringVar(None), 'fd_index': tkinter.StringVar(None)}

        self.frames = None
        self.headers = None
        self.entry = None
        self.buttons = None
        self.listbox = None
        self.new_selection = None
        self.selection_info = None
        self.additional_settings = None

        self.mpl_canvas = None
        self.backend = None
        self.graphs = {'figure': None, 'axes': None, 'image': None, 'colorbar': None, 'axes_colorbar': None, 'marker': None}
        self.displayed_graph = None
        self.data_key = None
        self.new_points_list = None
        self.new_points_plot = None
        self.new_line_plot = None
        self.new_line_text = None
        self.selections_lines = None
        self.selections_texts = None
        self.show_selections = tkinter.BooleanVar(None, True)
        self.show_identifiers = tkinter.BooleanVar(None, True)
        #self.analysis_control_panel = None




        self.color_scheme = _Helper_Functions_GUI._set_color_options()

        self.keys_pressed = dict()
        self.keys_pressed['Control_L'] = False
        self.keys_pressed['Shift_L'] = False
        self.canvas_bindings_ids = dict()




    def on_closing(self):

        if self.safe_closing:

            self.enter_window_app.destroy()
            self.control_parameter['selection_tool_window'] = False
            self.enter_window_app = None

            self.frames = None
            self.headers = None
            self.entry = None
            self.entry_var['identifier'].set('')
            self.entry_var['colormap'].set('afmhot')
            self.entry_var['limits']['vmin'].set('')
            self.entry_var['limits']['vmax'].set('')
            self.characteristics['identifier'].set('')
            self.characteristics['type'].set('')
            self.characteristics['root'].set('')
            self.characteristics['fd_index'].set('')

            self.buttons = None
            self.listbox = None
            self.new_selection = None
            self.selection_info = None
            self.additional_settings = None

            self.mpl_canvas = None
            self.backend = None
            self.graphs = {'figure': None, 'axes': None, 'image': None, 'colorbar': None, 'axes_colorbar': None, 'marker': None}
            self.displayed_graph = None
            self.data_key = None

            self.new_points_list = None
            self.new_points_plot = None
            self.new_line_plot = None
            self.new_line_text = None
            self.selections_lines = None
            self.selections_texts = None
            self.show_selections.set(True)
            self.show_identifiers.set(True)


            #self.line_data = {'x':list(), 'y':list()}

            self.keys_pressed['Control_L'] = False
            self.keys_pressed['Shift_L'] = False
            self.canvas_bindings_ids = dict()

        else:
            self.enter_window_app.bell()
            tkinter.messagebox.showinfo(parent = self.enter_window_app, title = 'Why so impatient! Let me finish first!', message = 'Cannot close Window. Selection process is still running!')



    def setup_selection_tool(self):


        if isinstance(self.enter_window_app, tkinter.Toplevel):

            self.enter_window_app.lift()
            self.enter_window_app.focus_set()

        else:

            self.enter_window_app = tkinter.Toplevel() #use tkinter.Tk() only once in an application
            self.enter_window_app.title('Selection Tool')
            self.enter_window_app.resizable(False, False)
            self.enter_window_app.focus_set()

            self.control_parameter['selection_tool_window'] = True

            self.selections = list(self.parent.qi_object.selections.keys())

            self._create_frames()
            self._create_frame_content()
            self._create_canvas()
            self._plot_qi_map()

            self.listbox['standard_selections'].bind("<<ListboxSelect>>", self._show_selection_characteristics)
            self.frames['master_frame']['canvas_frame'].bind('<Enter>', self._canvas_gets_focus)
            self.enter_window_app.bind('<Control_L>', self._control_press)
            self.enter_window_app.bind('<Shift_L>', self._shift_press)
            self.enter_window_app.bind('<KeyRelease>', self._key_released)
            #self.enter_window_app.bind('<Button-1>', self._deselect_listbox)
            self.enter_window_app.bind('<Escape>', self._deselect_listbox_escape)
            self.enter_window_app.bind('<Delete>', self.delete_selection)


            self.enter_window_app.protocol("WM_DELETE_WINDOW", self.on_closing)




    def _on_open_new_qi_map(self):

        if self.control_parameter['selection_tool_window']:
            self._select_topography()
            self._plot_qi_map()
            self.listbox['standard_selections'].delete(0,'end')
            for select in self.parent.qi_object.selections.keys():
                self.listbox['standard_selections'].insert('end', select)

            self.listbox['standard_selections_selected_item'] = None
            self.selections = list(self.parent.qi_object.selections.keys())

        self.characteristics['identifier'].set('')
        self.characteristics['type'].set('')
        self.characteristics['root'].set('')
        self.characteristics['fd_index'].set('')




    def _on_loading_qi_snapshot(self):
        self._on_open_new_qi_map()




    def start_selection_process(self):

        select_entry = self.entry_var['identifier'].get()

        if select_entry:
        #check wheter selection already exist

            self.parent.safe_closing = False
            self.safe_closing = False

            self.new_selection['status_label'].configure(text = 'Selection process in progress')

            self.entry.configure(state = 'disable')
            self.buttons['start'].configure(state = 'disable')
            self.additional_settings['colormap']['entry'].configure(state = 'disable')
            self.additional_settings['limits']['entry_vmin'].configure(state = 'disable')
            self.additional_settings['limits']['entry_vmax'].configure(state = 'disable')
            self.additional_settings['colormap']['entry'].unbind('<Return>')
            self.additional_settings['limits']['entry_vmin'].unbind('<Return>')
            self.additional_settings['limits']['entry_vmax'].unbind('<Return>')
            self.frames['canvas_frame']['selection']['label_topography'].unbind('<Button-1>')
            self.frames['canvas_frame']['selection']['label_layer_thickness'].unbind('<Button-1>')

            self.enter_window_app.unbind('<Escape>')

            #remove all the previous points, plot the selections if
            if self.new_points_plot:
                self.new_points_plot.remove()
                self.new_points_plot = None
                self.new_line_plot.remove()
                self.new_line_plot = None
                self.new_line_text.remove()
                self.new_line_text = None


            while self.selections_lines:
                self.selections_lines.pop(0).remove()

            while self.selections_texts: # separate, because text might not be shown
                self.selections_texts.pop(0).remove()


            if self.show_selections.get():

                for select in self.parent.qi_object.selections.keys():

                    polygon = plt.Polygon(self.parent.qi_object.selections[select]['vertices'], closed = True, fill = None)
                    line = self.graphs['axes'].add_line(polygon)
                    line.set_linewidth(1)
                    self.selections_lines.append(line)

                    if self.show_identifiers.get():

                        center = np.mean(self.parent.qi_object.selections[select]['vertices'], 0)
                        text = self.graphs['axes'].text(center[0], center[1], select, horizontalalignment = 'center')
                        self.selections_texts.append(text)


            self.backend.draw()

            self.new_points_list = list()
            self.new_points_plot = self.graphs['axes'].plot([],[], linewidth = 0, marker = 'x', markersize = 3, markeredgecolor = '#000000')[0]

            self.canvas_bindings_ids[0] = self.backend.mpl_connect('motion_notify_event', self._add_points_draw)
            self.canvas_bindings_ids[1] = self.backend.mpl_connect('button_press_event', self._add_points_click)
            self.enter_window_app.bind('<Return>', self.finalize_selection_process)
            self.enter_window_app.bind('<Escape>', self.abort_selection_process)




    def finalize_selection_process(self, event = None):

        self.backend.mpl_disconnect(self.canvas_bindings_ids[0])
        self.backend.mpl_disconnect(self.canvas_bindings_ids[1])

        self.new_selection['status_label'].configure(text = '')

        select_entry = self.entry.get()

        if select_entry in self.selections:
            self.delete_selection(select_entry = select_entry)


        poly_array = np.array(self.new_points_list)
        polygon = plt.Polygon(poly_array, closed = True, fill = None)
        self.new_line_plot = self.graphs['axes'].add_line(polygon)
        self.new_line_plot.set_color('blue')
        self.new_line_plot.set_linewidth(1)
        center = np.mean(poly_array, 0)
        self.new_line_text = self.graphs['axes'].text(center[0], center[1], select_entry, horizontalalignment = 'center', color = 'blue')

        self.backend.draw()




        self.parent.qi_object.select_fd_curves_in_aoi(select_key = select_entry, data_key = copy.deepcopy(self.data_key), show_selections = self.show_selections.get(), gui = True, poly_array = poly_array, origin = 'lower', cmap = self.entry_var['colormap'].get(), vmin = float(self.entry_var['limits']['vmin'].get()), vmax = float(self.entry_var['limits']['vmax'].get()))

        self.listbox['standard_selections'].insert('end', select_entry)
        #if self.parent.multi_layer_segments_window.control_parameter['multi_layer_segments_window']:
        if self.control_parameter['multi_layer_segments_window']:
            self.parent.multi_layer_segments_window.selection_panel['listbox'].insert('end', select_entry)
        if self.control_parameter['standard_hertz_window']:
            self.parent.standard_hertz_window.selection_panel['listbox'].insert('end', select_entry)


        self.selections.append(select_entry)
        self.entry.configure(state = 'normal')
        self.buttons['start'].configure(state = 'normal')
        self.entry_var['identifier'].set('')
        self.enter_window_app.unbind('<Return>')
        self.enter_window_app.unbind('<Escape>')
        self.enter_window_app.bind('<Escape>', self._deselect_listbox_escape)
        self.frames['canvas_frame']['selection']['label_topography'].bind('<Button-1>', self._select_topography)
        self.frames['canvas_frame']['selection']['label_layer_thickness'].bind('<Button-1>', self._select_layer_thickness)


        self.additional_settings['colormap']['entry'].configure(state = 'normal')
        self.additional_settings['limits']['entry_vmin'].configure(state = 'normal')
        self.additional_settings['limits']['entry_vmax'].configure(state = 'normal')
        self.additional_settings['colormap']['entry'].bind('<Return>', self._update_colormap)
        self.additional_settings['limits']['entry_vmin'].bind('<Return>', self._update_clim)
        self.additional_settings['limits']['entry_vmax'].bind('<Return>', self._update_clim)

        self.parent.safe_closing = True
        self.safe_closing = True




    def abort_selection_process(self, event = None):

        self.backend.mpl_disconnect(self.canvas_bindings_ids[0])
        self.backend.mpl_disconnect(self.canvas_bindings_ids[1])

        self.new_selection['status_label'].configure(text = '')

        if self.new_points_plot:
            self.new_points_plot.remove()
            self.new_points_plot = None


        self.backend.draw()

        self.entry.configure(state = 'normal')
        self.buttons['start'].configure(state = 'normal')
        self.entry_var['identifier'].set('')
        self.enter_window_app.unbind('<Return>')
        self.enter_window_app.unbind('<Escape>')
        self.enter_window_app.bind('<Escape>', self._deselect_listbox_escape)
        self.frames['canvas_frame']['selection']['label_topography'].bind('<Button-1>', self._select_topography)
        self.frames['canvas_frame']['selection']['label_layer_thickness'].bind('<Button-1>', self._select_layer_thickness)

        self.additional_settings['colormap']['entry'].configure(state = 'normal')
        self.additional_settings['limits']['entry_vmin'].configure(state = 'normal')
        self.additional_settings['limits']['entry_vmax'].configure(state = 'normal')
        self.additional_settings['colormap']['entry'].bind('<Return>', self._update_colormap)
        self.additional_settings['limits']['entry_vmin'].bind('<Return>', self._update_clim)
        self.additional_settings['limits']['entry_vmax'].bind('<Return>', self._update_clim)

        self.parent.safe_closing = True
        self.safe_closing = True




    def delete_selection(self, event = None, select_entry = None):

        if select_entry and select_entry in self.selections:

            self.parent.qi_object.delete_selection(select_entry)
            ind = self.selections.index(select_entry)
            self.selections.remove(select_entry)

            if self.control_parameter['multi_layer_segments_window']:
                self.parent.multi_layer_segments_window.selection_panel['listbox'].delete(ind)
            if self.control_parameter['standard_hertz_window']:
                self.parent.standard_hertz_window.selection_panel['listbox'].delete(ind)
            self.listbox['standard_selections'].delete(ind)

            # if self.new_points_plot:
            #     self.new_points_plot.remove()
            #     self.new_points_plot = None
            #     self.new_line_plot.remove()
            #     self.new_line_plot = None
            #     self.new_line_text.remove()
            #     self.new_line_text = None


            while self.selections_lines:
                self.selections_lines.pop(0).remove()

            while self.selections_texts: # separate, because text might not be shown
                self.selections_texts.pop(0).remove()


            if self.show_selections.get():

                for select in self.parent.qi_object.selections.keys():

                    polygon = plt.Polygon(self.parent.qi_object.selections[select]['vertices'], closed = True, fill = None)
                    line = self.graphs['axes'].add_line(polygon)
                    line.set_linewidth(1)
                    self.selections_lines.append(line)

                    if self.show_identifiers.get():

                        center = np.mean(self.parent.qi_object.selections[select]['vertices'], 0)
                        text = self.graphs['axes'].text(center[0], center[1], select, horizontalalignment = 'center')
                        self.selections_texts.append(text)


            #self.backend.draw()


        elif self.listbox['standard_selections'].curselection():

            self.parent.qi_object.delete_selection(self.listbox['standard_selections'].get('active'))
            self.selections.remove(self.listbox['standard_selections'].get('active'))
            if self.control_parameter['multi_layer_segments_window']:
                self.parent.multi_layer_segments_window.selection_panel['listbox'].delete(self.listbox['standard_selections'].curselection())
            if self.control_parameter['standard_hertz_window']:
                self.parent.standard_hertz_window.selection_panel['listbox'].delete(self.listbox['standard_selections'].curselection())
            self.listbox['standard_selections'].delete(self.listbox['standard_selections'].curselection())

            if self.new_points_plot:
                self.new_points_plot.remove()
                self.new_points_plot = None
                self.new_line_plot.remove()
                self.new_line_plot = None
                self.new_line_text.remove()
                self.new_line_text = None


            while self.selections_lines:
                self.selections_lines.pop(0).remove()

            while self.selections_texts: # separate, because text might not be shown
                self.selections_texts.pop(0).remove()


            if self.show_selections.get():

                for select in self.parent.qi_object.selections.keys():

                    polygon = plt.Polygon(self.parent.qi_object.selections[select]['vertices'], closed = True, fill = None)
                    line = self.graphs['axes'].add_line(polygon)
                    line.set_linewidth(1)
                    self.selections_lines.append(line)

                    if self.show_identifiers.get():

                        center = np.mean(self.parent.qi_object.selections[select]['vertices'], 0)
                        text = self.graphs['axes'].text(center[0], center[1], select, horizontalalignment = 'center')
                        self.selections_texts.append(text)


            self.backend.draw()

        self._show_selection_characteristics()




    def _add_points_draw(self,event):

        if self.keys_pressed['Control_L']:
            if event.xdata is not None:
                self.new_points_list.append((event.xdata,event.ydata))
                #self.graphs['axes'].plot(event.xdata,event.ydata, marker = '.')
                self.new_points_plot.set_xdata(np.append(self.new_points_plot.get_xdata(), event.xdata))
                self.new_points_plot.set_ydata(np.append(self.new_points_plot.get_ydata(), event.ydata))
                self.backend.draw()
            #print('Draw:', event.xdata, event.ydata)

    def _add_points_click(self,event):

        if self.keys_pressed['Shift_L']:
            if event.xdata is not None:
                self.new_points_list.append((event.xdata,event.ydata))
                #self.graphs['axes'].plot(event.xdata,event.ydata, marker = '.')
                self.new_points_plot.set_xdata(np.append(self.new_points_plot.get_xdata(), event.xdata))
                self.new_points_plot.set_ydata(np.append(self.new_points_plot.get_ydata(), event.ydata))
                self.backend.draw()
            #print('Click:', event.xdata, event.ydata)




    def _create_frames(self):

        self.frames = dict()
        self.frames['master_frame'] = dict()
        self.frames['master_frame']['control_frame'] = tkinter.Frame(self.enter_window_app)
        self.frames['master_frame']['canvas_frame'] = tkinter.Frame(self.enter_window_app)
        self.frames['master_frame']['separator'] = tkinter.Frame(self.enter_window_app, background = self.color_scheme['separator'])
        #self.frames['master_frame']['canvas_frame'].columnconfigure(2,weight = 1)
        #self.frames['master_frame']['canvas_frame'].rowconfigure(1,weight = 1)

        self.frames['master_frame']['control_frame'].configure(background = self.color_scheme['background'])#, relief = 'sunken', borderwidth = 1)
        self.frames['master_frame']['canvas_frame'].configure(background = self.color_scheme['background'])#, relief = 'sunken', borderwidth = 1)

        self.frames['master_frame']['control_frame'].grid(row = 0, column = 0, sticky = 'nsw')
        self.frames['master_frame']['separator'].grid(row = 0, column = 1, sticky = 'ns')
        self.frames['master_frame']['canvas_frame'].grid(row = 0, column = 2, sticky = 'nsew')
        #self.frames['master_frame']['canvas_frame'].grid_propagate(False)
        self.frames['master_frame']['canvas_frame'].columnconfigure(0, weight = 1)



        self.frames['canvas_frame'] = dict()
        self.frames['canvas_frame']['selection'] = dict()
        self.frames['canvas_frame']['selection']['master_frame'] = tkinter.Frame(self.frames['master_frame']['canvas_frame'], background = self.color_scheme['border'])
        #self.frames['canvas_frame']['additional_settings'] = tkinter.Frame(self.frames['master_frame']['canvas_frame'], background = self.color_scheme['background'])
        self.frames['canvas_frame']['qi_map'] = dict()
        self.frames['canvas_frame']['qi_map']['master_frame'] = tkinter.Frame(self.frames['master_frame']['canvas_frame'], background = self.color_scheme['figure_background'], relief = 'ridge', borderwidth = 2)#self.color_scheme['background'])

        self.frames['canvas_frame']['selection']['spacer_start'] = tkinter.Frame(self.frames['canvas_frame']['selection']['master_frame'], background = self.color_scheme['border'], width = 20)
        self.frames['canvas_frame']['selection']['option_topography'] = tkinter.Frame(self.frames['canvas_frame']['selection']['master_frame'], background = self.color_scheme['background'])
        self.frames['canvas_frame']['selection']['option_layer_thickness'] = tkinter.Frame(self.frames['canvas_frame']['selection']['master_frame'], background = self.color_scheme['background_dark'])
        self.frames['canvas_frame']['selection']['spacer_end'] = tkinter.Frame(self.frames['canvas_frame']['selection']['master_frame'], background = self.color_scheme['border'])

        self.frames['canvas_frame']['selection']['label_topography'] = tkinter.Label(self.frames['canvas_frame']['selection']['option_topography'], text = 'Topography', width = 15)
        self.frames['canvas_frame']['selection']['label_layer_thickness'] = tkinter.Label(self.frames['canvas_frame']['selection']['option_layer_thickness'], text = 'Layer Thickness', width = 15)


        self.frames['canvas_frame']['selection']['master_frame'].grid(row = 0, column = 0, sticky = 'nsew')
        self.frames['canvas_frame']['qi_map']['master_frame'].grid(row = 1, column = 0, sticky = 'nsew', padx = 10, pady = 10)

        self.frames['canvas_frame']['selection']['spacer_start'].grid(row = 0, column = 0, sticky= 'nsew', pady = (0,1))
        #self.frames['canvas_frame']['selection']['option_topography'].grid(row = 0, column = 1, padx = 1, pady = (0,0))
        #self.frames['canvas_frame']['selection']['option_layer_thickness'].grid(row = 0, column = 2, padx = (0,1), pady = (0,1))
        self.frames['canvas_frame']['selection']['master_frame'].columnconfigure(3, weight = 1)
        self.frames['canvas_frame']['selection']['spacer_end'].grid(row = 0, column = 3, sticky= 'nsew', pady = (0,1))
        #self.frames['canvas_frame']['selection']['label_topography'].grid(row = 0, column = 0, sticky = 'ew', pady = (1,0))
        #self.frames['canvas_frame']['selection']['label_layer_thickness'].grid(row = 0, column = 0, sticky = 'ew', pady = (0,0))
        self._select_topography_startup()

        #placeholder = tkinter.Label(self.frames['canvas_frame']['additional_settings'], text = 'To Do: Options to change limits and colormap!', background = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        #placeholder.grid(row = 0, column = 0, padx = 10, pady = 5)

        self.frames['canvas_frame']['qi_map']['toolbar'] = tkinter.Frame(self.frames['canvas_frame']['qi_map']['master_frame'])
        self.frames['canvas_frame']['qi_map']['additional_settings'] = tkinter.Frame(self.frames['canvas_frame']['qi_map']['master_frame'], bg = self.color_scheme['figure_background'])
        self.frames['canvas_frame']['qi_map']['canvas'] = tkinter.Frame(self.frames['canvas_frame']['qi_map']['master_frame'])

        self.frames['canvas_frame']['qi_map']['toolbar'].grid(row = 0, column = 0, sticky = 'nsew')
        self.frames['canvas_frame']['qi_map']['additional_settings'].grid(row = 1, column = 0, sticky = 'nsw')
        self.frames['canvas_frame']['qi_map']['canvas'].grid(row = 2, column = 0)


        self.headers = dict()
        self.headers['control_frame'] = dict()
        self.headers['control_frame']['new_selection'] = tkinter.Label(self.frames['master_frame']['control_frame'], text = "New Selection", width = 25, relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.headers['control_frame']['existing_selection'] = tkinter.Label(self.frames['master_frame']['control_frame'], text = "Existing Selections", width = 25, relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.headers['control_frame']['info_guide'] = tkinter.Label(self.frames['master_frame']['control_frame'], text = "Keybindings", width = 25, relief = 'ridge', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])

        self.frames['control_frame'] = dict()
        self.frames['control_frame']['new_selection'] = tkinter.Frame(self.frames['master_frame']['control_frame'], background = self.color_scheme['background'])
        self.frames['control_frame']['existing_selection'] = tkinter.Frame(self.frames['master_frame']['control_frame'], background = self.color_scheme['background'])
        self.frames['control_frame']['info_guide'] = tkinter.Frame(self.frames['master_frame']['control_frame'], background = self.color_scheme['background'])

        self.headers['control_frame']['new_selection'].grid(row = 0, column = 0, sticky = 'ew')
        self.frames['control_frame']['new_selection'].grid(row = 1, column = 0, sticky = 'ew', padx = 10, pady = 5)
        self.headers['control_frame']['existing_selection'].grid(row = 2, column = 0, sticky = 'ew')
        self.frames['control_frame']['existing_selection'].grid(row = 3, column = 0, sticky = 'ew', padx = 10, pady = 5)
        self.headers['control_frame']['info_guide'].grid(row = 4, column = 0, sticky = 'ew')
        self.frames['control_frame']['info_guide'].grid(row = 5, column = 0, sticky = 'ew', padx = 10, pady = 5)

        self.frames['canvas_frame']['selection']['label_topography'].bind('<Button-1>', self._select_topography)
        self.frames['canvas_frame']['selection']['label_layer_thickness'].bind('<Button-1>', self._select_layer_thickness)




    def _create_frame_content(self):

        self.new_selection = dict()
        self.new_selection['entry_label'] = tkinter.Label(self.frames['control_frame']['new_selection'], text = 'Enter identifier:', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.new_selection['status_label'] = tkinter.Label(self.frames['control_frame']['new_selection'], text = '', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])

        self.entry = tkinter.Entry(self.frames['control_frame']['new_selection'], textvariable = self.entry_var['identifier'], width = 15, justify = 'right', bd = 0, bg = self.color_scheme['background_input_dark'], fg = self.color_scheme['text_standard'], disabledbackground = self.color_scheme['background_input_disabled'], insertbackground = self.color_scheme['text_standard'], highlightthickness = 1, highlightcolor =  self.color_scheme['border_active'], highlightbackground = self.color_scheme['border'], selectbackground = self.color_scheme['text_selectbackground'])
        self.buttons = dict()
        self.buttons['start'] = tkinter.Button(self.frames['control_frame']['new_selection'], text = 'Start selection', width = 12, command = self.start_selection_process, state = 'normal', bg = self.color_scheme['button'], fg = self.color_scheme['text_highlighted'], activebackground = self.color_scheme['button'], activeforeground = self.color_scheme['text_highlighted'], disabledforeground = self.color_scheme['text_disabled'])

        self.new_selection['entry_label'].grid(row = 0, column = 0, pady = (5,0), sticky = 'w')
        self.entry.grid(row = 1, column = 0, pady = (0,10), sticky = 'we')
        self.new_selection['status_label'].grid(row = 1, column = 1, pady = (0,10), padx = (20,0), sticky = 'we')
        self.buttons['start'].grid(row = 2, column = 0, pady = (0,5), sticky = 'we')


        self.listbox = dict()
        #self.listbox['frame'] = tkinter.Frame(self.frames['control_frame']['existing_selection'], background = self.color_scheme['background'])
        self.listbox['standard_selections'] = tkinter.Listbox(self.frames['control_frame']['existing_selection'], height = 6, width = 15, selectmode = 'single', bg = self.color_scheme['background_input_dark'], fg = self.color_scheme['text_standard'], selectbackground = self.color_scheme['text_selectbackground'], activestyle = 'none', bd = 0, highlightthickness = 1, highlightcolor =  self.color_scheme['border_active'], highlightbackground = self.color_scheme['border'], relief = 'flat')
        for v in self.selections:
            self.listbox['standard_selections'].insert('end', v)

        self.listbox['standard_selections_scrollbar'] = tkinter.Scrollbar(self.frames['control_frame']['existing_selection']) #changing color does not work
        self.listbox['standard_selections_selected_item'] = None
        self.buttons['show_selections'] = tkinter.Checkbutton(self.frames['control_frame']['existing_selection'], text = 'Show selections', variable = self.show_selections, command = self._toggle_show_selections, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])
        self.buttons['show_identifiers'] = tkinter.Checkbutton(self.frames['control_frame']['existing_selection'], text = 'Show identifiers', variable = self.show_identifiers, command = self._toggle_show_identifiers, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'], selectcolor = self.color_scheme['background'], activebackground = self.color_scheme['background'], activeforeground = self.color_scheme['text_standard'])

        self.selection_info = dict()
        self.selection_info['frame'] = tkinter.Frame(self.frames['control_frame']['existing_selection'], bg = self.color_scheme['background'])
        self.selection_info['header'] = tkinter.Label(self.selection_info['frame'], text = 'Characteristics', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.selection_info['identifier_label'] = tkinter.Label(self.selection_info['frame'], text = 'Identifier:', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.selection_info['identifier_var'] = tkinter.Label(self.selection_info['frame'], textvariable = self.characteristics['identifier'], width = 14, anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])
        self.selection_info['type_label'] = tkinter.Label(self.selection_info['frame'], text = 'Type:', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.selection_info['type_var'] = tkinter.Label(self.selection_info['frame'], textvariable = self.characteristics['type'], width = 14, anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])
        self.selection_info['fd_index_label'] = tkinter.Label(self.selection_info['frame'], text = '# of FD:', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.selection_info['fd_index_var'] = tkinter.Label(self.selection_info['frame'], textvariable = self.characteristics['fd_index'], width = 14, anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])
        self.selection_info['root_label'] = tkinter.Label(self.selection_info['frame'], text = 'Root:', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.selection_info['root_var'] = tkinter.Message(self.selection_info['frame'], textvariable = self.characteristics['root'], anchor  = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_highlighted'])

        self.listbox['standard_selections'].grid(row = 0, column = 0, sticky = 'we')
        self.listbox['standard_selections_scrollbar'].grid(row = 0, column = 1, padx = (0,5), sticky = 'nsw')
        self.buttons['show_selections'].grid(row = 1, column = 0, columnspan = 2, pady = (10,0), sticky = 'w')
        self.buttons['show_identifiers'].grid(row = 2, column = 0, columnspan = 2, pady = (0,5), padx = (20,5), sticky = 'w')
        # attach listbox to scrollbar
        self.listbox['standard_selections'].config(yscrollcommand=self.listbox['standard_selections_scrollbar'].set)
        self.listbox['standard_selections_scrollbar'].config(command=self.listbox['standard_selections'].yview)

        self.selection_info['frame'].grid(row = 0, column = 2, rowspan = 3, padx = (10,0), sticky = 'ns')
        self.selection_info['frame'].columnconfigure(1, weight = 1)
        self.selection_info['header'].grid(row = 0, column = 0, columnspan = 2, sticky = 'w')
        self.selection_info['identifier_label'].grid(row = 1, column = 0, sticky = 'w')
        self.selection_info['identifier_var'].grid(row = 1, column = 1, padx = (5,0), sticky = 'w')
        self.selection_info['type_label'].grid(row = 2, column = 0, sticky = 'w')
        self.selection_info['type_var'].grid(row = 2, column = 1, padx = (5,0), sticky = 'w')
        self.selection_info['fd_index_label'].grid(row = 3, column = 0, sticky = 'w')
        self.selection_info['fd_index_var'].grid(row = 3, column = 1, padx = (5,0), sticky = 'w')
        self.selection_info['root_label'].grid(row = 4, column = 0, sticky = 'nw')
        self.selection_info['root_var'].grid(row = 4, column = 1, padx = (5,0), sticky = 'nw')


        info_guide = dict()
        info_guide['Control_L'] = tkinter.Label(self.frames['control_frame']['info_guide'], text = 'CTRL:', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        info_guide['Control_L_text'] = tkinter.Message(self.frames['control_frame']['info_guide'], text = 'Add points with mouse motion', width = 220, anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        info_guide['Shift_L'] = tkinter.Label(self.frames['control_frame']['info_guide'], text = 'SHIFT:', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        info_guide['Shift_L_text'] = tkinter.Message(self.frames['control_frame']['info_guide'], text = 'Add points with mouse clicks', width = 220, anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        info_guide['Return'] = tkinter.Label(self.frames['control_frame']['info_guide'], text = 'RETURN:', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        info_guide['Return_text'] = tkinter.Message(self.frames['control_frame']['info_guide'], text = 'Finish current selection process', width = 220, anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        info_guide['Escape'] = tkinter.Label(self.frames['control_frame']['info_guide'], text = 'ESC:', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        info_guide['Escape_text'] = tkinter.Message(self.frames['control_frame']['info_guide'], text = '- Abort current selection process\n- Deselect the tagged selection', width = 220, anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        info_guide['Delete'] = tkinter.Label(self.frames['control_frame']['info_guide'], text = 'DELETE:', anchor = 'w', bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        info_guide['Delete_text'] = tkinter.Message(self.frames['control_frame']['info_guide'], text = 'Delete the tagged selection', anchor = 'w', width = 220, bg = self.color_scheme['background'], fg = self.color_scheme['text_standard'])

        info_guide['Control_L'].grid(row = 0, column = 0, pady = (1,0), sticky = 'nw')
        info_guide['Control_L_text'].grid(row = 0, column = 1, padx = (10,0), sticky = 'nwe')
        info_guide['Shift_L'].grid(row = 1, column = 0, pady = (1,0), sticky = 'nw')
        info_guide['Shift_L_text'].grid(row = 1, column = 1, padx = (10,0), sticky = 'nwe')
        info_guide['Return'].grid(row = 2, column = 0, sticky = 'nw')
        info_guide['Return_text'].grid(row = 2, column = 1, padx = (10,0), sticky = 'nwe')
        info_guide['Escape'].grid(row = 3, column = 0, sticky = 'nw')
        info_guide['Escape_text'].grid(row = 3, column = 1, padx = (10,0), sticky = 'nwe')
        info_guide['Delete'].grid(row = 4, column = 0, sticky = 'nw')
        info_guide['Delete_text'].grid(row = 4, column = 1, padx = (10,0), sticky = 'nwe')


        self.additional_settings = dict()
        self.additional_settings['colormap'] = dict()
        self.additional_settings['colormap']['label'] = tkinter.Label(self.frames['canvas_frame']['qi_map']['additional_settings'], text = 'Colormap:', bg = self.color_scheme['figure_background'], fg = self.color_scheme['text_standard'])
        self.additional_settings['colormap']['entry'] = tkinter.Entry(self.frames['canvas_frame']['qi_map']['additional_settings'], textvariable = self.entry_var['colormap'], width = 12 , justify = 'right', bd = 0, bg = self.color_scheme['background_input_dark'], fg = self.color_scheme['text_standard'], disabledbackground = self.color_scheme['background_input_disabled'], insertbackground = self.color_scheme['text_standard'], highlightthickness = 1, highlightcolor =  self.color_scheme['border_active'], highlightbackground = self.color_scheme['border'], selectbackground = self.color_scheme['text_selectbackground'])

        self.additional_settings['limits'] = dict()
        self.additional_settings['limits']['label_vmin'] = tkinter.Label(self.frames['canvas_frame']['qi_map']['additional_settings'], text = 'Vmin:', bg = self.color_scheme['figure_background'], fg = self.color_scheme['text_standard'])
        self.additional_settings['limits']['label_vmax'] = tkinter.Label(self.frames['canvas_frame']['qi_map']['additional_settings'], text = 'Vmax:', bg = self.color_scheme['figure_background'], fg = self.color_scheme['text_standard'])
        self.additional_settings['limits']['entry_vmin'] = tkinter.Entry(self.frames['canvas_frame']['qi_map']['additional_settings'], textvariable = self.entry_var['limits']['vmin'], width = 7, justify = 'right', bd = 0, bg = self.color_scheme['background_input_dark'], fg = self.color_scheme['text_standard'], disabledbackground = self.color_scheme['background_input_disabled'], insertbackground = self.color_scheme['text_standard'], highlightthickness = 1, highlightcolor =  self.color_scheme['border_active'], highlightbackground = self.color_scheme['border'], selectbackground = self.color_scheme['text_selectbackground'])
        self.additional_settings['limits']['entry_vmax'] = tkinter.Entry(self.frames['canvas_frame']['qi_map']['additional_settings'], textvariable = self.entry_var['limits']['vmax'], width = 7, justify = 'right', bd = 0, bg = self.color_scheme['background_input_dark'], fg = self.color_scheme['text_standard'], disabledbackground = self.color_scheme['background_input_disabled'], insertbackground = self.color_scheme['text_standard'], highlightthickness = 1, highlightcolor =  self.color_scheme['border_active'], highlightbackground = self.color_scheme['border'], selectbackground = self.color_scheme['text_selectbackground'])

        self.additional_settings['colormap']['label'].grid(row = 0, column = 0, pady = (10,5), padx = (10,0), sticky = 'nsw')
        self.additional_settings['colormap']['entry'].grid(row = 0, column = 1, pady = (10,5), padx = (5,10), sticky = 'nsw')
        self.additional_settings['limits']['label_vmin'].grid(row = 0, column = 2, pady = (10,5), padx = (25,5), sticky = 'nsw')
        self.additional_settings['limits']['entry_vmin'].grid(row = 0, column = 3, pady = (10,5), padx = (0,10), sticky = 'nsw')
        self.additional_settings['limits']['label_vmax'].grid(row = 0, column = 4, pady = (10,5), padx = (5,5), sticky = 'nsw')
        self.additional_settings['limits']['entry_vmax'].grid(row = 0, column = 5, pady = (10,5), padx = (0,10), sticky = 'nsw')

        self.additional_settings['colormap']['entry'].bind('<Return>', self._update_colormap)
        self.additional_settings['limits']['entry_vmin'].bind('<Return>', self._update_clim)
        self.additional_settings['limits']['entry_vmax'].bind('<Return>', self._update_clim)


        info1 = CreateToolTip(self.additional_settings['colormap']['label'], 'Enter a valid color map - see matplitlib documentation for choices.')







    def _create_canvas(self):

        plt.ioff()
        self.graphs['figure'] = plt.figure(facecolor = self.color_scheme['figure_background'], figsize = (6.4,4.8), dpi = 100)
        plt.ion()

        self.backend = FigureCanvasTkAgg(self.graphs['figure'], self.frames['canvas_frame']['qi_map']['canvas'])
        self.mpl_canvas = self.backend.get_tk_widget()
        #self.configure()
        self.mpl_canvas.grid(row = 0, column = 0)

        self.toolbar = NavigationToolbar2Tk(self.backend, self.frames['canvas_frame']['qi_map']['toolbar'])
        self.toolbar.configure(background = self.color_scheme['figure_background'])
        self.toolbar._message_label.config(background = self.color_scheme['figure_background'], foreground = self.color_scheme['text_standard'])
        self.toolbar.update()

        #self.mpl_canvas['qi_map'].configure(width = self.dimensions['master_frame']['children']['middle']['children'][2]['children']['canvas_frame']['width'], height = self.dimensions['master_frame']['children']['middle']['children'][2]['children']['canvas_frame']['height'])
        #self.mpl_canvas['qi_map'].grid(row = 0, column = 0)




    def _plot_qi_map(self):

        if isinstance(self.graphs['axes'], matplotlib.axes.Axes):

            self.graphs['figure'].clear() #clear whole figure, as there are several subplots

        self.graphs['axes'] = self.graphs['figure'].add_subplot(111)
        self.graphs['axes'].set_xlabel('Position / pixel')
        self.graphs['axes'].set_ylabel('Position / pixel')
        self.graphs['figure'].subplots_adjust(top = 0.95)
        self.graphs['axes'].spines['bottom'].set_color(self.color_scheme['text_standard'])
        self.graphs['axes'].spines['top'].set_color(self.color_scheme['text_standard'])
        self.graphs['axes'].spines['left'].set_color(self.color_scheme['text_standard'])
        self.graphs['axes'].spines['right'].set_color(self.color_scheme['text_standard'])

        self.graphs['axes'].xaxis.label.set_color(self.color_scheme['text_standard'])
        self.graphs['axes'].yaxis.label.set_color(self.color_scheme['text_standard'])
        self.graphs['axes'].tick_params(colors=self.color_scheme['text_standard'], top = True, right = True)

        data_key = copy.deepcopy(self.data_key)
        data = self.parent.qi_object.data

        while len(data_key):

            key = data_key.pop(0)
            data = data[key]

        if self.displayed_graph == 'topography':

            color_label = 'Measured height / \u03BCm'
            self.entry_var['limits']['vmin'].set(str(np.round(np.nanmin(data)*1.1,2)))
            self.entry_var['limits']['vmax'].set(str(np.round(np.nanmax(data)*1.1,2)))

        elif self.displayed_graph == 'layer_thickness':

            color_label = 'Apparent layer thickness / nm'
            self.entry_var['limits']['vmin'].set('0')
            self.entry_var['limits']['vmax'].set('1000')


        self.graphs['image'] = self.graphs['axes'].imshow(data, origin = 'lower', cmap = self.entry_var['colormap'].get(), vmin = float(self.entry_var['limits']['vmin'].get()), vmax = float(self.entry_var['limits']['vmax'].get()))
        self.graphs['colorbar'] = self.graphs['figure'].colorbar(self.graphs['image'], ax = self.graphs['axes'])
        self.graphs['colorbar'].set_label(color_label, rotation = 270, labelpad = 20)
        self.graphs['axes_colorbar'] = self.graphs['colorbar'].ax

        self.graphs['colorbar'].outline.set_edgecolor(self.color_scheme['text_standard'])
        self.graphs['axes_colorbar'].xaxis.label.set_color(self.color_scheme['text_standard'])
        self.graphs['axes_colorbar'].yaxis.label.set_color(self.color_scheme['text_standard'])
        self.graphs['axes_colorbar'].tick_params(colors=self.color_scheme['text_standard'])


        self.selections_lines = list()
        self.selections_texts = list()

        if self.new_points_plot:

            self.new_points_plot.remove()
            self.new_points_plot = None
            self.new_line_text.remove()
            self.new_line_text = None

        if self.show_selections.get():

            self.buttons['show_identifiers'].configure(state = 'normal')

            for select in self.parent.qi_object.selections.keys():

                polygon = plt.Polygon(self.parent.qi_object.selections[select]['vertices'], closed = True, fill = None)
                line = self.graphs['axes'].add_line(polygon)
                line.set_linewidth(1)
                self.selections_lines.append(line)

                if self.show_identifiers.get():

                    center = np.mean(self.parent.qi_object.selections[select]['vertices'], 0)
                    text = self.graphs['axes'].text(center[0], center[1], select, horizontalalignment = 'center')
                    self.selections_texts.append(text)

        else:

            self.buttons['show_identifiers'].configure(state = 'disabled')


        self.backend.draw()




    def _select_topography_startup(self, event = None):

        self.frames['canvas_frame']['selection']['option_topography'].configure(background = self.color_scheme['background'])
        self.frames['canvas_frame']['selection']['label_topography'].configure(background = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
        self.frames['canvas_frame']['selection']['option_layer_thickness'].configure(background = self.color_scheme['background_dark'])
        self.frames['canvas_frame']['selection']['label_layer_thickness'].configure(background = self.color_scheme['background_dark'], fg = self.color_scheme['text_disabled'])

        self.frames['canvas_frame']['selection']['option_topography'].grid(row = 0, column = 1, padx = 1, pady = (0,0))
        self.frames['canvas_frame']['selection']['option_layer_thickness'].grid(row = 0, column = 2, padx = (0,1), pady = (0,1))
        self.frames['canvas_frame']['selection']['label_topography'].grid(row = 0, column = 0, sticky = 'ew', pady = (1,0))
        self.frames['canvas_frame']['selection']['label_layer_thickness'].grid(row = 0, column = 0, sticky = 'ew', pady = (0,0))

        self.displayed_graph = 'topography'
        self.data_key = ['topography_mod']




    def _select_topography(self, event = None):

        if self.displayed_graph == 'layer_thickness':

            self.frames['canvas_frame']['selection']['option_topography'].configure(background = self.color_scheme['background'])
            self.frames['canvas_frame']['selection']['label_topography'].configure(background = self.color_scheme['background'], fg = self.color_scheme['text_standard'])
            self.frames['canvas_frame']['selection']['option_layer_thickness'].configure(background = self.color_scheme['background_dark'])
            self.frames['canvas_frame']['selection']['label_layer_thickness'].configure(background = self.color_scheme['background_dark'], fg = self.color_scheme['text_disabled'])

            self.frames['canvas_frame']['selection']['option_topography'].grid(row = 0, column = 1, padx = 1, pady = (0,0))
            self.frames['canvas_frame']['selection']['option_layer_thickness'].grid(row = 0, column = 2, padx = (0,1), pady = (0,1))
            self.frames['canvas_frame']['selection']['label_topography'].grid(row = 0, column = 0, sticky = 'ew', pady = (1,0))
            self.frames['canvas_frame']['selection']['label_layer_thickness'].grid(row = 0, column = 0, sticky = 'ew', pady = (0,0))

            self.displayed_graph = 'topography'
            self.entry_var['colormap'].set('afmhot')
            self.data_key = ['topography_mod']
            self._plot_qi_map()




    def _select_layer_thickness(self, event = None):

        if self.displayed_graph == 'topography' and 'apparent_layer' in self.parent.qi_object.data.keys():

            self.frames['canvas_frame']['selection']['option_topography'].configure(background = self.color_scheme['background_dark'])
            self.frames['canvas_frame']['selection']['label_topography'].configure(background = self.color_scheme['background_dark'], fg = self.color_scheme['text_disabled'])
            self.frames['canvas_frame']['selection']['option_layer_thickness'].configure(background = self.color_scheme['background'])
            self.frames['canvas_frame']['selection']['label_layer_thickness'].configure(background = self.color_scheme['background'], fg = self.color_scheme['text_standard'])

            self.frames['canvas_frame']['selection']['option_topography'].grid(row = 0, column = 1, padx = 1, pady = (0,1))
            self.frames['canvas_frame']['selection']['option_layer_thickness'].grid(row = 0, column = 2, padx = (0,1), pady = (0,0))
            self.frames['canvas_frame']['selection']['label_topography'].grid(row = 0, column = 0, sticky = 'ew', pady = (0,0))
            self.frames['canvas_frame']['selection']['label_layer_thickness'].grid(row = 0, column = 0, sticky = 'ew', pady = (1,0))

            self.displayed_graph = 'layer_thickness'
            self.entry_var['colormap'].set('RdYlBu_r')
            self.data_key = ['apparent_layer','basic']
            self._plot_qi_map()




    def _toggle_show_selections(self, event = None):

        while self.selections_lines:
            self.selections_lines.pop(0).remove()

        while self.selections_texts: # separate, because text might not be shown
            self.selections_texts.pop(0).remove()

        if self.new_points_plot:
            self.new_points_plot.remove()
            self.new_points_plot = None
            self.new_line_plot.remove()
            self.new_line_plot = None
            self.new_line_text.remove()
            self.new_line_text = None

        if self.show_selections.get():

            self.buttons['show_identifiers'].configure(state = 'normal')

            for select in self.parent.qi_object.selections.keys():

                polygon = plt.Polygon(self.parent.qi_object.selections[select]['vertices'], closed = True, fill = None)
                line = self.graphs['axes'].add_line(polygon)
                line.set_linewidth(1)
                self.selections_lines.append(line)

                if self.show_identifiers.get():

                    center = np.mean(self.parent.qi_object.selections[select]['vertices'], 0)
                    text = self.graphs['axes'].text(center[0], center[1], select, horizontalalignment = 'center')
                    self.selections_texts.append(text)

        elif not self.show_selections.get():

            self.buttons['show_identifiers'].configure(state = 'disable')


        self.backend.draw()




    def _toggle_show_identifiers(self, event = None):

        while self.selections_lines:
            self.selections_lines.pop(0).remove()

        while self.selections_texts:
            self.selections_texts.pop(0).remove()

        if self.new_points_plot:
            self.new_points_plot.remove()
            self.new_points_plot = None
            self.new_line_plot.remove()
            self.new_line_plot = None
            self.new_line_text.remove()
            self.new_line_text = None

        if self.show_identifiers.get():

            for select in self.parent.qi_object.selections.keys():

                polygon = plt.Polygon(self.parent.qi_object.selections[select]['vertices'], closed = True, fill = None)
                line = self.graphs['axes'].add_line(polygon)
                line.set_linewidth(1)
                self.selections_lines.append(line)

                center = np.mean(self.parent.qi_object.selections[select]['vertices'], 0)
                text = self.graphs['axes'].text(center[0], center[1], select, horizontalalignment = 'center')
                self.selections_texts.append(text)

        else:

            for select in self.parent.qi_object.selections.keys():

                polygon = plt.Polygon(self.parent.qi_object.selections[select]['vertices'], closed = True, fill = None)
                line = self.graphs['axes'].add_line(polygon)
                line.set_linewidth(1)
                self.selections_lines.append(line)


        self.backend.draw()




    def _update_colormap(self, event = None):

        #if self.entry_var['colormap'].get() in _COLOR_MAPS:
        if self.entry_var['colormap'].get() in _Helper_Functions_GUI._get_colormaps_imshow():
            self.graphs['image'].set_cmap(self.entry_var['colormap'].get())
            self.backend.draw()

        else:

            self.enter_window_app.bell()
            print('Invalid color map')




    def _update_clim(self, event = None):

        try:

            vmin_new = float(self.entry_var['limits']['vmin'].get())
            vmax_new = float(self.entry_var['limits']['vmax'].get())

            self.graphs['image'].set_clim(vmin = vmin_new, vmax = vmax_new)
            self.backend.draw()

        except:

            self.enter_window_app.bell()
            print('Invalid climits!')




    def _show_selection_characteristics(self, event = None):
        # <<ListboxSelect>> also fires when selection is deactivated by clicking in listbox in other window.
        try:

            select_ind = self.listbox['standard_selections'].curselection()[0]
            select = self.selections[select_ind]

            self.characteristics['identifier'].set(select)
            self.characteristics['type'].set(self.parent.qi_object.selections[select]['type'])
            self.characteristics['root'].set(str(self.parent.qi_object.selections[select]['root']))
            self.characteristics['fd_index'].set(str(len(self.parent.qi_object.selections[select]['fd_index'])))

        except:

            self.characteristics['identifier'].set('')
            self.characteristics['type'].set('')
            self.characteristics['root'].set('')
            self.characteristics['fd_index'].set('')


    #
    # def _deselect_listbox(self, event = None):
    #
    #     #print(self.listbox['standard_selections'].curselection())
    #     if self.listbox['standard_selections_selected_item'] == self.listbox['standard_selections'].curselection():
    #         self.listbox['standard_selections'].selection_clear(0, 'end')
    #     self.listbox['standard_selections_selected_item'] = self.listbox['standard_selections'].curselection()

    def _deselect_listbox_escape(self, event = None):

        self.listbox['standard_selections'].selection_clear(0, 'end')

        self.characteristics['identifier'].set('')
        self.characteristics['type'].set('')
        self.characteristics['root'].set('')
        self.characteristics['fd_index'].set('')



    def _canvas_gets_focus(self,event):
        self.enter_window_app.bind('<Control_L>', self._control_press)
        self.enter_window_app.bind('<Shift_L>', self._shift_press)

    def _control_press(self, event = None):
        self.keys_pressed['Control_L'] = True
        self.enter_window_app.unbind('<Control_L>')
        #print('Selection Window: control pressed')

    def _shift_press(self, event = None):
        self.keys_pressed['Shift_L'] = True
        self.enter_window_app.unbind('<Shift_L>')
        #print('Selection Window: alt pressed')

    def _key_released(self, event = None):

        if event.keycode == 17:
            self.keys_pressed['Control_L'] = False
            self.enter_window_app.bind('<Control_L>', self._control_press)
            #print('Selection Window: control released')
        elif event.keycode == 16:
            self.keys_pressed['Shift_L'] = False
            self.enter_window_app.bind('<Shift_L>', self._shift_press)
            #print('Selection Window: alt released')




class CorrectionInfoFrame(tkinter.Frame):

    def __init__(self, root, correction_window_ref, **kwargs):

        self.options = dict()
        self.kwargs = self._get_options(**kwargs)

        tkinter.Frame.__init__(self, root, bg = self.options['background'], **self.kwargs)
        self.columnconfigure(0, weight = 1)
        #self.configure(width = 200)
        #self.grid_propagate(False)
        self.parent = root
        self.frames = dict()
        self.header = dict()
        self.labels = dict()
        self.confirmed_corrections = correction_window_ref
        self.create_frames()
        self.create_content()







    def create_frames(self):


        self.frames['info'] = tkinter.Frame(self, bg = self.options['background'])
        self.frames['units'] = tkinter.Frame(self, bg = self.options['background'])
        self.frames['baseline_correction'] = tkinter.Frame(self, bg = self.options['background'])
        self.frames['distance_correction'] = tkinter.Frame(self, bg = self.options['background'])
        self.frames['get_tip_sample_separation'] = tkinter.Frame(self, bg = self.options['background'])

        self.header['header'] = tkinter.Label(self, text = '==== Correction Info ====', relief = 'ridge', bg = self.options['background'], fg = self.options['textcolor'])
        self.header['units'] = tkinter.Label(self, text = 'Units', relief = 'ridge', bg = self.options['background'], fg = self.options['textcolor'])
        self.header['baseline_correction'] = tkinter.Label(self, text = 'Baseline Correction', relief = 'ridge', bg = self.options['background'], fg = self.options['textcolor'])
        self.header['distance_correction'] = tkinter.Label(self, text = 'Distance Correction', relief = 'ridge', bg = self.options['background'], fg = self.options['textcolor'])
        self.header['get_tip_sample_separation'] = tkinter.Label(self, text = 'Distance Axis/Height Axis', relief = 'ridge', bg = self.options['background'], fg = self.options['textcolor'])
        #self.frames['master']['frame'].grid(row = 0 , column = 0)

        self.header['header'].grid(row = 0, column = 0, sticky = 'ew')
        self.frames['info'].grid(row = 1 , column = 0, sticky = 'ew', padx = 10, pady = 10)
        self.header['units'].grid(row = 2, column = 0, sticky = 'ew')
        self.frames['units'].grid(row = 3 , column = 0, sticky = 'ew', padx = 10, pady = 10)
        self.header['baseline_correction'].grid(row = 4, column = 0, sticky = 'ew')
        self.frames['baseline_correction'].grid(row = 5 , column = 0, sticky = 'ew', padx = 10, pady = 10)
        self.header['distance_correction'].grid(row = 6, column = 0, sticky = 'ew')
        self.frames['distance_correction'].grid(row = 7 , column = 0, sticky = 'ew', padx = 10, pady = 10)
        self.header['get_tip_sample_separation'].grid(row = 8, column = 0, sticky = 'ew')
        self.frames['get_tip_sample_separation'].grid(row = 9 , column = 0, sticky = 'ew', padx = 10, pady = 10)

        self.frames['info'].columnconfigure(1, weight = 1)
        self.frames['units'].columnconfigure(1, weight = 1)
        self.frames['baseline_correction'].columnconfigure(1, weight = 1)
        self.frames['distance_correction'].columnconfigure(1, weight = 1)
        self.frames['get_tip_sample_separation'].columnconfigure(1, weight = 1)

        info1 = CreateToolTip(self.header['header'], 'The corrections that are shown here are applied to each force-distance curve in the analysis. Some of the parameters might be unused (smooth_length, length_fit) depending on the method used for distance_correction. Update corrections with \"Confirm corrections\" in the corrections window.')
        info2 = CreateToolTip(self.frames['info'], 'The corrections that are shown here are applied to each force-distance curve in the analysis. Some of the parameters might be unused (smooth_length, length_fit) depending on the method used for distance_correction. Update corrections with \"Confirm corrections\" in the corrections window.')




    def create_content(self):

        self.labels = dict()
        self.labels['info'] = tkinter.Label(self.frames['info'], text = 'Shows corrections applied in analysis', bg = self.options['background'], fg = self.options['textcolor'])

        self.labels['units'] = dict()
        self.labels['units']['force_unit_1'] = tkinter.Label(self.frames['units'], text = 'Force unit:', width = 14, anchor = 'w', bg = self.options['background'], fg = self.options['textcolor'])
        self.labels['units']['force_unit_2'] = tkinter.Label(self.frames['units'], textvariable =  self.confirmed_corrections['force_unit'], bg = self.options['background'], fg = self.options['highlighttextcolor'])
        self.labels['units']['distance_unit_1'] = tkinter.Label(self.frames['units'], text = 'Distance unit:', bg = self.options['background'], fg = self.options['textcolor'])
        self.labels['units']['distance_unit_2'] = tkinter.Label(self.frames['units'], textvariable = self.confirmed_corrections['distance_unit'], bg = self.options['background'], fg = self.options['highlighttextcolor'])

        self.labels['baseline_correction'] = dict()
        self.labels['baseline_correction']['method_1'] = tkinter.Label(self.frames['baseline_correction'], text = 'Method:', width = 14, anchor = 'w', bg = self.options['background'], fg = self.options['textcolor'])
        self.labels['baseline_correction']['method_2'] = tkinter.Label(self.frames['baseline_correction'], textvariable = self.confirmed_corrections['baseline_correction']['method'], bg = self.options['background'], fg = self.options['highlighttextcolor'])
        self.labels['baseline_correction']['reference_1'] = tkinter.Label(self.frames['baseline_correction'], text = 'Reference:', bg = self.options['background'], fg = self.options['textcolor'])
        self.labels['baseline_correction']['reference_2'] = tkinter.Label(self.frames['baseline_correction'], textvariable = self.confirmed_corrections['baseline_correction']['reference'], bg = self.options['background'], fg = self.options['highlighttextcolor'])
        self.labels['baseline_correction']['frac_data_1'] = tkinter.Label(self.frames['baseline_correction'], text = 'Interval:', bg = self.options['background'], fg = self.options['textcolor'])
        self.labels['baseline_correction']['frac_data_2'] = tkinter.Label(self.frames['baseline_correction'], textvariable = self.confirmed_corrections['baseline_correction']['frac_data_str'], bg = self.options['background'], fg = self.options['highlighttextcolor'])

        self.labels['distance_correction'] = dict()
        self.labels['distance_correction']['method_1'] = tkinter.Label(self.frames['distance_correction'], text = 'Method:', width = 14, anchor = 'w', bg = self.options['background'], fg = self.options['textcolor'])
        self.labels['distance_correction']['method_2'] = tkinter.Label(self.frames['distance_correction'], textvariable = self.confirmed_corrections['distance_correction']['method'], bg = self.options['background'], fg = self.options['highlighttextcolor'])
        self.labels['distance_correction']['reference_1'] = tkinter.Label(self.frames['distance_correction'], text = 'Reference:', bg = self.options['background'], fg = self.options['textcolor'])
        self.labels['distance_correction']['reference_2'] = tkinter.Label(self.frames['distance_correction'], textvariable = self.confirmed_corrections['distance_correction']['reference'], bg = self.options['background'], fg = self.options['highlighttextcolor'])
        self.labels['distance_correction']['smooth_applied_1'] = tkinter.Label(self.frames['distance_correction'], text = 'Smooth:', bg = self.options['background'], fg = self.options['textcolor'])
        self.labels['distance_correction']['smooth_applied_2'] = tkinter.Label(self.frames['distance_correction'], textvariable = self.confirmed_corrections['distance_correction']['smooth_applied'], bg = self.options['background'], fg = self.options['highlighttextcolor'])
        self.labels['distance_correction']['smooth_length_1'] = tkinter.Label(self.frames['distance_correction'], text = 'Smooth length:', bg = self.options['background'], fg = self.options['textcolor'])
        self.labels['distance_correction']['smooth_length_2'] = tkinter.Label(self.frames['distance_correction'], textvariable = self.confirmed_corrections['distance_correction']['smooth_length'], bg = self.options['background'], fg = self.options['highlighttextcolor'])
        self.labels['distance_correction']['length_fit_1'] = tkinter.Label(self.frames['distance_correction'], text = 'Fit length:', bg = self.options['background'], fg = self.options['textcolor'])
        self.labels['distance_correction']['length_fit_2'] = tkinter.Label(self.frames['distance_correction'], textvariable = self.confirmed_corrections['distance_correction']['length_fit'], bg = self.options['background'], fg = self.options['highlighttextcolor'])

        self.labels['get_tip_sample_separation'] = dict()
        self.labels['get_tip_sample_separation']['bool_1'] = tkinter.Label(self.frames['get_tip_sample_separation'], text = 'Get tip-sample separation:', bg = self.options['background'], fg = self.options['textcolor'])
        self.labels['get_tip_sample_separation']['bool_2'] = tkinter.Label(self.frames['get_tip_sample_separation'], textvariable = self.confirmed_corrections['get_tip_sample_separation'], bg = self.options['background'], fg = self.options['highlighttextcolor'])


        self.labels['info'].grid(row = 0, column = 0,  sticky = 'ew')

        self.labels['units']['force_unit_1'].grid(row = 0, column = 0, sticky = 'w')
        self.labels['units']['force_unit_2'].grid(row = 0, column = 1, sticky = 'w')
        self.labels['units']['distance_unit_1'].grid(row = 1, column = 0, sticky = 'w')
        self.labels['units']['distance_unit_2'].grid(row = 1, column = 1, sticky = 'w')

        self.labels['baseline_correction']['method_1'].grid(row = 0, column = 0, sticky = 'w')
        self.labels['baseline_correction']['method_2'].grid(row = 0, column = 1, sticky = 'w')
        self.labels['baseline_correction']['reference_1'].grid(row = 1, column = 0, sticky = 'w')
        self.labels['baseline_correction']['reference_2'].grid(row = 1, column = 1, sticky = 'w')
        self.labels['baseline_correction']['frac_data_1'].grid(row = 2, column = 0, sticky = 'w')
        self.labels['baseline_correction']['frac_data_2'].grid(row = 2, column = 1, sticky = 'w')

        self.labels['distance_correction']['method_1'].grid(row = 0, column = 0, sticky = 'w')
        self.labels['distance_correction']['method_2'].grid(row = 0, column = 1, sticky = 'w')
        self.labels['distance_correction']['reference_1'].grid(row = 1, column = 0, sticky = 'w')
        self.labels['distance_correction']['reference_2'].grid(row = 1, column = 1, sticky = 'w')
        self.labels['distance_correction']['smooth_applied_1'].grid(row = 2, column = 0, sticky = 'w')
        self.labels['distance_correction']['smooth_applied_2'].grid(row = 2, column = 1, sticky = 'w')
        self.labels['distance_correction']['smooth_length_1'].grid(row = 3, column = 0, sticky = 'w')
        self.labels['distance_correction']['smooth_length_2'].grid(row = 3, column = 1, sticky = 'w')
        self.labels['distance_correction']['length_fit_1'].grid(row = 4, column = 0, sticky = 'w')
        self.labels['distance_correction']['length_fit_2'].grid(row = 4, column = 1, sticky = 'w')

        self.labels['get_tip_sample_separation']['bool_1'].grid(row = 0, column = 0, sticky = 'w')
        self.labels['get_tip_sample_separation']['bool_2'].grid(row = 0, column = 1, sticky = 'w')

        #self.confirmed_corrections['get_tip_sample_separation'].set(self.parent.qi_object.corrections_pass_to_function['get_tip_sample_separation'])



    def _get_options(self, **kwargs):

        self.options['textcolor'] = kwargs.pop('textcolor', None)
        self.options['background'] = kwargs.pop('background', None)
        self.options['highlighttextcolor'] = kwargs.pop('highlighttextcolor', self.options['textcolor'])


        return kwargs



    #
    # def update_displayed_confirmed_corrections(self):
    #
    #     print('test')
    #     print(self.confirmed_corrections)
    #     self.labels['units']['force_unit_2'].config(text = self.confirmed_corrections['force_unit'])
    #     self.labels['units']['distance_unit_2'].config(text = self.confirmed_corrections['distance_unit'])
    #     self.labels['baseline_correction']['method_2'].config(text = self.confirmed_corrections['baseline_correction']['method'])
    #     self.labels['baseline_correction']['reference_2'].config(text = self.confirmed_corrections['baseline_correction']['reference'])


        # self.corrections = dict()
        # self.corrections['force_unit'] = tkinter.StringVar(None, 'nN')
        # self.corrections['distance_unit'] = tkinter.StringVar(None, 'nm')
        # self.corrections['baseline_correction'] = dict()
        # self.corrections['baseline_correction']['method'] = tkinter.StringVar(None, 'linear')
        # self.corrections['baseline_correction']['reference'] = tkinter.StringVar(None, 'individual')
        # self.corrections['baseline_correction']['frac_data'] = {'min':tkinter.IntVar(None, 0),'max':tkinter.IntVar(None, 50)}
        # self.corrections['distance_correction'] = dict()
        # self.corrections['distance_correction']['method'] = tkinter.StringVar(None, 'zero_force')
        # self.corrections['distance_correction']['reference'] = tkinter.StringVar(None, 'extend')
        # self.corrections['distance_correction']['smooth_applied'] = tkinter.BooleanVar(None, False)
        # self.corrections['distance_correction']['smooth_length'] = tkinter.IntVar(None, 51)
        # self.corrections['distance_correction']['length_fit'] = tkinter.IntVar(None, 10)
        # self.corrections['get_tip_sample_separation'] = tkinter.BooleanVar(None,True)





class CorrectionInfoFrame_Result(tkinter.Frame):

    def __init__(self, root, corrections, **kwargs):

        self.options = dict()
        self.kwargs = self._get_options(**kwargs)

        tkinter.Frame.__init__(self, root, bg = self.options['background'], **self.kwargs)
        self.columnconfigure(0, weight = 1)
        #self.configure(width = 200)
        #self.grid_propagate(False)
        self.parent = root
        self.frames = dict()
        self.header = dict()
        self.labels = dict()
        self.corrections = corrections
        self.create_frames()
        self.create_content()







    def create_frames(self):


        self.frames['info'] = tkinter.Frame(self, bg = self.options['background'])
        self.frames['units'] = tkinter.Frame(self, bg = self.options['background'])
        self.frames['baseline_correction'] = tkinter.Frame(self, bg = self.options['background'])
        self.frames['distance_correction'] = tkinter.Frame(self, bg = self.options['background'])
        self.frames['get_tip_sample_separation'] = tkinter.Frame(self, bg = self.options['background'])

        self.header['header'] = tkinter.Label(self, text = '==== Correction Info ====', relief = 'ridge', bg = self.options['background'], fg = self.options['textcolor'])
        self.header['units'] = tkinter.Label(self, text = 'Units', relief = 'ridge', bg = self.options['background'], fg = self.options['textcolor'])
        self.header['baseline_correction'] = tkinter.Label(self, text = 'Baseline Correction', relief = 'ridge', bg = self.options['background'], fg = self.options['textcolor'])
        self.header['distance_correction'] = tkinter.Label(self, text = 'Distance Correction', relief = 'ridge', bg = self.options['background'], fg = self.options['textcolor'])
        self.header['get_tip_sample_separation'] = tkinter.Label(self, text = 'Distance Axis/Height Axis', relief = 'ridge', bg = self.options['background'], fg = self.options['textcolor'])
        #self.frames['master']['frame'].grid(row = 0 , column = 0)

        self.header['header'].grid(row = 0, column = 0, sticky = 'ew')
        self.frames['info'].grid(row = 1 , column = 0, sticky = 'ew', padx = 10, pady = 10)
        self.header['units'].grid(row = 2, column = 0, sticky = 'ew')
        self.frames['units'].grid(row = 3 , column = 0, sticky = 'ew', padx = 10, pady = 10)
        self.header['baseline_correction'].grid(row = 4, column = 0, sticky = 'ew')
        self.frames['baseline_correction'].grid(row = 5 , column = 0, sticky = 'ew', padx = 10, pady = 10)
        self.header['distance_correction'].grid(row = 6, column = 0, sticky = 'ew')
        self.frames['distance_correction'].grid(row = 7 , column = 0, sticky = 'ew', padx = 10, pady = 10)
        self.header['get_tip_sample_separation'].grid(row = 8, column = 0, sticky = 'ew')
        self.frames['get_tip_sample_separation'].grid(row = 9 , column = 0, sticky = 'ew', padx = 10, pady = 10)


        self.frames['info'].columnconfigure(1, weight = 1)
        self.frames['units'].columnconfigure(1, weight = 1)
        self.frames['baseline_correction'].columnconfigure(1, weight = 1)
        self.frames['distance_correction'].columnconfigure(1, weight = 1)
        self.frames['get_tip_sample_separation'].columnconfigure(1, weight = 1)
#        info1 = CreateToolTip(self.header['header'], 'The corrections that are shown here are applied to each force-distance curve in the analysis. Some of the parameters might be unused (smooth_length, length_fit) depending on the method used for distance_correction. Update corrections with \"Confirm corrections\" in the corrections window.')
#        info2 = CreateToolTip(self.frames['info'], 'The corrections that are shown here are applied to each force-distance curve in the analysis. Some of the parameters might be unused (smooth_length, length_fit) depending on the method used for distance_correction. Update corrections with \"Confirm corrections\" in the corrections window.')




    def create_content(self):

        self.labels = dict()
        self.labels['info'] = tkinter.Label(self.frames['info'], text = 'Shows corrections applied in analysis', bg = self.options['background'], fg = self.options['textcolor'])

        self.labels['units'] = dict()
        self.labels['units']['force_unit_1'] = tkinter.Label(self.frames['units'], text = 'Force unit:', width = 14, anchor = 'w', bg = self.options['background'], fg = self.options['textcolor'])
        self.labels['units']['force_unit_2'] = tkinter.Label(self.frames['units'], text =  self.corrections['force_unit'], bg = self.options['background'], fg = self.options['highlighttextcolor'])
        self.labels['units']['distance_unit_1'] = tkinter.Label(self.frames['units'], text = 'Distance unit:', bg = self.options['background'], fg = self.options['textcolor'])
        self.labels['units']['distance_unit_2'] = tkinter.Label(self.frames['units'], text = self.corrections['distance_unit'], bg = self.options['background'], fg = self.options['highlighttextcolor'])

        self.labels['baseline_correction'] = dict()
        self.labels['baseline_correction']['method_1'] = tkinter.Label(self.frames['baseline_correction'], text = 'Method:', width = 14, anchor = 'w', bg = self.options['background'], fg = self.options['textcolor'])
        self.labels['baseline_correction']['method_2'] = tkinter.Label(self.frames['baseline_correction'], text = self.corrections['baseline_correction']['method'], bg = self.options['background'], fg = self.options['highlighttextcolor'])
        self.labels['baseline_correction']['reference_1'] = tkinter.Label(self.frames['baseline_correction'], text = 'Reference:', bg = self.options['background'], fg = self.options['textcolor'])
        self.labels['baseline_correction']['reference_2'] = tkinter.Label(self.frames['baseline_correction'], text = self.corrections['baseline_correction']['reference'], bg = self.options['background'], fg = self.options['highlighttextcolor'])
        self.labels['baseline_correction']['frac_data_1'] = tkinter.Label(self.frames['baseline_correction'], text = 'Interval:', bg = self.options['background'], fg = self.options['textcolor'])
        self.labels['baseline_correction']['frac_data_2'] = tkinter.Label(self.frames['baseline_correction'], text = self.corrections['baseline_correction']['frac_data_str'], bg = self.options['background'], fg = self.options['highlighttextcolor'])

        self.labels['distance_correction'] = dict()
        self.labels['distance_correction']['method_1'] = tkinter.Label(self.frames['distance_correction'], text = 'Method:', width = 14, anchor = 'w', bg = self.options['background'], fg = self.options['textcolor'])
        self.labels['distance_correction']['method_2'] = tkinter.Label(self.frames['distance_correction'], text = self.corrections['distance_correction']['method'], bg = self.options['background'], fg = self.options['highlighttextcolor'])
        self.labels['distance_correction']['reference_1'] = tkinter.Label(self.frames['distance_correction'], text = 'Reference:', bg = self.options['background'], fg = self.options['textcolor'])
        self.labels['distance_correction']['reference_2'] = tkinter.Label(self.frames['distance_correction'], text = self.corrections['distance_correction']['reference'], bg = self.options['background'], fg = self.options['highlighttextcolor'])
        self.labels['distance_correction']['smooth_applied_1'] = tkinter.Label(self.frames['distance_correction'], text = 'Smooth:', bg = self.options['background'], fg = self.options['textcolor'])
        self.labels['distance_correction']['smooth_applied_2'] = tkinter.Label(self.frames['distance_correction'], text = self.corrections['distance_correction']['smooth_applied'], bg = self.options['background'], fg = self.options['highlighttextcolor'])
        self.labels['distance_correction']['smooth_length_1'] = tkinter.Label(self.frames['distance_correction'], text = 'Smooth length:', bg = self.options['background'], fg = self.options['textcolor'])
        self.labels['distance_correction']['smooth_length_2'] = tkinter.Label(self.frames['distance_correction'], text = self.corrections['distance_correction']['smooth_length'], bg = self.options['background'], fg = self.options['highlighttextcolor'])
        self.labels['distance_correction']['length_fit_1'] = tkinter.Label(self.frames['distance_correction'], text = 'Fit length:', bg = self.options['background'], fg = self.options['textcolor'])
        self.labels['distance_correction']['length_fit_2'] = tkinter.Label(self.frames['distance_correction'], text = self.corrections['distance_correction']['length_fit'], bg = self.options['background'], fg = self.options['highlighttextcolor'])

        self.labels['get_tip_sample_separation'] = dict()
        self.labels['get_tip_sample_separation']['bool_1'] = tkinter.Label(self.frames['get_tip_sample_separation'], text = 'Get tip-sample separation:', bg = self.options['background'], fg = self.options['textcolor'])
        self.labels['get_tip_sample_separation']['bool_2'] = tkinter.Label(self.frames['get_tip_sample_separation'], text = self.corrections['get_tip_sample_separation'], bg = self.options['background'], fg = self.options['highlighttextcolor'])


        self.labels['info'].grid(row = 0, column = 0,  sticky = 'ew')

        self.labels['units']['force_unit_1'].grid(row = 0, column = 0, sticky = 'w')
        self.labels['units']['force_unit_2'].grid(row = 0, column = 1, sticky = 'w')
        self.labels['units']['distance_unit_1'].grid(row = 1, column = 0, sticky = 'w')
        self.labels['units']['distance_unit_2'].grid(row = 1, column = 1, sticky = 'w')

        self.labels['baseline_correction']['method_1'].grid(row = 0, column = 0, sticky = 'w')
        self.labels['baseline_correction']['method_2'].grid(row = 0, column = 1, sticky = 'w')
        self.labels['baseline_correction']['reference_1'].grid(row = 1, column = 0, sticky = 'w')
        self.labels['baseline_correction']['reference_2'].grid(row = 1, column = 1, sticky = 'w')
        self.labels['baseline_correction']['frac_data_1'].grid(row = 2, column = 0, sticky = 'w')
        self.labels['baseline_correction']['frac_data_2'].grid(row = 2, column = 1, sticky = 'w')

        self.labels['distance_correction']['method_1'].grid(row = 0, column = 0, sticky = 'w')
        self.labels['distance_correction']['method_2'].grid(row = 0, column = 1, sticky = 'w')
        self.labels['distance_correction']['reference_1'].grid(row = 1, column = 0, sticky = 'w')
        self.labels['distance_correction']['reference_2'].grid(row = 1, column = 1, sticky = 'w')
        self.labels['distance_correction']['smooth_applied_1'].grid(row = 2, column = 0, sticky = 'w')
        self.labels['distance_correction']['smooth_applied_2'].grid(row = 2, column = 1, sticky = 'w')
        self.labels['distance_correction']['smooth_length_1'].grid(row = 3, column = 0, sticky = 'w')
        self.labels['distance_correction']['smooth_length_2'].grid(row = 3, column = 1, sticky = 'w')
        self.labels['distance_correction']['length_fit_1'].grid(row = 4, column = 0, sticky = 'w')
        self.labels['distance_correction']['length_fit_2'].grid(row = 4, column = 1, sticky = 'w')

        self.labels['get_tip_sample_separation']['bool_1'].grid(row = 0, column = 0, sticky = 'w')
        self.labels['get_tip_sample_separation']['bool_2'].grid(row = 0, column = 1, sticky = 'w')

        #self.confirmed_corrections['get_tip_sample_separation'].set(self.parent.qi_object.corrections_pass_to_function['get_tip_sample_separation'])



    def _get_options(self, **kwargs):

        self.options['textcolor'] = kwargs.pop('textcolor', None)
        self.options['background'] = kwargs.pop('background', None)
        self.options['highlighttextcolor'] = kwargs.pop('highlighttextcolor', self.options['textcolor'])


        return kwargs




class ParameterInfoFrame_Result(tkinter.Frame):

    def __init__(self, root, parameters, **kwargs):

        self.options = dict()
        self.kwargs = self._get_options(**kwargs)

        tkinter.Frame.__init__(self, root, bg = self.options['background'], **self.kwargs)
        self.columnconfigure(0, weight = 1)
        #self.configure(width = 200)
        #self.grid_propagate(False)
        self.parent = root
        self.parameter_info = parameters
        self.frames = dict()
        self.header = dict()
        self.labels = dict()

        self.create_frames()
        self.create_content()




    def create_frames(self):

        self.header['parameter'] = tkinter.Label(self, text = '==== Analysis Parameter ====', relief = 'ridge', bg = self.options['background'], fg = self.options['textcolor'])
        self.frames['parameter'] = tkinter.Frame(self, bg = self.options['background'])


        self.header['parameter'].grid(row = 0, column = 0, sticky = 'we', pady = (0,0))
        self.frames['parameter'].grid(row = 1, column = 0, sticky = 'we', padx = 10, pady = (10,0))
        self.frames['parameter'].columnconfigure(1, weight = 1)
        #self.columnconfigure(1, weight = 1)



    def create_content(self):

        for group in self.parameter_info.keys():

            for key in self.parameter_info[group].keys():

                self.labels[key] = dict()
                self.labels[key][1] = tkinter.Label(self.frames['parameter'], text = str(key + ':'), anchor = 'w', bg = self.options['background'], fg = self.options['textcolor'])
                self.labels[key][2] = tkinter.Label(self.frames['parameter'], text = self.parameter_info[group][key], anchor = 'w', bg = self.options['background'], fg = self.options['highlighttextcolor'])

        row = 0

        for group in self.parameter_info.keys():

            keys = list(self.parameter_info[group].keys())
            for i in range(len(keys)):

                if i == len(keys) - 1:
                    self.labels[keys[i]][1].grid(row = row, column = 0, sticky = 'w', padx = (0,10), pady = (0,10))
                    self.labels[keys[i]][2].grid(row = row, column = 1, sticky = 'w', pady = (0,10))
                else:
                    self.labels[keys[i]][1].grid(row = row, column = 0, sticky = 'w', padx = (0,10))
                    self.labels[keys[i]][2].grid(row = row, column = 1, sticky = 'w')
                row += 1








    def _get_options(self, **kwargs):

        self.options['textcolor'] = kwargs.pop('textcolor', None)
        self.options['background'] = kwargs.pop('background', None)
        self.options['highlighttextcolor'] = kwargs.pop('highlighttextcolor', self.options['textcolor'])


        return kwargs





class SlideBar():

    def __init__(self,parent,width,height,border, frac_data_dict, update_plot):

        self.update_plot = update_plot

        self.parent = parent
        self.canvas_dimension = {'width':width*1.1+2*border+30, 'height':height+2*border+35}
        self.bar_dimension = {'width':width*1.1, 'height':height, 'x1':border, 'y1':border, 'x2':border+width*1.1, 'y2':2*border+height}
        self.slider_dimension = {'width':width*0.1, 'height':height}

        self.motion_range = self.bar_dimension['width']-self.slider_dimension['width']
        #self.slider_position = {'left': tkinter.IntVar(None,50), 'right': tkinter.IntVar(None,0)}
        self.slider_position = frac_data_dict


        self.frames = dict()
        self.frames['label'] = tkinter.Frame(self.parent)
        self.frames['label'].grid(row = 0, column = 0, columnspan = 2)
        self.frames['canvas'] = tkinter.Frame(self.parent)
        self.frames['canvas'].grid(row = 1, column = 0)
        self.frames['entry'] = dict()
        self.frames['entry']['master'] = tkinter.Frame(self.parent)
        self.frames['entry']['master'].grid(row = 1, column = 1)

        self.frames['entry']['label'] = tkinter.Frame(self.frames['entry']['master'])
        self.frames['entry']['label'].grid(row = 0, column = 0, columnspan = 2)
        self.frames['entry']['left'] = tkinter.Frame(self.frames['entry']['master'])
        self.frames['entry']['left'].grid(row = 1, column = 0)
        self.frames['entry']['right'] = tkinter.Frame(self.frames['entry']['master'])
        self.frames['entry']['right'].grid(row = 1, column = 1)

        self.frames['entry']['button_left'] = tkinter.Frame(self.frames['entry']['master'])
        self.frames['entry']['button_left'].grid(row = 2, column = 0)
        self.frames['entry']['button_right'] = tkinter.Frame(self.frames['entry']['master'])
        self.frames['entry']['button_right'].grid(row = 2, column = 1)

        #self.frames['entry']['button_left'].grid_propagate(False)

        #self.label = tkinter.Label(self.frames['label'], text = '=== Data range for correction ===').grid(row = 0, column = 0, sticky = 'nsew')

        self.canvas = tkinter.Canvas(self.frames['canvas'], width = self.canvas_dimension['width'], height = self.canvas_dimension['height'])
        self.canvas.grid(row = 0, column = 0)


        self.slide_bar = self.canvas.create_rectangle(self.bar_dimension['x1'], self.bar_dimension['y1'], self.bar_dimension['x2'], self.bar_dimension['y2'], fill="#dddddd")
        self.filled_bar = self.canvas.create_rectangle(self.bar_dimension['x2'] - self.slider_dimension['width'] - self.motion_range * (self.slider_position['max'].get()/100), self.bar_dimension['y1'],self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.motion_range * (self.slider_position['min'].get()/100), self.bar_dimension['y2'], fill = '#777777')

        self.sliders = dict()
        self.sliders['left'] = dict()
        self.sliders['left']['box'] = self.canvas.create_rectangle(self.bar_dimension['x2'] - self.slider_dimension['width'] - self.motion_range * (self.slider_position['max'].get()/100), self.bar_dimension['y1'] ,self.bar_dimension['x2'] - self.motion_range * (self.slider_position['max'].get()/100), self.bar_dimension['y2'], fill="#222222")
        self.sliders['left']['line'] = self.canvas.create_line(self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.motion_range * (self.slider_position['max'].get()/100), self.bar_dimension['y1'], self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.motion_range * (self.slider_position['max'].get()/100), self.bar_dimension['y2'], fill="#888888")
        self.sliders['right'] = dict()
        self.sliders['right']['box'] = self.canvas.create_rectangle(self.bar_dimension['x2'] - self.slider_dimension['width'] - self.motion_range * (self.slider_position['min'].get()/100), self.bar_dimension['y1'] ,self.bar_dimension['x2'] - self.motion_range * (self.slider_position['min'].get()/100), self.bar_dimension['y2'], fill="#222222")
        self.sliders['right']['line'] = self.canvas.create_line(self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.motion_range * (self.slider_position['min'].get()/100), self.bar_dimension['y1'], self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.motion_range * (self.slider_position['min'].get()/100), self.bar_dimension['y2'], fill="#888888")

        #self.filled_bar = {'x1':self.canvas.coords(self.sliders['right']['box'])[2], 'y1':border, 'x2':self.canvas.coords(self.sliders['right']['box'])[0], 'y2':2*border+height}
        #self.filled_bar = self.canvas.create_rectangle(self.canvas.coords(self.sliders['left']['box'])[2], self.bar_dimension['y1'],self.canvas.coords(self.sliders['right']['box'])[0], self.bar_dimension['y2'], fill = '#999999')
        self.start = tkinter.IntVar()



        self.canvas.tag_bind(self.sliders['left']['box'],'<Button-1>', self.click)
        self.canvas.tag_bind(self.sliders['left']['box'],'<B1-Motion>', self.motion_left_slider)
        self.canvas.tag_bind(self.sliders['left']['line'],'<Button-1>', self.click)
        self.canvas.tag_bind(self.sliders['left']['line'],'<B1-Motion>', self.motion_left_slider)

        self.canvas.tag_bind(self.sliders['right']['box'],'<Button-1>', self.click)
        self.canvas.tag_bind(self.sliders['right']['box'],'<B1-Motion>', self.motion_right_slider)
        self.canvas.tag_bind(self.sliders['right']['line'],'<Button-1>', self.click)
        self.canvas.tag_bind(self.sliders['right']['line'],'<B1-Motion>', self.motion_right_slider)

        self.ruler = dict()
        self.ruler['ticks'] = dict()
        self.ruler['labels'] = dict()

        for i in range(0,101,10):

            self.ruler['ticks'][i] = self.canvas.create_line(self.bar_dimension['x1']+0.5*self.slider_dimension['width'] + (100-i)/100*self.motion_range, self.bar_dimension['y2']+5, self.bar_dimension['x1']+0.5*self.slider_dimension['width'] + (100-i)/100*self.motion_range,self.bar_dimension['y2']+15)

        for i in range(5,101,10):

            self.ruler['ticks'][i] = self.canvas.create_line(self.bar_dimension['x1']+0.5*self.slider_dimension['width'] + (100-i)/100*self.motion_range, self.bar_dimension['y2']+5, self.bar_dimension['x1']+0.5*self.slider_dimension['width'] + (100-i)/100*self.motion_range,self.bar_dimension['y2']+10)

        for i in range(0,101,10):

            self.ruler['labels'][i] = self.canvas.create_text(self.canvas.coords(self.ruler['ticks'][i])[0],self.canvas.coords(self.ruler['ticks'][i])[3]+10,text = i)


        self.entry_var = dict()
        self.entry_var['left'] = tkinter.StringVar(None, self.slider_position['max'].get())
        self.entry_var['right'] = tkinter.StringVar(None, self.slider_position['min'].get())

        self.entry = dict()
        self.entry['label'] = tkinter.Label(self.frames['entry']['label'], text = 'Interval').grid(row = 0, column = 0, sticky = 'ew')
        self.entry['left'] = tkinter.Entry(self.frames['entry']['left'], textvariable = self.entry_var['left'], width = 4, justify = 'right', bd = 3)
        self.entry['right'] = tkinter.Entry(self.frames['entry']['right'], textvariable = self.entry_var['right'], width = 4, justify = 'right', bd = 3)
        self.entry['buttons'] = {'left': dict(), 'right': dict()}
        self.entry['buttons']['left']['up'] = tkinter.Button(self.frames['entry']['button_left'], text = '<', command = self.button_left_up)
        self.entry['buttons']['left']['down'] = tkinter.Button(self.frames['entry']['button_left'], text = '>', command = self.button_left_down)
        self.entry['buttons']['right']['up'] = tkinter.Button(self.frames['entry']['button_right'],text = '<', command = self.button_right_up)
        self.entry['buttons']['right']['down'] = tkinter.Button(self.frames['entry']['button_right'],text = '>', command = self.button_right_down)


        self.entry['left'].grid(row = 0, column = 0, sticky = 'w')
        self.entry['right'].grid(row = 0, column = 0, sticky = 'w')


        self.entry['buttons']['left']['up'].grid(row = 0, column = 0, sticky = 'nsw')
        self.entry['buttons']['left']['down'].grid(row = 0, column = 1, sticky = 'nse')
        self.entry['buttons']['right']['up'].grid(row = 0, column = 0, sticky = 'nsw')
        self.entry['buttons']['right']['down'].grid(row = 0, column = 1, sticky = 'nse')

        #self.entry['left'].bind('<KeyRelease>', self.set_left_slider_pos)
        #self.entry['right'].bind('<KeyRelease>', self.set_right_slider_pos)
        self.entry['left'].bind('<Return>', self.set_left_slider_pos)
        self.entry['right'].bind('<Return>', self.set_right_slider_pos)

    def click(self,event):

        self.start.set(event.x)




    def motion_left_slider(self,event):

        delta = event.x - self.start.get()

        if delta > 0 and self.canvas.coords(self.sliders['left']['box'])[2] < self.canvas.coords(self.sliders['right']['box'])[0] and self.slider_position['max'].get() - 10 > self.slider_position['min'].get():
        #if delta > 0 and self.slider_position['max'].get() - 10 > self.slider_position['min'].get():

            coords_old = self.canvas.coords(self.filled_bar)
            self.canvas.move(self.sliders['left']['box'],1,0)
            self.canvas.move(self.sliders['left']['line'],1,0)
            self.canvas.coords(self.filled_bar,coords_old[0]+1,coords_old[1],coords_old[2],coords_old[3])
            self.start.set(self.start.get()+1)

            self.slider_position['max'].set(100 * (self.bar_dimension['x2'] - self.canvas.coords(self.sliders['left']['line'])[0] - 0.5 * self.slider_dimension['width'])/ self.motion_range)
            self.entry_var['left'].set(self.slider_position['max'].get())

            self.update_plot()

        elif delta < 0 and self.canvas.coords(self.sliders['left']['box'])[0] > self.bar_dimension['x1']:
        #elif delta < 0 and self.slider_position['max'].get() < 100:

            coords_old = self.canvas.coords(self.filled_bar)
            self.canvas.move(self.sliders['left']['box'],-1,0)
            self.canvas.move(self.sliders['left']['line'],-1,0)
            self.canvas.coords(self.filled_bar,coords_old[0]-1,coords_old[1],coords_old[2],coords_old[3])
            self.start.set(self.start.get()-1)

            self.slider_position['max'].set(100 * (self.bar_dimension['x2'] - self.canvas.coords(self.sliders['left']['line'])[0] - 0.5 * self.slider_dimension['width'])/ self.motion_range)
            self.entry_var['left'].set(self.slider_position['max'].get())

            self.update_plot()


    def motion_right_slider(self,event):

        delta = event.x - self.start.get()

        if delta > 0 and self.canvas.coords(self.sliders['right']['box'])[2] < self.bar_dimension['x2']:
        #if delta > 0 and self.slider_position['min'].get()>0:

            coords_old = self.canvas.coords(self.filled_bar)
            self.canvas.move(self.sliders['right']['box'],1,0)
            self.canvas.move(self.sliders['right']['line'],1,0)
            self.canvas.coords(self.filled_bar,coords_old[0],coords_old[1],coords_old[2]+1,coords_old[3])
            self.start.set(self.start.get()+1)

            self.slider_position['min'].set(100 * (self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.canvas.coords(self.sliders['right']['line'])[0])/self.motion_range)
            self.entry_var['right'].set(self.slider_position['min'].get())

            self.update_plot()

        elif delta < 0 and self.canvas.coords(self.sliders['right']['box'])[0] > self.canvas.coords(self.sliders['left']['box'])[2] and self.slider_position['min'].get() + 10 < self.slider_position['max'].get():
        #elif delta < 0 and self.slider_position['min'].get() + 10 < self.slider_position['max'].get():

            coords_old = self.canvas.coords(self.filled_bar)
            self.canvas.move(self.sliders['right']['box'],-1,0)
            self.canvas.move(self.sliders['right']['line'],-1,0)
            self.canvas.coords(self.filled_bar,coords_old[0],coords_old[1],coords_old[2]-1,coords_old[3])
            self.start.set(self.start.get()-1)

            self.slider_position['min'].set(100 * (self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.canvas.coords(self.sliders['right']['line'])[0])/self.motion_range)
            self.entry_var['right'].set(self.slider_position['min'].get())

            self.update_plot()




    def set_left_slider_pos(self,event):

        conv = self.entry_var['left'].get()

        if conv.isdecimal():

            conv = int(self.entry_var['left'].get())

            if conv <= 100 and conv >= self.slider_position['min'].get()+10:

                self.slider_position['max'].set(conv)

                self.canvas.coords(self.sliders['left']['box'],self.bar_dimension['x2'] - self.slider_dimension['width'] - self.motion_range * (self.slider_position['max'].get()/100), self.bar_dimension['y1'] ,self.bar_dimension['x2'] - self.motion_range * (self.slider_position['max'].get()/100), self.bar_dimension['y2'])
                self.canvas.coords(self.sliders['left']['line'],self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.motion_range * (self.slider_position['max'].get()/100), self.bar_dimension['y1'], self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.motion_range * (self.slider_position['max'].get()/100), self.bar_dimension['y2'])
                self.canvas.coords(self.filled_bar,self.bar_dimension['x2'] - self.slider_dimension['width'] - self.motion_range * (self.slider_position['max'].get()/100), self.bar_dimension['y1'],self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.motion_range * (self.slider_position['min'].get()/100), self.bar_dimension['y2'])

                self.update_plot()

        else:

            self.parent.bell()



    def set_right_slider_pos(self,event):

        conv = self.entry_var['right'].get()

        if conv.isdecimal():

            conv = int(self.entry_var['right'].get())

            if conv >= 0 and conv <= self.slider_position['max'].get()-10:

                self.slider_position['min'].set(conv)

                self.canvas.coords(self.sliders['right']['box'],self.bar_dimension['x2'] - self.slider_dimension['width'] - self.motion_range * (self.slider_position['min'].get()/100), self.bar_dimension['y1'] ,self.bar_dimension['x2'] - self.motion_range * (self.slider_position['min'].get()/100), self.bar_dimension['y2'])
                self.canvas.coords(self.sliders['right']['line'],self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.motion_range * (self.slider_position['min'].get()/100), self.bar_dimension['y1'], self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.motion_range * (self.slider_position['min'].get()/100), self.bar_dimension['y2'])
                self.canvas.coords(self.filled_bar,self.bar_dimension['x2'] - self.slider_dimension['width'] - self.motion_range * (self.slider_position['max'].get()/100), self.bar_dimension['y1'],self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.motion_range * (self.slider_position['min'].get()/100), self.bar_dimension['y2'])

                self.update_plot()

        else:

            self.parent.bell()





    def button_left_up(self):

        if self.slider_position['max'].get() <= 99:

            self.slider_position['max'].set(self.slider_position['max'].get()+1)
            self.canvas.coords(self.sliders['left']['box'],self.bar_dimension['x2'] - self.slider_dimension['width'] - self.motion_range * (self.slider_position['max'].get()/100), self.bar_dimension['y1'] ,self.bar_dimension['x2'] - self.motion_range * (self.slider_position['max'].get()/100), self.bar_dimension['y2'])
            self.canvas.coords(self.sliders['left']['line'],self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.motion_range * (self.slider_position['max'].get()/100), self.bar_dimension['y1'], self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.motion_range * (self.slider_position['max'].get()/100), self.bar_dimension['y2'])
            self.canvas.coords(self.filled_bar,self.bar_dimension['x2'] - self.slider_dimension['width'] - self.motion_range * (self.slider_position['max'].get()/100), self.bar_dimension['y1'],self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.motion_range * (self.slider_position['min'].get()/100), self.bar_dimension['y2'])
            self.entry_var['left'].set(self.slider_position['max'].get())

            self.update_plot()

        else:

            self.parent.bell()



    def button_left_down(self):

        if self.slider_position['max'].get() >= self.slider_position['min'].get()+11:

            self.slider_position['max'].set(self.slider_position['max'].get()-1)
            self.canvas.coords(self.sliders['left']['box'],self.bar_dimension['x2'] - self.slider_dimension['width'] - self.motion_range * (self.slider_position['max'].get()/100), self.bar_dimension['y1'] ,self.bar_dimension['x2'] - self.motion_range * (self.slider_position['max'].get()/100), self.bar_dimension['y2'])
            self.canvas.coords(self.sliders['left']['line'],self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.motion_range * (self.slider_position['max'].get()/100), self.bar_dimension['y1'], self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.motion_range * (self.slider_position['max'].get()/100), self.bar_dimension['y2'])
            self.canvas.coords(self.filled_bar,self.bar_dimension['x2'] - self.slider_dimension['width'] - self.motion_range * (self.slider_position['max'].get()/100), self.bar_dimension['y1'],self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.motion_range * (self.slider_position['min'].get()/100), self.bar_dimension['y2'])
            self.entry_var['left'].set(self.slider_position['max'].get())

            self.update_plot()

        else:

            self.parent.bell()




    def button_right_up(self):

        if self.slider_position['min'].get() <= self.slider_position['max'].get() - 11:

            self.slider_position['min'].set(self.slider_position['min'].get()+1)
            self.canvas.coords(self.sliders['right']['box'],self.bar_dimension['x2'] - self.slider_dimension['width'] - self.motion_range * (self.slider_position['min'].get()/100), self.bar_dimension['y1'] ,self.bar_dimension['x2'] - self.motion_range * (self.slider_position['min'].get()/100), self.bar_dimension['y2'])
            self.canvas.coords(self.sliders['right']['line'],self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.motion_range * (self.slider_position['min'].get()/100), self.bar_dimension['y1'], self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.motion_range * (self.slider_position['min'].get()/100), self.bar_dimension['y2'])
            self.canvas.coords(self.filled_bar,self.bar_dimension['x2'] - self.slider_dimension['width'] - self.motion_range * (self.slider_position['max'].get()/100), self.bar_dimension['y1'],self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.motion_range * (self.slider_position['min'].get()/100), self.bar_dimension['y2'])
            self.entry_var['right'].set(self.slider_position['min'].get())

            self.update_plot()

        else:

            self.parent.bell()

    def button_right_down(self):

        if self.slider_position['min'].get() >= 1:

            self.slider_position['min'].set(self.slider_position['min'].get()-1)
            self.canvas.coords(self.sliders['right']['box'],self.bar_dimension['x2'] - self.slider_dimension['width'] - self.motion_range * (self.slider_position['min'].get()/100), self.bar_dimension['y1'] ,self.bar_dimension['x2'] - self.motion_range * (self.slider_position['min'].get()/100), self.bar_dimension['y2'])
            self.canvas.coords(self.sliders['right']['line'],self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.motion_range * (self.slider_position['min'].get()/100), self.bar_dimension['y1'], self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.motion_range * (self.slider_position['min'].get()/100), self.bar_dimension['y2'])
            self.canvas.coords(self.filled_bar,self.bar_dimension['x2'] - self.slider_dimension['width'] - self.motion_range * (self.slider_position['max'].get()/100), self.bar_dimension['y1'],self.bar_dimension['x2'] - 0.5*self.slider_dimension['width'] - self.motion_range * (self.slider_position['min'].get()/100), self.bar_dimension['y2'])
            self.entry_var['right'].set(self.slider_position['min'].get())

            self.update_plot()

        else:

            self.parent.bell()




class MyOwnComboBox(tkinter.Frame):

    def __init__(self, root, textvariable, values, command = None, **kwargs):

        self.options = dict()
        self.kwargs = self._get_options(**kwargs)
        self.command = command

        self.parent = root
        self.textvariable = textvariable
        self.values = values

        self.len = len(values)


        tkinter.Frame.__init__(self, root)#, relief = 'solid', borderwidth = 0, highlightbackground = 'red', highlightcolor = 'black', highlightthickness = 1)
        self.frames = dict()
        self.frames['f1'] = tkinter.Frame(self, background = self.options['bordercolor'])
        self.frames['f2'] = tkinter.Frame(self, background = self.options['bordercolor'])
        self.frames['f2_1'] = tkinter.Frame(self.frames['f2'], background = self.options['background'])

        self.label1 = tkinter.Entry(self.frames['f1'], textvariable = self.textvariable, width = self.options['width'], state = 'disabled', bd = 0, justify = 'center', cursor = 'arrow', disabledbackground = self.options['background'], disabledforeground = self.options['foreground'])
        self.label2 = tkinter.Entry(self.frames['f2_1'], text = tkinter.StringVar(None,u'\u2b9f'), width = 3, state = 'disabled', bd = 0, justify = 'center', disabledbackground = self.options['arrow_background'], disabledforeground = self.options['arrow_color'], cursor = 'arrow')

        self.toplevel = None
        self.listbox = None


        self.frames['f1'].grid(row = 0, column = 0)
        self.frames['f2'].grid(row = 0, column = 1)
        self.frames['f2_1'].grid(row = 0, column = 0, padx = (0,1), pady = (1,1))
        self.label1.grid(row = 0, column = 0, padx = (1,0), pady = (1,1))
        self.label2.grid(row = 0, column = 0, padx = (1,0))

        self.label1.bind('<Button-1>', self.onClick_open)
        self.label2.bind('<Button-1>', self.onClick_open)
        self.label1.bind('<Enter>', self._text_on_enter)
        self.label1.bind('<Leave>', self._text_on_leave)
        self.label2.bind('<Enter>', self._arrow_on_enter)
        self.label2.bind('<Leave>', self._arrow_on_leave)





    def onClick_open(self,event):

        self.label2.configure(disabledbackground = self.options['arrow_activebackground'])
        x = self.winfo_rootx()
        y = self.winfo_rooty() + self.winfo_height()

        self.toplevel = tkinter.Toplevel()
        self.toplevel.wm_overrideredirect(True)

        frame = tkinter.Frame(self.toplevel, background = self.options['background'], borderwidth = 0, highlightbackground = self.options['activebordercolor'], highlightcolor = 'black', highlightthickness = 1)

        self.listbox = tkinter.Listbox(frame, height = self.len, width = self.options['width']+3, justify = 'center', bg = self.options['background'], fg = self.options['foreground'], selectbackground = self.options['selectbackground'], activestyle = 'none', bd = 0, highlightthickness = 1, highlightbackground = self.options['background'], highlightcolor = self.options['background'], relief = 'flat')

        for v in self.values:

            self.listbox.insert('end', v)


        w = self.listbox.winfo_reqwidth() + 5
        h = self.listbox.winfo_reqheight() + 2

        self.toplevel.wm_geometry("%dx%d+%d+%d" % (w,h,x, y))
        frame.pack(expand = 1, fill = 'both')
        self.listbox.pack(expand = 1, fill = 'both')

        self.frames['f2'].configure(background = self.options['activebordercolor'])
        self.frames['f2_1'].configure(background = self.options['activebordercolor'])

        self.toplevel.focus_set()

        self.label1.unbind('<Button-1>')
        self.label2.unbind('<Button-1>') #FocusOut and ButtonPress would trigger from the same event if clicking on label1,2
        #self.label1.bind('<Button-1>', self.onClick_close)
        #self.label2.bind('<Button-1>', self.onClick_close)
        self.listbox.bind('<Motion>', self.mouse_hover)
        self.listbox.bind('<Button-1>', self.select_item)
        self.toplevel.bind('<FocusOut>', self.focus_out)

        self.label1.unbind('<Leave>')
        self.label2.unbind('<Leave>')


    def set_state(self,state):

        if state == 'disabled':

            self.label1.unbind('<Button-1>')
            self.label2.unbind('<Button-1>')
            self.label1.unbind('<Enter>')
            self.label1.unbind('<Leave>')
            self.label2.unbind('<Enter>')
            self.label2.unbind('<Leave>')
            self.label1.configure(disabledbackground = self.options['disabledbackground'], disabledforeground = self.options['disabledforeground'])
            self.label2.configure(disabledbackground = self.options['disabledbackground'], disabledforeground = self.options['disabledforeground'])

        elif state == 'normal':

            self.label1.bind('<Button-1>', self.onClick_open)
            self.label2.bind('<Button-1>', self.onClick_open)
            self.label1.bind('<Enter>', self._text_on_enter)
            self.label1.bind('<Leave>', self._text_on_leave)
            self.label2.bind('<Enter>', self._arrow_on_enter)
            self.label2.bind('<Leave>', self._arrow_on_leave)
            self.label1.configure(disabledbackground = self.options['background'], disabledforeground = self.options['foreground'])
            self.label2.configure(disabledbackground = self.options['background'], disabledforeground = self.options['foreground'])





    def focus_out(self, event = None):

        self.toplevel.destroy()
        self.listbox = None
        self.toplevel = None

        self.frames['f1'].configure(background = self.options['activebordercolor'])
        self.frames['f2'].configure(background = self.options['activebordercolor'])
        self.frames['f2_1'].configure(background = self.options['background'])

        #self.label1.bind('<Button-1>', self.onClick_open) #binding here would be triggered by the buttonpress event. if clicked on label1,2
        #self.label2.bind('<Button-1>', self.onClick_open)
        self.label2.configure(disabledbackground = self.options['background'])

        self._text_on_leave()
        self._arrow_on_leave()

        self.label1.bind('<Leave>', self._text_on_leave)
        self.label2.bind('<Leave>', self._arrow_on_leave)
        self.label2.after(1,self._re_bind)




    def _re_bind(self):
        self.label1.bind('<Button-1>', self.onClick_open)
        self.label2.bind('<Button-1>', self.onClick_open)




    def onClick_close(self, event = None): #still used when entry selected

        self.toplevel.destroy()
        self.listbox = None
        self.toplevel = None

        self.frames['f1'].configure(background = self.options['activebordercolor'])
        self.frames['f2'].configure(background = self.options['activebordercolor'])
        self.frames['f2_1'].configure(background = self.options['background'])

        self._text_on_leave()
        self._arrow_on_leave()

        self.label1.bind('<Leave>', self._text_on_leave)
        self.label2.bind('<Leave>', self._arrow_on_leave)
        self.label1.bind('<Button-1>', self.onClick_open)
        self.label2.bind('<Button-1>', self.onClick_open)
        self.label2.configure(disabledbackground = self.options['background'])




    def _arrow_on_enter(self, event = None):

        self.label2.configure(disabledbackground = self.options['arrow_activebackground'])
        self.frames['f1'].configure(background = self.options['activebordercolor'])
        self.frames['f2'].configure(background = self.options['arrow_activebordercolor'])
        self.frames['f2_1'].configure(background = self.options['arrow_activebordercolor'])




    def _arrow_on_leave(self, event = None):

        self.label2.configure(disabledbackground = self.options['background'])
        self.frames['f1'].configure(background = self.options['bordercolor'])
        self.frames['f2'].configure(background = self.options['bordercolor'])
        self.frames['f2_1'].configure(background = self.options['background'])




    def _text_on_enter(self, event = None):

        self.frames['f1'].configure(background = self.options['activebordercolor'])
        self.frames['f2'].configure(background = self.options['activebordercolor'])




    def _text_on_leave(self, event = None):

        self.frames['f1'].configure(background = self.options['bordercolor'])
        self.frames['f2'].configure(background = self.options['bordercolor'])




    def mouse_hover(self, event):

        #self.toplevel.winfo_height() #height seems to be number_entries*16+2 #2 is probably from the highlightborder
        self.listbox.selection_clear(0, last = self.len)
        #self.listbox.selection_set(int(event.y*self.len/(16*self.len+2)))
        self.listbox.selection_set(int(event.y*self.len/self.toplevel.winfo_height()))



    def select_item(self, event):
        #print(self.toplevel.winfo_width(),self.toplevel.winfo_height())
        #self.textvariable.set(self.values[int(event.y*self.len/(16*self.len+2))])
        self.textvariable.set(self.values[int(event.y*self.len/self.toplevel.winfo_height())])
        self.command()
        self.onClick_close()




    def _get_options(self, **kwargs):

        self.options['width'] = kwargs.pop('width',10)
        self.options['foreground'] = kwargs.pop('foreground', None)
        self.options['arrow_color'] = kwargs.pop('arrow_color', None)
        self.options['background'] = kwargs.pop('background', None)
        self.options['disabledbackground'] = kwargs.pop('disabledbackground', None)
        self.options['disabledforeground'] = kwargs.pop('disabledforeground', None)
        self.options['arrow_background'] = kwargs.pop('arrow_background', None)
        self.options['arrow_activebackground'] = kwargs.pop('arrow_activebackground', None)
        self.options['selectbackground'] = kwargs.pop('selectbackground', None)
        self.options['bordercolor'] = kwargs.pop('bordercolor', None)
        self.options['activebordercolor'] = kwargs.pop('activebordercolor', None)
        self.options['arrow_activebordercolor'] = kwargs.pop('arrow_activebordercolor', None)

        # self.options['foreground'] = kwargs.pop('foreground','#000000')
        # self.options['arrow_color'] = kwargs.pop('arrow_color','#000000')
        # self.options['background'] = kwargs.pop('background','#ffffff')
        # self.options['arrow_background'] = kwargs.pop('arrow_background',self.options['background'])
        # self.options['arrow_activebackground'] = kwargs.pop('arrow_activebackground','#e5f1fb')
        # self.options['selectbackground'] = kwargs.pop('selectbackground','#0078d7')
        # self.options['bordercolor'] = kwargs.pop('bordercolor','#949494')
        # self.options['activebordercolor'] = kwargs.pop('activebordercolor','#4e4e4e')
        # self.options['arrow_activebordercolor'] = kwargs.pop('arrow_activebordercolor','#0176d7')

        return kwargs







# I propose to call self.hidetip() before self.tw = tk.Toplevel(self.widget). Otherwise tooltip sometimes hang up.
class CreateToolTip():
    """
    create a tooltip for a given widget
    """
    def __init__(self, widget, text='widget info'):
        self.waittime = 100     #miliseconds
        self.wraplength = 250   #pixels
        self.widget = widget
        self.text = text
        self.widget.bind("<Enter>", self.enter)
        self.widget.bind("<Leave>", self.leave)
        self.widget.bind("<ButtonPress>", self.leave)
        self.id = None
        self.tw = None

    def enter(self, event=None):
        self.schedule()

    def leave(self, event=None):
        self.unschedule()
        self.hidetip()

    def schedule(self):
        self.unschedule()
        self.id = self.widget.after(self.waittime, self.showtip)

    def unschedule(self):
        id = self.id
        self.id = None
        if id:
            self.widget.after_cancel(id)

    def showtip(self, event=None):
        x = y = 0
        x, y, cx, cy = self.widget.bbox("insert")
        x += self.widget.winfo_rootx() + 25
        y += self.widget.winfo_rooty() + 20
        # creates a toplevel window
        self.hidetip()
        self.tw = tkinter.Toplevel(self.widget)

        self.tw.wm_overrideredirect(True) # Leaves only the label and removes the app window
        self.tw.wm_geometry("+%d+%d" % (x, y))
        label = tkinter.Label(self.tw, text=self.text, justify = 'left', background = "#fff6d5", relief = 'solid', borderwidth = 1, wraplength = self.wraplength)
        label.pack(ipadx=1)

    def hidetip(self):
        tw = self.tw
        self.tw= None
        if tw:
            tw.destroy()







class _Helper_Functions_GUI():

    @staticmethod
    def _set_color_options(color_scheme = 'dark'):

        color_scheme = dict() #taken from atom dark
        color_scheme['background'] = '#2c3037'
        color_scheme['background_dark'] = '#26292e'
        color_scheme['background_light'] = '#404651'
        color_scheme['background_input_dark'] = '#202227'
        #color_scheme['background_input_dark'] = '#0d0f11' #dark version

        #color_scheme['background_input_disabled'] = '#333840'
        color_scheme['background_input_disabled'] = '#262a31' #dark version
        #color_scheme['separator'] = '#d6d9df'
        color_scheme['separator'] = '#95979a'

        color_scheme['figure_background'] = '#2c3037'
        #color_scheme['figure_background'] = '#262a31' #dark version

        #self.color_scheme['text_standard'] = '#a9b1bd' #original
        color_scheme['text_standard'] = '#d6d9df'
        color_scheme['text_highlighted'] = '#63afe9' #blue
        color_scheme['text_error'] = '#de6b74' #red
        #color_scheme['text_disabled'] = '#545c6b'#'#404651'
        color_scheme['text_disabled'] = '#6d6d6d'
        color_scheme['highlighted'] = '#97c07d' #green
        color_scheme['text_selectbackground'] = '#3c5687' #'#4f7ac7'

        color_scheme['border'] = '#1e2024'
        color_scheme['border_active'] = '#676d7b'
        color_scheme['button'] = '#2c3037'
        #color_scheme['button'] = '#3a3f49'


        # self.color_scheme['background'] = None
        # self.color_scheme['background_dark'] = None
        # self.color_scheme['background_light'] = None
        # self.color_scheme['background_input_dark'] = None
        # self.color_scheme['text_standard'] = None
        # self.color_scheme['text_highlighted'] = None
        # self.color_scheme['text_disabled'] = None
        # self.color_scheme['highlighted'] = None
        # self.color_scheme['text_selectbackground'] = None
        #
        # self.color_scheme['border'] = None
        # self.color_scheme['border_active'] = None
        # self.color_scheme['button'] = None

        return color_scheme


    @staticmethod
    def _get_colormaps_imshow():

        return ['viridis', 'plasma', 'inferno', 'magma', 'cividis', 'Greys', 'Purples', 'Blues', 'Greens', 'Oranges', 'Reds', 'YlOrBr', 'YlOrRd', 'OrRd', 'PuRd', 'RdPu', 'BuPu', 'GnBu', 'PuBu', 'YlGnBu', 'PuBuGn', 'BuGn', 'YlGn', 'binary', 'gist_yarg', 'gist_gray', 'gray', 'bone', 'pink', 'spring', 'summer', 'autumn', 'winter', 'cool', 'Wistia', 'hot', 'afmhot', 'gist_heat', 'copper', 'PiYG', 'PRGn', 'BrBG', 'PuOr', 'RdGy', 'RdBu', 'RdYlBu', 'RdYlGn', 'Spectral', 'coolwarm', 'bwr', 'seismic', 'twilight', 'twilight_shifted', 'hsv', 'Pastel1', 'Pastel2', 'Paired', 'Accent', 'Dark2', 'Set1', 'Set2', 'Set3', 'tab10', 'tab20', 'tab20b', 'tab20c', 'flag', 'prism', 'ocean', 'gist_earth', 'terrain', 'gist_stern', 'gnuplot', 'gnuplot2', 'CMRmap', 'cubehelix', 'brg', 'gist_rainbow', 'rainbow', 'jet', 'nipy_spectral', 'gist_ncar']











    #dummy


class _Helper_Functions_General():

    @staticmethod
    def combine_tuple(list_of_tuple, max_separation_2_tuple):

        new_list = list()
        i = 0

        while i < len(list_of_tuple):

            if i < len(list_of_tuple)-1 and list_of_tuple[i][1]+max_separation_2_tuple >= list_of_tuple[i+1][0]:

                new_list.append((list_of_tuple[i][0],list_of_tuple[i+1][1]))
                i += 2

            else:

                new_list.append((list_of_tuple[i][0],list_of_tuple[i][1]))
                i += 1



        if not list_of_tuple == new_list:

            new_list = combine_tuple(new_list, max_separation_2_tuple)


        return new_list





def parabolic_hertz_fit(contact_point, baseline):
    def parabolic_hertz(x, a):

        ret = np.array(x)
        ret = ret-contact_point
        ret[ret<0] = 0

        return a * ret ** (3/2) + baseline
    return parabolic_hertz


def parabolic_hertz(x, a, contact_point, baseline):

    ret = np.array(x)
    ret = ret-contact_point
    ret[ret<0] = 0

    return a * ret ** (3/2) + baseline



def conical_hertz_fit(contact_point, baseline):
    def conical_hertz(x, a):

        ret = np.array(x)
        ret = ret-contact_point
        ret[ret<0] = 0

        return a * ret ** 2 + baseline
    return conical_hertz


def conical_hertz(x, a, contact_point, baseline):

    ret = np.array(x)
    ret = ret-contact_point
    ret[ret<0] = 0

    return a * ret ** 2 + baseline



def four_side_pyramid_hertz_fit(contact_point, baseline):
    def four_side_pyramid_hertz(x, a):

        ret = np.array(x)
        ret = ret-contact_point
        ret[ret<0] = 0

        return a * ret ** 2 + baseline
    return four_side_pyramid_hertz


def four_side_pyramid_hertz(x, a, contact_point, baseline):

    ret = np.array(x)
    ret = ret-contact_point
    ret[ret<0] = 0

    return a * ret ** 2 + baseline




def cylindrical_hertz_fit(contact_point, baseline):
    def cylindrical_hertz(x, a):

        ret = np.array(x)
        ret = ret-contact_point
        ret[ret<0] = 0

        return a * ret + baseline
    return cylindrical_hertz


def cylindrical_hertz(x, a, contact_point, baseline):

    ret = np.array(x)
    ret = ret-contact_point
    ret[ret<0] = 0

    return a * ret + baseline





def radius_contact_circle(x, R, ind):

    return x/2 * np.log((R+x)/(R-x)) - ind


def spherical_hertz_fit(contact_point, baseline, R, conv_list):
    def spherical_hertz(x,a):

        ret = np.array(x)
        ret = ret-contact_point
        ret[ret<0] = 0

        contact_radius = conv_list.convert_np_array(ret)


        return a * ((0.5*(contact_radius**2+R**2))*np.log((R+contact_radius)/(R-contact_radius)) - R*contact_radius) + baseline
    return spherical_hertz




def spherical_hertz(x, a, contact_point, baseline, R, conv_list):

    ret = np.array(x)
    ret = ret-contact_point
    ret[ret<0] = 0

    contact_radius = conv_list.convert_np_array(ret)

    return a * ((0.5*(contact_radius**2+R**2))*np.log((R+contact_radius)/(R-contact_radius)) - R*contact_radius) + baseline


#def spherical_hertz_fit_batch(baseline, R):
#    def spherical_hertz_batch(contact_radius,a):
#
#        return a * ((0.5*(contact_radius**2+R**2))*np.log((R+contact_radius)/(R-contact_radius)) - R*contact_radius) + baseline
#    return spherical_hertz_batch
#
#
#def spherical_hertz_batch(contact_radius, a, baseline, R):
#
#    return a * ((0.5*(contact_radius**2+R**2))*np.log((R+contact_radius)/(R-contact_radius)) - R*contact_radius) + baseline
#



#
#
def parabolic_hertz_fit_new(contact_point, baseline, unused_arg1, unused_arg2):
    def parabolic_hertz_new(x, a):

        ret = np.array(x)
        ret = ret-contact_point
        ret[ret<0] = 0

        return a * ret ** (3/2) + baseline
    return parabolic_hertz_new


def parabolic_hertz_new(x, a, contact_point, baseline, unused_arg1, unused_arg2):

    ret = np.array(x)
    ret = ret-contact_point
    ret[ret<0] = 0

    return a * ret ** (3/2) + baseline


#
#
def conical_hertz_fit_new(contact_point, baseline, unused_arg1, unused_arg2):
    def conical_hertz_new(x, a):

        ret = np.array(x)
        ret = ret-contact_point
        ret[ret<0] = 0

        return a * ret ** 2 + baseline
    return conical_hertz_new


def conical_hertz_new(x, a, contact_point, baseline, unused_arg1, unused_arg2):

    ret = np.array(x)
    ret = ret-contact_point
    ret[ret<0] = 0

    return a * ret ** 2 + baseline


#
#
def cylindrical_hertz_fit_new(contact_point, baseline, unused_arg1, unused_arg2):
    def cylindrical_hertz_new(x, a):

        ret = np.array(x)
        ret = ret-contact_point
        ret[ret<0] = 0

        return a * ret + baseline
    return cylindrical_hertz_new


def cylindrical_hertz_new(x, a, contact_point, baseline, unused_arg1, unused_arg2):

    ret = np.array(x)
    ret = ret-contact_point
    ret[ret<0] = 0

    return a * ret + baseline


#
#
def four_side_pyramid_hertz_fit_new(contact_point, baseline, unused_arg1, unused_arg2):
    def four_side_pyramid_hertz_new(x, a):

        ret = np.array(x)
        ret = ret-contact_point
        ret[ret<0] = 0

        return a * ret ** 2 + baseline
    return four_side_pyramid_hertz_new


def four_side_pyramid_hertz_new(x, a, contact_point, baseline, unused_arg1, unused_arg2):

    ret = np.array(x)
    ret = ret-contact_point
    ret[ret<0] = 0

    return a * ret ** 2 + baseline


#
#

def spherical_hertz_fit_new(contact_point, baseline, R, conv_list):
    def spherical_hertz_new(x,a):

        ret = np.array(x)
        ret = ret-contact_point
        ret[ret<0] = 0

        contact_radius = conv_list.convert_np_array(ret)


        return a * ((0.5*(contact_radius**2+R**2))*np.log((R+contact_radius)/(R-contact_radius)) - R*contact_radius) + baseline
    return spherical_hertz_new




def spherical_hertz_new(x, a, contact_point, baseline, R, conv_list):

    ret = np.array(x)
    ret = ret-contact_point
    ret[ret<0] = 0

    contact_radius = conv_list.convert_np_array(ret)

    return a * ((0.5*(contact_radius**2+R**2))*np.log((R+contact_radius)/(R-contact_radius)) - R*contact_radius) + baseline





def e_modul_parabolic(fit_param, poisson_ratio,indenter_geometry_detail):

    return  fit_param * (1 - poisson_ratio**2) * 3 / (4 * math.sqrt(indenter_geometry_detail))

def e_modul_conical(fit_param, poisson_ratio,indenter_geometry_detail):

    return  fit_param * (1 - poisson_ratio**2) * np.pi / (2 * math.tan(indenter_geometry_detail * np.pi / 180))

def e_modul_four_sided_pyramid(fit_param, poisson_ratio,indenter_geometry_detail):

    return  fit_param * (1 - poisson_ratio**2) / (0.7453 * math.tan(indenter_geometry_detail * np.pi / 180))

def e_modul_cylindrical(fit_param, poisson_ratio,indenter_geometry_detail):

    return  fit_param * (1 - poisson_ratio**2) / (2 * indenter_geometry_detail)

def e_modul_spherical(fit_param, poisson_ratio,indenter_geometry_detail):

    return  fit_param * (1 - poisson_ratio**2)


#%% helper functions

def combine_tuple(l, n):

    new_list = list()
    i = 0

    while i < len(l):

        if i < len(l)-1 and l[i][1]+n >= l[i+1][0]:

            new_list.append((l[i][0],l[i+1][1]))
            i += 2

        else:

            new_list.append((l[i][0],l[i][1]))
            i += 1



    if not l == new_list:

        new_list = combine_tuple(new_list, n)


    return new_list


#%% other stuff








def create_index_list(index):

    len_index = len(index)

    index_list = list()

    for i in range(0, len_index):

        if type(index[i]) is tuple and len(index[i]) == 2:

            if type(index[i][0]) is int and type(index[i][1]) is int:

                if index[i][0] < index[i][1]:

                    for j in range(index[i][0], index[i][1] + 1):

                        index_list.append(j)

                else:

                    raise ValueError('ERROR! Sepcify intervall in ascending order!')


            else:

                raise ValueError('ERROR! Given index is not of type int!')


        elif type(index[i]) is tuple and not len(index[i]) == 2:

            raise ValueError('ERROR! Given tuple length is not 2!')


        elif type(index[i]) is int:

            index_list.append(index[i])


        else:

            raise ValueError('ERROR! Given index is not of type int!')

    # remove duplicates
    index_list_final = list(set(index_list))

    index_list_final.sort()


    return index_list_final




def popupmsg(msg):

   tkinter.messagebox.showinfo("",msg)
